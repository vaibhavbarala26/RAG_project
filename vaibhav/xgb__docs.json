[
{"chunk_id": "chunk_0", "url": "https://xgboost.readthedocs.io/en/stable/index.html", "title": "XGBoost Documentation", "page_title": "XGBoost Documentation — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Documentation", "content": "XGBoost Documentation XGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Hadoop, SGE, MPI) and can solve problems beyond billions of examples.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_1", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "Installation Guide", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "Installation Guide", "content": "Installation Guide XGBoost provides binary packages for some language bindings. The binary packages support the GPU algorithm (device=cuda:0) on machines with NVIDIA GPUs. Please note that training with multiple GPUs is only supported for Linux platform. See XGBoost GPU Support. Also we have both stable releases and nightly builds, see below for how to install them. For building from source, visit this page.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_2", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "Python", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "Python", "content": "Python Pre-built binary wheels are uploaded to PyPI (Python Package Index) for each release. Supported platforms are Linux (x86_64, aarch64), Windows (x86_64) and MacOS (x86_64, Apple Silicon). # Pip 21.3+ is required pip install xgboost You might need to run the command with --user flag or use virtualenv if you run into permission errors. Capabilities of binary wheels for each platform: Platform | GPU | Multi-Node-Multi-GPU Linux x86_64 | ✔ | ✔ Linux aarch64 | ✘ | ✘ MacOS x86_64 | ✘ | ✘ MacOS Apple Silicon | ✘ | ✘ Windows | ✔ | ✘", "prev_chunk_id": "chunk_1", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_3", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "Minimal installation (CPU-only)", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "Minimal installation (CPU-only)", "content": "Minimal installation (CPU-only) The default installation with pip will install the full XGBoost package, including the support for the GPU algorithms and federated learning. You may choose to reduce the size of the installed package and save the disk space, by opting to install xgboost-cpu instead: pip install xgboost-cpu The xgboost-cpu variant will have drastically smaller disk footprint, but does not provide some features, such as the GPU algorithms and federated learning. Currently, xgboost-cpu package is provided for x86_64 (amd64) Linux and Windows platforms.", "prev_chunk_id": "chunk_2", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_4", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "Conda", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "Conda", "content": "Conda You may use the Conda packaging manager to install XGBoost: conda install -c conda-forge py-xgboost Conda should be able to detect the existence of a GPU on your machine and install the correct variant of XGBoost. If you run into issues, try indicating the variant explicitly: # CPU variant conda install -c conda-forge py-xgboost=*=cpu* # GPU variant conda install -c conda-forge py-xgboost=*=cuda* To force the installation of the GPU variant on a machine that does not have an NVIDIA GPU, use environment variable CONDA_OVERRIDE_CUDA, as described in “Managing Virtual Packages” in the conda docs. export CONDA_OVERRIDE_CUDA=\"12.8\" conda install -c conda-forge py-xgboost=*=cuda* You can install Conda from the following link: Download the conda-forge Installer.", "prev_chunk_id": "chunk_3", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_5", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "R", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "R", "content": "R - From R Universe install.packages('xgboost', repos = c('https://dmlc.r-universe.dev', 'https://cloud.r-project.org')) - We also provideexperimentalpre-built binary with GPU support. With this binary, you will be able to use the GPU algorithm without building XGBoost from the source. Download the binary package from the Releases page. The file name will be of the formxgboost_r_gpu_[os]_[version].tar.gz, where[os]is eitherlinuxorwin64. (We build the binaries for 64-bit Linux and Windows.) Then install XGBoost by running:# Install dependenciesR-q-e\"install.packages(c('data.table', 'jsonlite'))\"# Install XGBoostRCMDINSTALL./xgboost_r_gpu_linux.tar.gz - From CRAN (outdated): install.packages(\"xgboost\")", "prev_chunk_id": "chunk_4", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_6", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "JVM", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "JVM", "content": "JVM - XGBoost4j-Spark - XGBoost4j-Spark-GPU This will check out the latest stable version from the Maven Central. For the latest release version number, please check release page. To enable the GPU algorithm (device='cuda'), use artifacts xgboost4j-spark-gpu_2.12 instead (note the gpu suffix).", "prev_chunk_id": "chunk_5", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_7", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "Python", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "Python", "content": "Python Nightly builds are available. You can go to this page, find the wheel with the commit ID you want and install it with pip: pip install <url to the wheel> The capability of Python pre-built wheel is the same as stable release.", "prev_chunk_id": "chunk_6", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_8", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "R", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "R", "content": "R Other than standard CRAN installation, we also provide experimental pre-built binary on with GPU support. You can go to this page, Find the commit ID you want to install and then locate the file xgboost_r_gpu_[os]_[commit].tar.gz, where [os] is either linux or win64. (We build the binaries for 64-bit Linux and Windows.) Download it and run the following commands: # Install dependencies R -q -e \"install.packages(c('data.table', 'jsonlite', 'remotes'))\" # Install XGBoost R CMD INSTALL ./xgboost_r_gpu_linux.tar.gz", "prev_chunk_id": "chunk_7", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_9", "url": "https://xgboost.readthedocs.io/en/stable/install.html", "title": "JVM", "page_title": "Installation Guide — xgboost 3.0.4 documentation", "breadcrumbs": "JVM", "content": "JVM - XGBoost4j/XGBoost4j-Spark Then add XGBoost4J-Spark as a dependency: - XGBoost4j-Spark-GPU Look up the version field in pom.xml to get the correct version number. The SNAPSHOT JARs are hosted by the XGBoost project. Every commit in the master branch will automatically trigger generation of a new SNAPSHOT JAR. You can control how often Maven should upgrade your SNAPSHOT installation by specifying updatePolicy. See here for details. You can browse the file listing of the Maven repository at https://s3-us-west-2.amazonaws.com/xgboost-maven-repo/list.html. To enable the GPU algorithm (device='cuda'), use artifacts xgboost4j-gpu_2.12 and xgboost4j-spark-gpu_2.12 instead (note the gpu suffix).", "prev_chunk_id": "chunk_8", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_10", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building From Source", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building From Source", "content": "Building From Source This page gives instructions on how to build and install XGBoost from the source code on various systems. If the instructions do not work for you, please feel free to ask questions at GitHub.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_11", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Obtaining the Source Code", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Obtaining the Source Code", "content": "Obtaining the Source Code To obtain the development repository of XGBoost, one needs to use git. XGBoost uses Git submodules to manage dependencies. So when you clone the repo, remember to specify --recursive option:", "prev_chunk_id": "chunk_10", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_12", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building the Shared Library", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building the Shared Library", "content": "Building the Shared Library This section describes the procedure to build the shared library and CLI interface independently. For building language specific package, see corresponding sections in this document. - On Linux and other UNIX-like systems, the target library islibxgboost.so - On MacOS, the target library islibxgboost.dylib - On Windows the target library isxgboost.dll This shared library is used by different language bindings (with some additions depending on the binding you choose). The minimal building requirement is - A recent C++ compiler supporting C++17. We use gcc, clang, and MSVC for daily testing. Mingw is only used for the R package and has limited features. - CMake 3.18 or higher. For a list of CMake options like GPU support, see #-- Options in CMakeLists.txt on top level of source tree. We use ninja for build in this document, specified via the CMake flag -GNinja. If you prefer other build tools like make or Visual Studio 17 2022, please change the corresponding CMake flags. Consult the CMake generator document when needed.", "prev_chunk_id": "chunk_11", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_13", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Running CMake and build", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Running CMake and build", "content": "Running CMake and build After obtaining the source code, one builds XGBoost by running CMake: cd xgboost cmake -B build -S . -DCMAKE_BUILD_TYPE=RelWithDebInfo -GNinja cd build && ninja The same command applies for both Unix-like systems and Windows. After running the build, one should see a shared object under the xgboost/lib directory. - Building on MacOSOn MacOS, one needs to obtainlibompfromHomebrewfirst:brewinstalllibomp - Visual StudioThe latest Visual Studio has builtin support for CMake projects. If you prefer using an IDE over the command line, you can use theopenwithvisualstudiooption in the right-click menu under thexgboostsource directory. Consult the VSdocumentfor more info.", "prev_chunk_id": "chunk_12", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_14", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building with GPU support", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building with GPU support", "content": "Building with GPU support XGBoost can be built with GPU support for both Linux and Windows using CMake. See Building R package with GPU support for special instructions for R. An up-to-date version of the CUDA toolkit is required. Some distros package a compatible gcc version with CUDA. If you run into compiler errors with nvcc, try specifying the correct compiler with -DCMAKE_CXX_COMPILER=/path/to/correct/g++ -DCMAKE_C_COMPILER=/path/to/correct/gcc. On Arch Linux, for example, both binaries can be found under /opt/cuda/bin/. In addition, the CMAKE_CUDA_HOST_COMPILER parameter can be useful. From the command line on Linux starting from the XGBoost directory, add the USE_CUDA flag: cmake -B build -S . -DUSE_CUDA=ON -GNinja cd build && ninja To speed up compilation, the compute version specific to your GPU could be passed to cmake as, e.g., -DCMAKE_CUDA_ARCHITECTURES=75. A quick explanation and numbers for some architectures can be found in this page. - Faster distributed GPU training with NCCLBy default, distributed GPU training is enabled with the optionUSE_NCCL=ON. Distributed GPU training depends on NCCL2, available atthis link. Since NCCL2 is only available for Linux machines,Distributed GPU training is available only for Linux.cmake-Bbuild-S.-DUSE_CUDA=ON-DUSE_NCCL=ON-DNCCL_ROOT=/path/to/nccl2-GNinjacdbuild&&ninjaSome additional flags are available for NCCL,BUILD_WITH_SHARED_NCCLenables building XGBoost with NCCL as a shared library, whileUSE_DLOPEN_NCCLenables XGBoost to load NCCL at runtime usingdlopen.", "prev_chunk_id": "chunk_13", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_15", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Federated Learning", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Federated Learning", "content": "Federated Learning The federated learning plugin requires grpc and protobuf. To install grpc, refer to the installation guide from the gRPC website. Alternatively, one can use the libgrpc and the protobuf package from conda forge if conda is available. After obtaining the required dependencies, enable the flag: -DPLUGIN_FEDERATED=ON when running CMake. Please note that only Linux is supported for the federated plugin. cmake -B build -S . -DPLUGIN_FEDERATED=ON -GNinja cd build && ninja", "prev_chunk_id": "chunk_14", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_16", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building Python Package from Source", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building Python Package from Source", "content": "Building Python Package from Source The Python package is located at python-package/.", "prev_chunk_id": "chunk_15", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_17", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building Python Package with Default Toolchains", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building Python Package with Default Toolchains", "content": "Building Python Package with Default Toolchains There are several ways to build and install the package from source: - Build C++ core with CMake first - Install the Python package directly - Editable installation - Reuse thelibxgboost.soon system path.", "prev_chunk_id": "chunk_16", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_18", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building R Package From Source", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building R Package From Source", "content": "Building R Package From Source By default, the package installed by running install.packages is built from source using the package from CRAN. Here we list some other options for installing development version.", "prev_chunk_id": "chunk_17", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_19", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Installing the development version (Linux / Mac OSX)", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Installing the development version (Linux / Mac OSX)", "content": "Installing the development version (Linux / Mac OSX) Make sure you have installed git and a recent C++ compiler supporting C++11 (See above sections for requirements of building C++ core). Due to the use of git-submodules, remotes::install_github() cannot be used to install the latest version of R package. Thus, one has to run git to check out the code first, see Obtaining the Source Code on how to initialize the git repository for XGBoost. The simplest way to install the R package after obtaining the source code is: cd R-package R CMD INSTALL . Use the environment variable MAKEFLAGS=-j$(nproc) if you want to speedup the build. As an alternative, the package can also be loaded through devtools::load_all() from the same subfolder R-package in the repository’s root, and by extension, can be installed through RStudio’s build panel if one adds that folder R-package as an R package project in the RStudio IDE. library(devtools) devtools::load_all(path = \"/path/to/xgboost/R-package\") On Linux, if you want to use the CMake build for greater flexibility around compile flags, the earlier snippet can be replaced by: cmake -B build -S . -DR_LIB=ON -GNinja cd build && ninja install Note in this case that cmake will not take configurations from your regular Makevars file (if you have such a file under ~/.R/Makevars) - instead, custom configurations such as compilers to use and flags need to be set through CMake variables like -DCMAKE_CXX_COMPILER.", "prev_chunk_id": "chunk_18", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_20", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building R package with GPU support", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building R package with GPU support", "content": "Building R package with GPU support The procedure and requirements are similar as in Building with GPU support, so make sure to read it first. On Linux, starting from the XGBoost directory type: cmake -B build -S . -DUSE_CUDA=ON -DR_LIB=ON cmake --build build --target install -j$(nproc) When default target is used, an R package shared library would be built in the build area. The install target, in addition, assembles the package files with this shared library under build/R-package and runs R CMD INSTALL.", "prev_chunk_id": "chunk_19", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_21", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building JVM Packages", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building JVM Packages", "content": "Building JVM Packages Building XGBoost4J using Maven requires Maven 3 or newer, Java 7+ and CMake 3.18+ for compiling Java code as well as the Java Native Interface (JNI) bindings. In addition, a Python script is used during configuration, make sure the command python is available on your system path (some distros use the name python3 instead of python). Before you install XGBoost4J, you need to define environment variable JAVA_HOME as your JDK directory to ensure that your compiler can find jni.h correctly, since XGBoost4J relies on JNI to implement the interaction between the JVM and native libraries. After your JAVA_HOME is defined correctly, it is as simple as run mvn package under jvm-packages directory to install XGBoost4J. You can also skip the tests by running mvn -DskipTests=true package, if you are sure about the correctness of your local setup. To publish the artifacts to your local maven repository, run mvn install Or, if you would like to skip tests, run mvn -DskipTests install This command will publish the xgboost binaries, the compiled java classes as well as the java sources to your local repository. Then you can use XGBoost4J in your Java projects by including the following dependency in pom.xml: <dependency> <groupId>ml.dmlc</groupId> <artifactId>xgboost4j</artifactId> <version>latest_source_version_num</version> </dependency> For sbt, please add the repository and dependency in build.sbt as following: resolvers += \"Local Maven Repository\" at \"file://\"+Path.userHome.absolutePath+\"/.m2/repository\" \"ml.dmlc\" % \"xgboost4j\" % \"latest_source_version_num\" If you want to use XGBoost4J-Spark, replace xgboost4j with xgboost4j-spark.", "prev_chunk_id": "chunk_20", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_22", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Additional System-dependent Features", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Additional System-dependent Features", "content": "Additional System-dependent Features - OpenMP on MacOS: SeeRunning CMake and buildfor installingopenmp. The flag -mvn-Duse.openmp=OFFcan be used to disable OpenMP support. - GPU support can be enabled by passing an additional flag to mavenmvn-Duse.cuda=ONinstall. SeeBuilding with GPU supportfor more info. In addition,-Dplugin.rmm=ONcan enable the optional RMM support.", "prev_chunk_id": "chunk_21", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_23", "url": "https://xgboost.readthedocs.io/en/stable/build.html", "title": "Building the Documentation", "page_title": "Building From Source — xgboost 3.0.4 documentation", "breadcrumbs": "Building the Documentation", "content": "Building the Documentation XGBoost uses Sphinx for documentation. To build it locally, you need a installed XGBoost with all its dependencies along with: - System dependenciesgitgraphviz - Python dependenciesCheckout therequirements.txtfile underdoc/ Under xgboost/doc directory, run make <format> with <format> replaced by the format you want. For a list of supported formats, run make help under the same directory. This builds a partial document for Python but not other language bindings. To build the full document, see Documentation and Examples.", "prev_chunk_id": "chunk_22", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_24", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "Get Started with XGBoost", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Get Started with XGBoost", "content": "Get Started with XGBoost This is a quick start tutorial showing snippets for you to quickly try out XGBoost on the demo dataset on a binary classification task.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_25", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "Links to Other Helpful Resources", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Links to Other Helpful Resources", "content": "Links to Other Helpful Resources - SeeInstallation Guideon how to install XGBoost. - SeeText Input Formaton using text format for specifying training/testing data. - SeeTutorialsfor tips and tutorials. - SeeLearning to use XGBoost by Examplesfor more code examples.", "prev_chunk_id": "chunk_24", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_26", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "Python", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Python", "content": "Python from xgboost import XGBClassifier # read data from sklearn.datasets import load_iris from sklearn.model_selection import train_test_split data = load_iris() X_train, X_test, y_train, y_test = train_test_split(data['data'], data['target'], test_size=.2) # create model instance bst = XGBClassifier(n_estimators=2, max_depth=2, learning_rate=1, objective='binary:logistic') # fit model bst.fit(X_train, y_train) # make predictions preds = bst.predict(X_test)", "prev_chunk_id": "chunk_25", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_27", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "R", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "R", "content": "R # load data data(agaricus.train, package='xgboost') data(agaricus.test, package='xgboost') train <- agaricus.train test <- agaricus.test # fit model bst <- xgboost(x = train$data, y = factor(train$label), max.depth = 2, eta = 1, nrounds = 2, nthread = 2, objective = \"binary:logistic\") # predict pred <- predict(bst, test$data)", "prev_chunk_id": "chunk_26", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_28", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "Julia", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Julia", "content": "Julia using XGBoost # read data train_X, train_Y = readlibsvm(\"demo/data/agaricus.txt.train\", (6513, 126)) test_X, test_Y = readlibsvm(\"demo/data/agaricus.txt.test\", (1611, 126)) # fit model num_round = 2 bst = xgboost(train_X, num_round, label=train_Y, eta=1, max_depth=2) # predict pred = predict(bst, test_X)", "prev_chunk_id": "chunk_27", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_29", "url": "https://xgboost.readthedocs.io/en/stable/get_started.html", "title": "Scala", "page_title": "Get Started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Scala", "content": "Scala import ml.dmlc.xgboost4j.scala.DMatrix import ml.dmlc.xgboost4j.scala.XGBoost object XGBoostScalaExample { def main(args: Array[String]) { // read trainining data, available at xgboost/demo/data val trainData = new DMatrix(\"/path/to/agaricus.txt.train\") // define parameters val paramMap = List( \"eta\" -> 0.1, \"max_depth\" -> 2, \"objective\" -> \"binary:logistic\").toMap // number of iterations val round = 2 // train the model val model = XGBoost.train(trainData, paramMap, round) // run prediction val predTrain = model.predict(trainData) // save model to the file. model.saveModel(\"/local/path/to/model\") } }", "prev_chunk_id": "chunk_28", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_30", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/index.html", "title": "XGBoost Tutorials", "page_title": "XGBoost Tutorials — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Tutorials", "content": "XGBoost Tutorials This section contains official tutorials inside XGBoost package. See Awesome XGBoost for more resources. Also, don’t miss the feature introductions in each package.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_31", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Frequently Asked Questions", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Frequently Asked Questions", "content": "Frequently Asked Questions This document contains frequently asked questions about XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_32", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "How to tune parameters", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "How to tune parameters", "content": "How to tune parameters See Parameter Tuning Guide.", "prev_chunk_id": "chunk_31", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_33", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Description of the model", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Description of the model", "content": "Description of the model See Introduction to Boosted Trees.", "prev_chunk_id": "chunk_32", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_34", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "I have a big dataset", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "I have a big dataset", "content": "I have a big dataset XGBoost is designed to be memory efficient. Usually it can handle problems as long as the data fits into your memory. This usually means millions of instances. If you are running out of memory, checkout the tutorial page for using distributed training with one of the many frameworks, or the external memory version for using external memory.", "prev_chunk_id": "chunk_33", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_35", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "How to handle categorical feature?", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "How to handle categorical feature?", "content": "How to handle categorical feature? Visit this tutorial for a walkthrough of categorical data handling and some worked examples.", "prev_chunk_id": "chunk_34", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_36", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Why not implement distributed XGBoost on top of X (Spark, Hadoop)?", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Why not implement distributed XGBoost on top of X (Spark, Hadoop)?", "content": "Why not implement distributed XGBoost on top of X (Spark, Hadoop)? The first fact we need to know is going distributed does not necessarily solve all the problems. Instead, it creates more problems such as more communication overhead and fault tolerance. The ultimate question will still come back to how to push the limit of each computation node and use less resources to complete the task (thus with less communication and chance of failure). To achieve these, we decide to reuse the optimizations in the single node XGBoost and build the distributed version on top of it. The demand for communication in machine learning is rather simple, in the sense that we can depend on a limited set of APIs. Such design allows us to reuse most of the code, while being portable to major platforms such as Hadoop/Yarn, MPI, SGE. Most importantly, it pushes the limit of the computation resources we can use.", "prev_chunk_id": "chunk_35", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_37", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "How can I port a model to my own system?", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "How can I port a model to my own system?", "content": "How can I port a model to my own system? The model and data format of XGBoost are exchangeable, which means the model trained by one language can be loaded in another. This means you can train the model using R, while running prediction using Java or C++, which are more common in production systems. You can also train the model using distributed versions, and load them in from Python to do some interactive analysis. See Model IO for more information.", "prev_chunk_id": "chunk_36", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_38", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Do you support LambdaMART?", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Do you support LambdaMART?", "content": "Do you support LambdaMART? Yes, XGBoost implements LambdaMART. Checkout the objective section in parameters.", "prev_chunk_id": "chunk_37", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_39", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "How to deal with missing values", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "How to deal with missing values", "content": "How to deal with missing values XGBoost supports missing values by default. In tree algorithms, branch directions for missing values are learned during training. Note that the gblinear booster treats missing values as zeros. When the missing parameter is specified, values in the input predictor that is equal to missing will be treated as missing and removed. By default it’s set to NaN.", "prev_chunk_id": "chunk_38", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_40", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Slightly different result between runs", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Slightly different result between runs", "content": "Slightly different result between runs This could happen, due to non-determinism in floating point summation order and multi-threading. Also, data partitioning changes by distributed framework can be an issue as well. Though the general accuracy will usually remain the same.", "prev_chunk_id": "chunk_39", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_41", "url": "https://xgboost.readthedocs.io/en/stable/faq.html", "title": "Why do I see different results with sparse and dense data?", "page_title": "Frequently Asked Questions — xgboost 3.0.4 documentation", "breadcrumbs": "Why do I see different results with sparse and dense data?", "content": "Why do I see different results with sparse and dense data? “Sparse” elements are treated as if they were “missing” by the tree booster, and as zeros by the linear booster. However, if we convert the sparse matrix back to dense matrix, the sparse matrix might fill the missing entries with 0, which is a valid value for xgboost. In short, sparse matrix implementations like scipy treats 0 as missing, while 0 is a valid split value for XGBoost decision trees.", "prev_chunk_id": "chunk_40", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_42", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "XGBoost GPU Support", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost GPU Support", "content": "XGBoost GPU Support This page contains information about GPU algorithms supported in XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_43", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "CUDA Accelerated Tree Construction Algorithms", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "CUDA Accelerated Tree Construction Algorithms", "content": "CUDA Accelerated Tree Construction Algorithms Most of the algorithms in XGBoost including training, prediction and evaluation can be accelerated with CUDA-capable GPUs.", "prev_chunk_id": "chunk_42", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_44", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Usage", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Usage", "content": "Usage To enable GPU acceleration, specify the device parameter as cuda. In addition, the device ordinal (which GPU to use if you have multiple devices in the same node) can be specified using the cuda:<ordinal> syntax, where <ordinal> is an integer that represents the device ordinal. XGBoost defaults to 0 (the first device reported by CUDA runtime). The GPU algorithms currently work with CLI, Python, R, and JVM packages. See Installation Guide for details.", "prev_chunk_id": "chunk_43", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_45", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "GPU-Accelerated SHAP values", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "GPU-Accelerated SHAP values", "content": "GPU-Accelerated SHAP values XGBoost makes use of GPUTreeShap as a backend for computing shap values when the GPU is used. booster.set_param({\"device\": \"cuda:0\"}) shap_values = booster.predict(dtrain, pred_contribs=True) shap_interaction_values = model.predict(dtrain, pred_interactions=True) See Use GPU to speedup SHAP value computation for a worked example.", "prev_chunk_id": "chunk_44", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_46", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Multi-node Multi-GPU Training", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Multi-node Multi-GPU Training", "content": "Multi-node Multi-GPU Training XGBoost supports fully distributed GPU training using Dask, Spark and PySpark. For getting started with Dask see our tutorial Distributed XGBoost with Dask and worked examples XGBoost Dask Feature Walkthrough, also Python documentation Dask API for complete reference. For usage with Spark using Scala see XGBoost4J-Spark-GPU Tutorial. Lastly for distributed GPU training with PySpark, see Distributed XGBoost with PySpark.", "prev_chunk_id": "chunk_45", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_47", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "RMM integration", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "RMM integration", "content": "RMM integration XGBoost provides optional support for RMM integration. See Using XGBoost with RAPIDS Memory Manager (RMM) plugin for more info.", "prev_chunk_id": "chunk_46", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_48", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Memory usage", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Memory usage", "content": "Memory usage The following are some guidelines on the device memory usage of the hist tree method on GPU. Memory inside xgboost training is generally allocated for two reasons - storing the dataset and working memory. The dataset itself is stored on device in a compressed ELLPACK format. The ELLPACK format is a type of sparse matrix that stores elements with a constant row stride. This format is convenient for parallel computation when compared to CSR because the row index of each element is known directly from its address in memory. The disadvantage of the ELLPACK format is that it becomes less memory efficient if the maximum row length is significantly more than the average row length. Elements are quantised and stored as integers. These integers are compressed to a minimum bit length. Depending on the number of features, we usually don’t need the full range of a 32 bit integer to store elements and so compress this down. The compressed, quantised ELLPACK format will commonly use 1/4 the space of a CSR matrix stored in floating point. Working memory is allocated inside the algorithm proportional to the number of rows to keep track of gradients, tree positions and other per row statistics. Memory is allocated for histogram bins proportional to the number of bins, number of features and nodes in the tree. For performance reasons we keep histograms in memory from previous nodes in the tree, when a certain threshold of memory usage is passed we stop doing this to conserve memory at some performance loss. If you are getting out-of-memory errors on a big dataset, try the xgboost.QuantileDMatrix or external memory version. Note that when external memory is used for GPU hist, it’s best to employ gradient based sampling as well. Last but not least, inplace_predict can be", "prev_chunk_id": "chunk_47", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_49", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Memory usage", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Memory usage", "content": "preferred over predict when data is already on GPU. Both QuantileDMatrix and inplace_predict are automatically enabled if you are using the scikit-learn interface.", "prev_chunk_id": "chunk_48", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_50", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "CPU-GPU Interoperability", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "CPU-GPU Interoperability", "content": "CPU-GPU Interoperability The model can be used on any device regardless of the one used to train it. For instance, a model trained using GPU can still work on a CPU-only machine and vice versa. For more information about model serialization, see Introduction to Model IO.", "prev_chunk_id": "chunk_49", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_51", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Developer notes", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Developer notes", "content": "Developer notes The application may be profiled with annotations by specifying USE_NTVX to cmake. Regions covered by the ‘Monitor’ class in CUDA code will automatically appear in the nsight profiler when verbosity is set to 3.", "prev_chunk_id": "chunk_50", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_52", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "References", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "References", "content": "References Mitchell R, Frank E. (2017) Accelerating the XGBoost algorithm using GPU computing. PeerJ Computer Science 3:e127 https://doi.org/10.7717/peerj-cs.127 NVIDIA Parallel Forall: Gradient Boosting, Decision Trees and XGBoost with CUDA Out-of-Core GPU Gradient Boosting", "prev_chunk_id": "chunk_51", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_53", "url": "https://xgboost.readthedocs.io/en/stable/gpu/index.html", "title": "Contributors", "page_title": "XGBoost GPU Support — xgboost 3.0.4 documentation", "breadcrumbs": "Contributors", "content": "Contributors Many thanks to the following contributors (alphabetical order): - Andrey Adinets - Jiaming Yuan - Jonathan C. McKinney - Matthew Jones - Philip Cho - Rong Ou - Rory Mitchell - Shankara Rao Thejaswi Nanditale - Sriram Chandramouli - Vinay Deshpande Please report bugs to the XGBoost issues list.", "prev_chunk_id": "chunk_52", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_54", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "XGBoost Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Parameters", "content": "XGBoost Parameters Before running XGBoost, we must set three types of parameters: general parameters, booster parameters and task parameters. - General parametersrelate to which booster we are using to do boosting, commonly tree or linear model - Booster parametersdepend on which booster you have chosen - Learning task parametersdecide on the learning scenario. For example, regression tasks may use different parameters with ranking tasks. - Command line parametersrelate to behavior of CLI version of XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_55", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Global Configuration", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Global Configuration", "content": "Global Configuration The following parameters can be set in the global scope, using xgboost.config_context() (Python) or xgb.set.config() (R). - verbosity: Verbosity of printing messages. Valid values of 0 (silent), 1 (warning), 2 (info), and 3 (debug). - use_rmm: Whether to use RAPIDS Memory Manager (RMM) to allocate cache GPU memory. The primary memory is always allocated on the RMM pool when XGBoost is built (compiled) with the RMM plugin enabled. Valid values aretrueandfalse. SeeUsing XGBoost with RAPIDS Memory Manager (RMM) pluginfor details. - nthread: Set the global number of threads for OpenMP. Use this only when you need to override some OpenMP-related environment variables likeOMP_NUM_THREADS. Otherwise, thenthreadparameter from the Booster and the DMatrix should be preferred as the former sets the global variable and might cause conflicts with other libraries.", "prev_chunk_id": "chunk_54", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_56", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "General Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "General Parameters", "content": "General Parameters - booster[default=gbtree]Which booster to use. Can begbtree,gblinearordart;gbtreeanddartuse tree based models whilegblinearuses linear functions. - device[default=cpu]Added in version 2.0.0.Device for XGBoost to run. User can set it to one of the following values:cpu: Use CPU.cuda: Use a GPU (CUDA device).cuda:<ordinal>:<ordinal>is an integer that specifies the ordinal of the GPU (which GPU do you want to use if you have more than one devices).gpu: Default GPU device selection from the list of available and supported devices. Onlycudadevices are supported currently.gpu:<ordinal>: Default GPU device selection from the list of available and supported devices. Onlycudadevices are supported currently.For more information about GPU acceleration, seeXGBoost GPU Support. In distributed environments, ordinal selection is handled by distributed frameworks instead of XGBoost. As a result, usingcuda:<ordinal>will result in an error. Usecudainstead. - verbosity[default=1]Verbosity of printing messages. Valid values are 0 (silent), 1 (warning), 2 (info), 3 (debug). Sometimes XGBoost tries to change configurations based on heuristics, which is displayed as warning message. If there’s unexpected behaviour, please try to increase value of verbosity. - validate_parameters[default tofalse, except for Python, R and CLI interface]When set to True, XGBoost will perform validation of input parameters to check whether a parameter is used or not. A warning is emitted when there’s unknown parameter. - nthread[default to maximum number of threads available if not set]Number of parallel threads used to run XGBoost. When choosing it, please keep thread contention and hyperthreading in mind. - disable_default_eval_metric[default=false]Flag to disable default metric. Set to 1 ortrueto disable.", "prev_chunk_id": "chunk_55", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_57", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Tree Booster", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Tree Booster", "content": "Parameters for Tree Booster - eta[default=0.3, alias:learning_rate]Step size shrinkage used in update to prevent overfitting. After each boosting step, we can directly get the weights of new features, andetashrinks the feature weights to make the boosting process more conservative.range: [0,1] - gamma[default=0, alias:min_split_loss]Minimum loss reduction required to make a further partition on a leaf node of the tree. The largergammais, the more conservative the algorithm will be. Note that a tree where no splits were made might still contain a single terminal node with a non-zero score.range: [0,∞] - max_depth[default=6, type=int32]Maximum depth of a tree. Increasing this value will make the model more complex and more likely to overfit. 0 indicates no limit on depth. Beware that XGBoost aggressively consumes memory when training a deep tree.exacttree method requires non-zero value.range: [0,∞] - min_child_weight[default=1]Minimum sum of instance weight (hessian) needed in a child. If the tree partition step results in a leaf node with the sum of instance weight less thanmin_child_weight, then the building process will give up further partitioning. In linear regression task, this simply corresponds to minimum number of instances needed to be in each node. The largermin_child_weightis, the more conservative the algorithm will be.range: [0,∞] - max_delta_step[default=0]Maximum delta step we allow each leaf output to be. If the value is set to 0, it means there is no constraint. If it is set to a positive value, it can help making the update step more conservative. Usually this parameter is not needed, but it might help in logistic regression when class is extremely imbalanced. Set it to value of 1-10 might help control the update.range: [0,∞] - subsample[default=1]Subsample ratio of the training instances. Setting it to 0.5 means that XGBoost would randomly sample half of the training data prior to growing trees. and this will prevent overfitting. Subsampling", "prev_chunk_id": "chunk_56", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_58", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Tree Booster", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Tree Booster", "content": "will occur once in every boosting iteration.range: (0,1] - sampling_method[default=uniform]The method to use to sample the training instances.uniform: each training instance has an equal probability of being selected. Typically setsubsample>= 0.5 for good results.gradient_based: the selection probability for each training instance is proportional to theregularized absolute valueof gradients (more specifically,\\(\\sqrt{g^2+\\lambda h^2}\\)).subsamplemay be set to as low as 0.1 without loss of model accuracy. Note that this sampling method is only supported whentree_methodis set tohistand the device iscuda; other tree methods only supportuniformsampling. - colsample_bytree,colsample_bylevel,colsample_bynode[default=1]This is a family of parameters for subsampling of columns.Allcolsample_by*parameters have a range of (0, 1], the default value of 1, and specify the fraction of columns to be subsampled.colsample_bytreeis the subsample ratio of columns when constructing each tree. Subsampling occurs once for every tree constructed.colsample_bylevelis the subsample ratio of columns for each level. Subsampling occurs once for every new depth level reached in a tree. Columns are subsampled from the set of columns chosen for the current tree.colsample_bynodeis the subsample ratio of columns for each node (split). Subsampling occurs once every time a new split is evaluated. Columns are subsampled from the set of columns chosen for the current level. This is not supported by the exact tree method.colsample_by*parameters work cumulatively. For instance, the combination{'colsample_bytree':0.5,'colsample_bylevel':0.5,'colsample_bynode':0.5}with 64 features will leave 8 features to choose from at each split.Using the Python or the R package, one can set thefeature_weightsfor DMatrix to define the probability of each feature being selected when using column sampling. There’s a similar parameter forfitmethod in sklearn interface. - lambda[default=1, alias:reg_lambda]L2 regularization term on weights. Increasing this value will make model more conservative.range: [0,\\(\\infty\\)] - alpha[default=0, alias:reg_alpha]L1 regularization term on weights. Increasing this value will make model more conservative.range: [0,\\(\\infty\\)] - tree_methodstring [default=auto]The tree construction algorithm used in XGBoost. See description in thereference paperandTree Methods.Choices:auto,exact,approx,hist,", "prev_chunk_id": "chunk_57", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_59", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Tree Booster", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Tree Booster", "content": "this is a combination of commonly used updaters. For other updaters likerefresh, set the parameterupdaterdirectly.auto: Same as thehisttree method.exact: Exact greedy algorithm. Enumerates all split candidates.approx: Approximate greedy algorithm using quantile sketch and gradient histogram.hist: Faster histogram optimized approximate greedy algorithm. - scale_pos_weight[default=1]Control the balance of positive and negative weights, useful for unbalanced classes. A typical value to consider:sum(negativeinstances)/sum(positiveinstances). SeeParameters Tuningfor more discussion. Also, see Higgs Kaggle competition demo for examples:R,py1,py2,py3. - updaterA comma separated string defining the sequence of tree updaters to run, providing a modular way to construct and to modify the trees. This is an advanced parameter that is usually set automatically, depending on some other parameters. However, it could be also set explicitly by a user. The following updaters exist:grow_colmaker: non-distributed column-based construction of trees.grow_histmaker: distributed tree construction with row-based data splitting based on global proposal of histogram counting.grow_quantile_histmaker: Grow tree using quantized histogram.grow_gpu_hist: Enabled whentree_methodis set tohistalong withdevice=cuda.grow_gpu_approx: Enabled whentree_methodis set toapproxalong withdevice=cuda.sync: synchronizes trees in all distributed nodes.refresh: refreshes tree’s statistics and/or leaf values based on the current data. Note that no random subsampling of data rows is performed.prune: prunes the splits where loss < min_split_loss (or gamma) and nodes that have depth greater thanmax_depth. - refresh_leaf[default=1]This is a parameter of therefreshupdater. When this flag is 1, tree leafs as well as tree nodes’ stats are updated. When it is 0, only node stats are updated. - process_type[default=default]A type of boosting process to run.Choices:default,updatedefault: The normal boosting process which creates new trees.update: Starts from an existing model and only updates its trees. In each boosting iteration, a tree from the initial model is taken, a specified sequence of updaters is run for that tree, and a modified tree is added to the new model. The new model would have either the same or smaller", "prev_chunk_id": "chunk_58", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_60", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Tree Booster", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Tree Booster", "content": "number of trees, depending on the number of boosting iterations performed. Currently, the following built-in updaters could be meaningfully used with this process type:refresh,prune. Withprocess_type=update, one cannot use updaters that create new trees. - grow_policy[default=depthwise]Controls a way new nodes are added to the tree.Currently supported only iftree_methodis set tohistorapprox.Choices:depthwise,lossguidedepthwise: split at nodes closest to the root.lossguide: split at nodes with highest loss change. - max_leaves[default=0, type=int32]Maximum number of nodes to be added. Not used byexacttree method. - max_bin, [default=256, type=int32]Only used iftree_methodis set tohistorapprox.Maximum number of discrete bins to bucket continuous features.Increasing this number improves the optimality of splits at the cost of higher computation time. - num_parallel_tree, [default=1]Number of parallel trees constructed during each iteration. This option is used to support boosted random forest. - monotone_constraintsConstraint of variable monotonicity. SeeMonotonic Constraintsfor more information. - interaction_constraintsConstraints for interaction representing permitted interactions. The constraints must be specified in the form of a nest list, e.g.[[0,1],[2,3,4]], where each inner list is a group of indices of features that are allowed to interact with each other. SeeFeature Interaction Constraintsfor more information. - multi_strategy, [default =one_output_per_tree]Added in version 2.0.0.NoteThis parameter is working-in-progress.The strategy used for training multi-target models, including multi-target regression and multi-class classification. SeeMultiple Outputsfor more information.one_output_per_tree: One model for each target.multi_output_tree: Use multi-target trees.", "prev_chunk_id": "chunk_59", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_61", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Non-Exact Tree Methods", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Non-Exact Tree Methods", "content": "Parameters for Non-Exact Tree Methods - max_cached_hist_node, [default = 65536]Maximum number of cached nodes for histogram. This can be used with thehistand theapproxtree methods.Added in version 2.0.0.For most of the cases this parameter should not be set except for growing deep trees. After 3.0, this parameter affects GPU algorithms as well. - extmem_single_page, [default =false]This parameter is only used for thehisttree method withdevice=cudaandsubsample!=1.0. Before 3.0, pages were always concatenated.Added in version 3.0.0.Whether the GPU-basedhisttree method should concatenate the training data into a single batch instead of fetching data on-demand when external memory is used. For GPU devices that don’t support address translation services, external memory training is expensive. This parameter can be used in combination with subsampling to reduce overall memory usage without significant overhead. SeeUsing XGBoost External Memory Versionfor more information.", "prev_chunk_id": "chunk_60", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_62", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Categorical Feature", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Categorical Feature", "content": "Parameters for Categorical Feature These parameters are only used for training with categorical data. See Categorical Data for more information. - max_cat_to_onehotAdded in version 1.6.0.A threshold for deciding whether XGBoost should use one-hot encoding based split for categorical data. When number of categories is lesser than the threshold then one-hot encoding is chosen, otherwise the categories will be partitioned into children nodes. - max_cat_thresholdAdded in version 1.7.0.Maximum number of categories considered for each split. Used only by partition-based splits for preventing over-fitting.", "prev_chunk_id": "chunk_61", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_63", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Additional parameters for Dart Booster (booster=dart)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Additional parameters for Dart Booster (booster=dart)", "content": "Additional parameters for Dart Booster (booster=dart) - sample_type[default=uniform]Type of sampling algorithm.uniform: dropped trees are selected uniformly.weighted: dropped trees are selected in proportion to weight. - normalize_type[default=tree]Type of normalization algorithm.tree: new trees have the same weight of each of dropped trees.Weight of new trees are1/(k+learning_rate).Dropped trees are scaled by a factor ofk/(k+learning_rate).forest: new trees have the same weight of sum of dropped trees (forest).Weight of new trees are1/(1+learning_rate).Dropped trees are scaled by a factor of1/(1+learning_rate). - rate_drop[default=0.0]Dropout rate (a fraction of previous trees to drop during the dropout).range: [0.0, 1.0] - one_drop[default=0]When this flag is enabled, at least one tree is always dropped during the dropout (allows Binomial-plus-one or epsilon-dropout from the original DART paper). - skip_drop[default=0.0]Probability of skipping the dropout procedure during a boosting iteration.If a dropout is skipped, new trees are added in the same manner asgbtree.Note that non-zeroskip_drophas higher priority thanrate_droporone_drop.range: [0.0, 1.0]", "prev_chunk_id": "chunk_62", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_64", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Linear Booster (booster=gblinear)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Linear Booster (booster=gblinear)", "content": "Parameters for Linear Booster (booster=gblinear) - lambda[default=0, alias:reg_lambda]L2 regularization term on weights. Increasing this value will make model more conservative. Normalised to number of training examples. - alpha[default=0, alias:reg_alpha]L1 regularization term on weights. Increasing this value will make model more conservative. Normalised to number of training examples. - eta[default=0.5, alias:learning_rate]Step size shrinkage used in update to prevent overfitting. After each boosting step, we can directly get the weights of new features, andetashrinks the feature weights to make the boosting process more conservative.range: [0,1] - updater[default=shotgun]Choice of algorithm to fit linear modelshotgun: Parallel coordinate descent algorithm based on shotgun algorithm. Uses ‘hogwild’ parallelism and therefore produces a nondeterministic solution on each run.coord_descent: Ordinary coordinate descent algorithm. Also multithreaded but still produces a deterministic solution. When thedeviceparameter is set tocudaorgpu, a GPU variant would be used. - feature_selector[default=cyclic]Feature selection and ordering methodcyclic: Deterministic selection by cycling through features one at a time.shuffle: Similar tocyclicbut with random feature shuffling prior to each update.random: A random (with replacement) coordinate selector.greedy: Select coordinate with the greatest gradient magnitude. It hasO(num_feature^2)complexity. It is fully deterministic. It allows restricting the selection totop_kfeatures per group with the largest magnitude of univariate weight change, by setting thetop_kparameter. Doing so would reduce the complexity toO(num_feature*top_k).thrifty: Thrifty, approximately-greedy feature selector. Prior to cyclic updates, reorders features in descending magnitude of their univariate weight changes. This operation is multithreaded and is a linear complexity approximation of the quadratic greedy selection. It allows restricting the selection totop_kfeatures per group with the largest magnitude of univariate weight change, by setting thetop_kparameter. - top_k[default=0]The number of top features to select ingreedyandthriftyfeature selector. The value of 0 means using all the features.", "prev_chunk_id": "chunk_63", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_65", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Learning Task Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Learning Task Parameters", "content": "Learning Task Parameters Specify the learning task and the corresponding learning objective. The objective options are below: - objective[default=reg:squarederror]reg:squarederror: regression with squared loss.reg:squaredlogerror: regression with squared log loss\\(\\frac{1}{2}[log(pred + 1) - log(label + 1)]^2\\). All input labels are required to be greater than -1. Also, see metricrmslefor possible issue with this objective.reg:logistic: logistic regression, output probabilityreg:pseudohubererror: regression with Pseudo Huber loss, a twice differentiable alternative to absolute loss.reg:absoluteerror: Regression with L1 error. When tree model is used, leaf value is refreshed after tree construction. If used in distributed training, the leaf value is calculated as the mean value from all workers, which is not guaranteed to be optimal.Added in version 1.7.0.reg:quantileerror: Quantile loss, also known aspinballloss. See later sections for its parameter andQuantile Regressionfor a worked example.Added in version 2.0.0.binary:logistic: logistic regression for binary classification, output probabilitybinary:logitraw: logistic regression for binary classification, output score before logistic transformationbinary:hinge: hinge loss for binary classification. This makes predictions of 0 or 1, rather than producing probabilities.count:poisson: Poisson regression for count data, output mean of Poisson distribution.max_delta_stepis set to 0.7 by default in Poisson regression (used to safeguard optimization)survival:cox: Cox regression for right censored survival time data (negative values are considered right censored). Note that predictions are returned on the hazard ratio scale (i.e., as HR = exp(marginal_prediction) in the proportional hazard functionh(t)=h0(t)*HR).survival:aft: Accelerated failure time model for censored survival time data. SeeSurvival Analysis with Accelerated Failure Timefor details.multi:softmax: set XGBoost to do multiclass classification using the softmax objective, you also need to set num_class(number of classes)multi:softprob: same as softmax, but output a vector ofndata*nclass, which can be further reshaped tondata*nclassmatrix. The result contains predicted probability of each data point belonging to each class.rank:ndcg: Use LambdaMART to perform pair-wise ranking whereNormalized Discounted Cumulative Gain (NDCG)is maximized. This objective supports position debiasing for click data.rank:map:", "prev_chunk_id": "chunk_64", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_66", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Learning Task Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Learning Task Parameters", "content": "Use LambdaMART to perform pair-wise ranking whereMean Average Precision (MAP)is maximizedrank:pairwise: Use LambdaRank to perform pair-wise ranking using theranknetobjective.reg:gamma: gamma regression with log-link. Output is a mean of gamma distribution. It might be useful, e.g., for modeling insurance claims severity, or for any outcome that might begamma-distributed.reg:tweedie: Tweedie regression with log-link. It might be useful, e.g., for modeling total loss in insurance, or for any outcome that might beTweedie-distributed. - base_scoreThe initial prediction score of all instances, global biasThe parameter is automatically estimated for selected objectives before training. To disable the estimation, specify a real number argument.Ifbase_marginis supplied,base_scorewill not be added.For sufficient number of iterations, changing this value will not have too much effect.SeeInterceptfor more info. - eval_metric[default according to objective]Evaluation metrics for validation data, a default metric will be assigned according to objective (rmse for regression, and logloss for classification,mean average precisionforrank:map, etc.)User can add multiple evaluation metrics. Python users: remember to pass the metrics in as list of parameters pairs instead of map, so that lattereval_metricwon’t override previous onesThe choices are listed below:rmse:root mean square errorrmsle: root mean square log error:\\(\\sqrt{\\frac{1}{N}[log(pred + 1) - log(label + 1)]^2}\\). Default metric ofreg:squaredlogerrorobjective. This metric reduces errors generated by outliers in dataset. But becauselogfunction is employed,rmslemight outputnanwhen prediction value is less than -1. Seereg:squaredlogerrorfor other requirements.mae:mean absolute errormape:mean absolute percentage errormphe:mean Pseudo Huber error. Default metric ofreg:pseudohubererrorobjective.logloss:negative log-likelihooderror: Binary classification error rate. It is calculated as#(wrongcases)/#(allcases). For the predictions, the evaluation will regard the instances with prediction value larger than 0.5 as positive instances, and the others as negative instances.error@t: a different than 0.5 binary classification threshold value could be specified by providing a numerical value through ‘t’.merror: Multiclass classification error rate. It is calculated as#(wrongcases)/#(allcases).mlogloss:Multiclass logloss.auc:Receiver Operating Characteristic Area under the Curve. Available for classification and learning-to-rank tasks.When used with", "prev_chunk_id": "chunk_65", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_67", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Learning Task Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Learning Task Parameters", "content": "binary classification, the objective should bebinary:logisticor similar functions that work on probability.When used with multi-class classification, objective should bemulti:softprobinstead ofmulti:softmax, as the latter doesn’t output probability. Also the AUC is calculated by 1-vs-rest with reference class weighted by class prevalence.When used with LTR task, the AUC is computed by comparing pairs of documents to count correctly sorted pairs. This corresponds to pairwise learning to rank. The implementation has some issues with average AUC around groups and distributed workers not being well-defined.On a single machine the AUC calculation is exact. In a distributed environment the AUC is a weighted average over the AUC of training rows on each node - therefore, distributed AUC is an approximation sensitive to the distribution of data across workers. Use another metric in distributed environments if precision and reproducibility are important.When input dataset contains only negative or positive samples, the output isNaN. The behavior is implementation defined, for instance,scikit-learnreturns\\(0.5\\)instead.aucpr:Area under the PR curve. Available for classification and learning-to-rank tasks.After XGBoost 1.6, both of the requirements and restrictions for usingaucprin classification problem are similar toauc. For ranking task, only binary relevance label\\(y \\in [0, 1]\\)is supported. Different frommap(meanaverageprecision),aucprcalculates theinterpolatedarea under precision recall curve using continuous interpolation.pre: Precision at\\(k\\). Supports only learning to rank task.ndcg:Normalized Discounted Cumulative Gainmap:Mean Average PrecisionTheaverage precisionis defined as:\\[AP@l = \\frac{1}{min{(l, N)}}\\sum^l_{k=1}P@k \\cdot I_{(k)}\\]where\\(I_{(k)}\\)is an indicator function that equals to\\(1\\)when the document at\\(k\\)is relevant and\\(0\\)otherwise. The\\(P@k\\)is the precision at\\(k\\), and\\(N\\)is the total number of relevant documents. Lastly, themean average precisionis defined as the weighted average across all queries.ndcg@n,map@n,pre@n:\\(n\\)can be assigned as an integer to cut off the top positions in the lists for evaluation.ndcg-,map-,ndcg@n-,map@n-: In XGBoost, the NDCG and MAP evaluate the score of a list without any positive samples as\\(1\\). By appending “-” to the evaluation metric name, we can ask XGBoost to", "prev_chunk_id": "chunk_66", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_68", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Learning Task Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Learning Task Parameters", "content": "evaluate these scores as\\(0\\)to be consistent under some conditions.poisson-nloglik: negative log-likelihood for Poisson regressiongamma-nloglik: negative log-likelihood for gamma regressioncox-nloglik: negative partial log-likelihood for Cox proportional hazards regressiongamma-deviance: residual deviance for gamma regressiontweedie-nloglik: negative log-likelihood for Tweedie regression (at a specified value of thetweedie_variance_powerparameter)aft-nloglik: Negative log likelihood of Accelerated Failure Time model. SeeSurvival Analysis with Accelerated Failure Timefor details.interval-regression-accuracy: Fraction of data points whose predicted labels fall in the interval-censored labels. Only applicable for interval-censored data. SeeSurvival Analysis with Accelerated Failure Timefor details. - seed[default=0]Random number seed. In the R package, if not specified, instead of defaulting to seed ‘zero’, will take a random seed through R’s own RNG engine. - seed_per_iteration[default=false]Seed PRNG determnisticly via iterator number.", "prev_chunk_id": "chunk_67", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_69", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for Tweedie Regression (objective=reg:tweedie)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for Tweedie Regression (objective=reg:tweedie)", "content": "Parameters for Tweedie Regression (objective=reg:tweedie) - tweedie_variance_power[default=1.5]Parameter that controls the variance of the Tweedie distributionvar(y)~E(y)^tweedie_variance_powerrange: (1,2)Set closer to 2 to shift towards a gamma distributionSet closer to 1 to shift towards a Poisson distribution.", "prev_chunk_id": "chunk_68", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_70", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameter for using Pseudo-Huber (reg:pseudohubererror)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameter for using Pseudo-Huber (reg:pseudohubererror)", "content": "Parameter for using Pseudo-Huber (reg:pseudohubererror) - huber_slope: A parameter used for Pseudo-Huber loss to define the\\(\\delta\\)term. [default = 1.0]", "prev_chunk_id": "chunk_69", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_71", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameter for using Quantile Loss (reg:quantileerror)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameter for using Quantile Loss (reg:quantileerror)", "content": "Parameter for using Quantile Loss (reg:quantileerror) - quantile_alpha: A scalar or a list of targeted quantiles.Added in version 2.0.0.", "prev_chunk_id": "chunk_70", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_72", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameter for using AFT Survival Loss (survival:aft) and Negative Log Likelihood of AFT metric (aft-nloglik)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameter for using AFT Survival Loss (survival:aft) and Negative Log Likelihood of AFT metric (aft-nloglik)", "content": "Parameter for using AFT Survival Loss (survival:aft) and Negative Log Likelihood of AFT metric (aft-nloglik) - aft_loss_distribution: Probability Density Function,normal,logistic, orextreme.", "prev_chunk_id": "chunk_71", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_73", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Parameters for learning to rank (rank:ndcg, rank:map, rank:pairwise)", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters for learning to rank (rank:ndcg, rank:map, rank:pairwise)", "content": "Parameters for learning to rank (rank:ndcg, rank:map, rank:pairwise) These are parameters specific to learning to rank task. See Learning to Rank for an in-depth explanation. - lambdarank_pair_method[default =topk]How to construct pairs for pair-wise learning.mean: Samplelambdarank_num_pair_per_samplepairs for each document in the query list.topk: Focus on top-lambdarank_num_pair_per_sampledocuments. Construct\\(|query|\\)pairs for each document at the top-lambdarank_num_pair_per_sampleranked by the model. - lambdarank_num_pair_per_sample[range =\\([1, \\infty]\\)]It specifies the number of pairs sampled for each document when pair method ismean, or the truncation level for queries when the pair method istopk. For example, to train withndcg@6, setlambdarank_num_pair_per_sampleto\\(6\\)andlambdarank_pair_methodtotopk. - lambdarank_normalization[default =true]Added in version 2.1.0.Whether to normalize the leaf value by lambda gradient. This can sometimes stagnate the training progress.Changed in version 3.0.0.When themeanmethod is used, it’s normalized by thelambdarank_num_pair_per_sampleinstead of gradient. - lambdarank_score_normalization[default =true]Added in version 3.0.0.Whether to normalize the delta metric by the difference of prediction scores. This can sometimes stagnate the training progress. With pairwise ranking, we can normalize the gradient using the difference between two samples in each pair to reduce influence from the pairs that have large difference in ranking scores. This can help us regularize the model to reduce bias and prevent overfitting. Similar to other regularization techniques, this might prevent training from converging.There was no normalization before 2.0. In 2.0 and later versions this is used by default. In 3.0, we made this an option that users can disable. - lambdarank_unbiased[default =false] - lambdarank_bias_norm[default = 2.0]\\(L_p\\)normalization for position debiasing, default is\\(L_2\\). Only relevant whenlambdarank_unbiasedis set to true. - ndcg_exp_gain[default =true]Whether we should use exponential gain function forNDCG. There are two forms of gain function forNDCG, one is using relevance value directly while the other is using\\(2^{rel} - 1\\)to emphasize on retrieving relevant documents. Whenndcg_exp_gainis true (the default), relevance degree cannot be greater than 31.", "prev_chunk_id": "chunk_72", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_74", "url": "https://xgboost.readthedocs.io/en/stable/parameter.html", "title": "Command Line Parameters", "page_title": "XGBoost Parameters — xgboost 3.0.4 documentation", "breadcrumbs": "Command Line Parameters", "content": "Command Line Parameters The following parameters are only used in the console version of XGBoost. The CLI has been deprecated and will be removed in future releases. - num_roundThe number of rounds for boosting - dataThe path of training data - test:dataThe path of test data to do prediction - save_period[default=0]The period to save the model. Settingsave_period=10means that for every 10 rounds XGBoost will save the model. Setting it to 0 means not saving any model during the training. - task[default=train] options:train,pred,eval,dumptrain: training using datapred: making prediction for test:dataeval: for evaluating statistics specified byeval[name]=filenamedump: for dump the learned model into text format - model_in[default=NULL]Path to input model, needed fortest,eval,dumptasks. If it is specified in training, XGBoost will continue training from the input model. - model_out[default=NULL]Path to output model after training finishes. If not specified, XGBoost will output files with such names as0003.modelwhere0003is number of boosting rounds. - model_dir[default=models/]The output directory of the saved models during training - fmapFeature map, used for dumping model - dump_format[default=text] options:text,jsonFormat of model dump file - name_dump[default=dump.txt]Name of model dump file - name_pred[default=pred.txt]Name of prediction file, used in pred mode - pred_margin[default=0]Predict margin instead of transformed probability", "prev_chunk_id": "chunk_73", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_75", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Prediction", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction There are a number of prediction functions in XGBoost with various parameters. This document attempts to clarify some of confusions around prediction with a focus on the Python binding, R package is similar when strict_shape is specified (see below).", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_76", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Prediction Options", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction Options", "content": "Prediction Options There are a number of different prediction options for the xgboost.Booster.predict() method, ranging from pred_contribs to pred_leaf. The output shape depends on types of prediction. Also for multi-class classification problem, XGBoost builds one tree for each class and the trees for each class are called a “group” of trees, so output dimension may change due to used model. After 1.4 release, we added a new parameter called strict_shape, one can set it to True to indicate a more restricted output is desired. Assuming you are using xgboost.Booster, here is a list of possible returns: - When using normal prediction withstrict_shapeset toTrue:Output is a 2-dim array with first dimension as rows and second as groups. For regression/survival/ranking/binary classification this is equivalent to a column vector withshape[1]==1. But for multi-class withmulti:softprobthe number of columns equals to number of classes. If strict_shape is set to False then XGBoost might output 1 or 2 dim array. - When usingoutput_marginto avoid transformation andstrict_shapeis set toTrue:Similar to the previous case, output is a 2-dim array, except for thatmulti:softmaxhas equivalent output shape ofmulti:softprobdue to dropped transformation. If strict shape is set to False then output can have 1 or 2 dim depending on used model. - When usingpred_contribswithstrict_shapeset toTrue:Output is a 3-dim array, with(rows,groups,columns+1)as shape. Whetherapprox_contribsis used does not change the output shape. If the strict shape parameter is not set, it can be a 2 or 3 dimension array depending on whether multi-class model is being used. - When usingpred_interactionswithstrict_shapeset toTrue:Output is a 4-dim array, with(rows,groups,columns+1,columns+1)as shape. Like the predict contribution case, whetherapprox_contribsis used does not change the output shape. If strict shape is set to False, it can have 3 or 4 dims depending on the underlying model. - When usingpred_leafwithstrict_shapeset toTrue:Output is a 4-dim array with(n_samples,n_iterations,n_classes,n_trees_in_forest)as shape.n_trees_in_forestis specified by thenumb_parallel_treeduring training. When", "prev_chunk_id": "chunk_75", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_77", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Prediction Options", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction Options", "content": "strict shape is set to False, output is a 2-dim array with last 3 dims concatenated into 1. Also the last dimension is dropped if it equals to 1. When usingapplymethod in scikit learn interface, this is set to False by default. For R package, when strict_shape is specified, an array is returned, with the same value as Python except R array is column-major while Python numpy array is row-major, so all the dimensions are reversed. For example, for a Python predict_leaf output obtained by having strict_shape=True has 4 dimensions: (n_samples, n_iterations, n_classes, n_trees_in_forest), while R with strict_shape=TRUE outputs (n_trees_in_forest, n_classes, n_iterations, n_samples). Other than these prediction types, there’s also a parameter called iteration_range, which is similar to model slicing. But instead of actually splitting up the model into multiple stacks, it simply returns the prediction formed by the trees within range. Number of trees created in each iteration equals to \\(trees_i = num\\_class \\times num\\_parallel\\_tree\\). So if you are training a boosted random forest with size of 4, on the 3-class classification dataset, and want to use the first 2 iterations of trees for prediction, you need to provide iteration_range=(0, 2). Then the first \\(2 \\times 3 \\times 4\\) trees will be used in this prediction.", "prev_chunk_id": "chunk_76", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_78", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Early Stopping", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Early Stopping", "content": "Early Stopping When a model is trained with early stopping, there is an inconsistent behavior between native Python interface and sklearn/R interfaces. By default on R and sklearn interfaces, the best_iteration is automatically used so prediction comes from the best model. But with the native Python interface xgboost.Booster.predict() and xgboost.Booster.inplace_predict() uses the full model. Users can use best_iteration attribute with iteration_range parameter to achieve the same behavior. Also the save_best parameter from xgboost.callback.EarlyStopping might be useful.", "prev_chunk_id": "chunk_77", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_79", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Base Margin", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Base Margin", "content": "Base Margin There’s a training parameter in XGBoost called base_score, and a meta data for DMatrix called base_margin (which can be set in fit method if you are using scikit-learn interface). They specifies the global bias for boosted model. If the latter is supplied then former is ignored. base_margin can be used to train XGBoost model based on other models. See demos on boosting from predictions.", "prev_chunk_id": "chunk_78", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_80", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Staged Prediction", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Staged Prediction", "content": "Staged Prediction Using the native interface with DMatrix, prediction can be staged (or cached). For example, one can first predict on the first 4 trees then run prediction on 8 trees. After running the first prediction, result from first 4 trees are cached so when you run the prediction with 8 trees XGBoost can reuse the result from previous prediction. The cache expires automatically upon next prediction, train or evaluation if the cached DMatrix object is expired (like going out of scope and being collected by garbage collector in your language environment).", "prev_chunk_id": "chunk_79", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_81", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "In-place Prediction", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "In-place Prediction", "content": "In-place Prediction Traditionally XGBoost accepts only DMatrix for prediction, with wrappers like scikit-learn interface the construction happens internally. We added support for in-place predict to bypass the construction of DMatrix, which is slow and memory consuming. The new predict function has limited features but is often sufficient for simple inference tasks. It accepts some commonly found data types in Python like numpy.ndarray, scipy.sparse.csr_matrix and cudf.DataFrame instead of xgboost.DMatrix. You can call xgboost.Booster.inplace_predict() to use it. Be aware that the output of in-place prediction depends on input data type, when input is on GPU data output is cupy.ndarray, otherwise a numpy.ndarray is returned.", "prev_chunk_id": "chunk_80", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_82", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Thread Safety", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Thread Safety", "content": "Thread Safety After 1.4 release, all prediction functions including normal predict with various parameters like shap value computation and inplace_predict are thread safe when underlying booster is gbtree or dart, which means as long as tree model is used, prediction itself should thread safe. But the safety is only guaranteed with prediction. If one tries to train a model in one thread and provide prediction at the other using the same model the behaviour is undefined. This happens easier than one might expect, for instance we might accidentally call clf.set_params() inside a predict function: def predict_fn(clf: xgb.XGBClassifier, X): X = preprocess(X) clf.set_params(n_jobs=1) # NOT safe! return clf.predict_proba(X, iteration_range=(0, 10)) with ThreadPoolExecutor(max_workers=10) as e: e.submit(predict_fn, ...)", "prev_chunk_id": "chunk_81", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_83", "url": "https://xgboost.readthedocs.io/en/stable/prediction.html", "title": "Privacy-Preserving Prediction", "page_title": "Prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Privacy-Preserving Prediction", "content": "Privacy-Preserving Prediction Concrete ML is a third-party open-source library developed by Zama that proposes gradient boosting classes similar to ours, but predicting directly over encrypted data, thanks to Fully Homomorphic Encryption. A simple example would be as follows: from sklearn.datasets import make_classification from sklearn.model_selection import train_test_split from concrete.ml.sklearn import XGBClassifier x, y = make_classification(n_samples=100, class_sep=2, n_features=30, random_state=42) X_train, X_test, y_train, y_test = train_test_split( x, y, test_size=10, random_state=42 ) # Train in the clear and quantize the weights model = XGBClassifier() model.fit(X_train, y_train) # Simulate the predictions in the clear y_pred_clear = model.predict(X_test) # Compile in FHE model.compile(X_train) # Generate keys model.fhe_circuit.keygen() # Run the inference on encrypted inputs! y_pred_fhe = model.predict(X_test, fhe=\"execute\") print(\"In clear :\", y_pred_clear) print(\"In FHE :\", y_pred_fhe) print(f\"Similarity: {int((y_pred_fhe == y_pred_clear).mean()*100)}%\") More information and examples are given in the Concrete ML documentation.", "prev_chunk_id": "chunk_82", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_84", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Tree Methods", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Tree Methods", "content": "Tree Methods For training boosted tree models, there are 2 parameters used for choosing algorithms, namely updater and tree_method. XGBoost has 3 builtin tree methods, namely exact, approx and hist. Along with these tree methods, there are also some free standing updaters including refresh, prune and sync. The parameter updater is more primitive than tree_method as the latter is just a pre-configuration of the former. The difference is mostly due to historical reasons that each updater requires some specific configurations and might has missing features. As we are moving forward, the gap between them is becoming more and more irrelevant. We will collectively document them under tree methods.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_85", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Exact Solution", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Exact Solution", "content": "Exact Solution Exact means XGBoost considers all candidates from data for tree splitting, but underlying the objective is still interpreted as a Taylor expansion. - exact: The vanilla gradient boosting tree algorithm described inreference paper. During split-finding, it iterates over all entries of input data. It’s more accurate (among other greedy methods) but computationally slower in compared to other tree methods. Further more, its feature set is limited. Features like distributed training and external memory that require approximated quantiles are not supported. This tree method can be used with the parametertree_methodset toexact.", "prev_chunk_id": "chunk_84", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_86", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Approximated Solutions", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Approximated Solutions", "content": "Approximated Solutions As exact tree method is slow in computation performance and difficult to scale, we often employ approximated training algorithms. These algorithms build a gradient histogram for each node and iterate through the histogram instead of real dataset. Here we introduce the implementations in XGBoost. - approxtree method: An approximation tree method described inreference paper. It runs sketching before building each tree using all the rows (rows belonging to the root). Hessian is used as weights during sketch. The algorithm can be accessed by settingtree_methodtoapprox. - histtree method: An approximation tree method used in LightGBM with slight differences in implementation. It runs sketching before training using only user provided weights instead of hessian. The subsequent per-node histogram is built upon this global sketch. This is the fastest algorithm as it runs sketching only once. The algorithm can be accessed by settingtree_methodtohist.", "prev_chunk_id": "chunk_85", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_87", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Implications", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Implications", "content": "Implications Some objectives like reg:squarederror have constant hessian. In this case, the hist should be preferred as weighted sketching doesn’t make sense with constant weights. When using non-constant hessian objectives, sometimes approx yields better accuracy, but with slower computation performance. Most of the time using hist with higher max_bin can achieve similar or even superior accuracy while maintaining good performance. However, as xgboost is largely driven by community effort, the actual implementations have some differences than pure math description. Result might be slightly different than expectation, which we are currently trying to overcome.", "prev_chunk_id": "chunk_86", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_88", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Other Updaters", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Other Updaters", "content": "Other Updaters - Prune: It prunes the existing trees.pruneis usually used as part of other tree methods. To use pruner independently, one needs to set the process type to update by:{\"process_type\":\"update\",\"updater\":\"prune\"}. With this set of parameters, during training, XGBoost will prune the existing trees according to 2 parametersmin_split_loss(gamma)andmax_depth. - Refresh: Refresh the statistic of built trees on a new training dataset. Like the pruner, To use refresh independently, one needs to set the process type to update:{\"process_type\":\"update\",\"updater\":\"refresh\"}. During training, the updater will change statistics likecoverandweightaccording to the new training dataset. Whenrefresh_leafis also set to true (default), XGBoost will update the leaf value according to the new leaf weight, but the tree structure (split condition) itself doesn’t change.There are examples on both training continuation (adding new trees) and using update process ondemo/guide-python. Also checkout theprocess_typeparameter inXGBoost Parameters. - Sync: Synchronize the tree among workers when running distributed training.", "prev_chunk_id": "chunk_87", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_89", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Removed Updaters", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Removed Updaters", "content": "Removed Updaters 3 Updaters were removed during development due to maintainability. We describe them here solely for the interest of documentation. - Distributed colmaker, which was a distributed version of exact tree method. It required specialization for column based splitting strategy and a different prediction procedure. As the exact tree method is slow by itself and scaling is even less efficient, we removed it entirely. - skmaker. Per-node weighted sketching employed bygrow_local_histmakeris slow, theskmakerwas unmaintained and seems to be a workaround trying to eliminate the histogram creation step and uses sketching values directly during split evaluation. It was never tested and contained some unknown bugs, we decided to remove it and focus our resources on more promising algorithms instead. For accuracy, most of the timeapproxandhistare enough with some parameters tuning, so removing them don’t have any real practical impact. - grow_local_histmakerupdater: An approximation tree method described inreference paper. This updater was rarely used in practice so it was still an updater rather than tree method. During split finding, it first runs a weighted GK sketching for data points belong to current node to find split candidates, using hessian as weights. The histogram is built upon this per-node sketch. It was faster thanexactin some applications, but still slow in computation. It was removed because it depended on Rabit’s customized reduction function that handles all the data structure that can be serialized/deserialized into fixed size buffer, which is not directly supported by NCCL or federated learning gRPC, making it hard to refactor into a common allreducer interface.", "prev_chunk_id": "chunk_88", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_90", "url": "https://xgboost.readthedocs.io/en/stable/treemethod.html", "title": "Feature Matrix", "page_title": "Tree Methods — xgboost 3.0.4 documentation", "breadcrumbs": "Feature Matrix", "content": "Feature Matrix Following table summarizes some differences in supported features between 4 tree methods, T means supported while F means unsupported. | Exact | Approx | Approx (GPU) | Hist | Hist (GPU) grow_policy | Depthwise | depthwise/lossguide | depthwise/lossguide | depthwise/lossguide | depthwise/lossguide max_leaves | F | T | T | T | T sampling method | uniform | uniform | gradient_based/uniform | uniform | gradient_based/uniform categorical data | F | T | T | T | T External memory | F | T | P | T | P Distributed | F | T | T | T | T Features/parameters that are not mentioned here are universally supported for all 3 tree methods (for instance, column sampling and constraints). The P in external memory means special handling. Please note that both categorical data and external memory are experimental.", "prev_chunk_id": "chunk_89", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_91", "url": "https://xgboost.readthedocs.io/en/stable/python/index.html", "title": "XGBoost Python Package", "page_title": "XGBoost Python Package — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Python Package", "content": "XGBoost Python Package This page contains links to all the python related documents on python package. To install the package, checkout Installation Guide.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_92", "url": "https://xgboost.readthedocs.io/en/stable/R-package/index.html", "title": "XGBoost R Package", "page_title": "XGBoost R Package — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost R Package", "content": "XGBoost R Package You have found the XGBoost R Package!", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_93", "url": "https://xgboost.readthedocs.io/en/stable/R-package/index.html", "title": "Get Started", "page_title": "XGBoost R Package — xgboost 3.0.4 documentation", "breadcrumbs": "Get Started", "content": "Get Started Since XGBoost 3.0.0, the latest R package is available on R-universe while the one on CRAN is kept at an older version. We will work on helping the CRAN version to catch up in the future. In the meantime, please use R-universe packages. - Check out theInstallation Guidefor instructions on how to install xgboost, andTutorialsfor examples on how to use XGBoost for various tasks. - Read the latestAPI documentation. - Read theCRAN documentation. (outdated)", "prev_chunk_id": "chunk_92", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_94", "url": "https://xgboost.readthedocs.io/en/stable/jvm/index.html", "title": "XGBoost JVM Package", "page_title": "XGBoost JVM Package — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost JVM Package", "content": "XGBoost JVM Package You have found the XGBoost JVM Package!", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_95", "url": "https://xgboost.readthedocs.io/en/stable/jvm/index.html", "title": "Installation", "page_title": "XGBoost JVM Package — xgboost 3.0.4 documentation", "breadcrumbs": "Installation", "content": "Installation Checkout the Installation Guide for how to install the jvm package, or Building from Source on how to build it from the sources.", "prev_chunk_id": "chunk_94", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_96", "url": "https://xgboost.readthedocs.io/en/stable/julia.html", "title": "XGBoost.jl", "page_title": "XGBoost.jl — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost.jl", "content": "XGBoost.jl See XGBoost.jl Project page.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_97", "url": "https://xgboost.readthedocs.io/en/stable/c.html", "title": "XGBoost C Package", "page_title": "XGBoost C Package — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost C Package", "content": "XGBoost C Package XGBoost implements a set of C API designed for various bindings, we maintain its stability and the CMake/make build interface. See C API Tutorial for an introduction and demo/c-api/ for related examples. Also one can generate doxygen document by providing -DBUILD_C_DOC=ON as parameter to CMake during build, or simply look at function comments in include/xgboost/c_api.h. The reference is exported to sphinx with the help of breathe, which doesn’t contain links to examples but might be easier to read. For the original doxygen pages please visit: - C API documentation (latest master branch) - C API documentation (last stable release)", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_98", "url": "https://xgboost.readthedocs.io/en/stable/c.html", "title": "Factory functions", "page_title": "XGBoost C Package — xgboost 3.0.4 documentation", "breadcrumbs": "Factory functions", "content": "Factory functions XGDMatrixCreateFromCallback for external memory XGQuantileDMatrixCreateFromCallback for quantile DMatrix XGExtMemQuantileDMatrixCreateFromCallback for External memory Quantile DMatrix", "prev_chunk_id": "chunk_97", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_99", "url": "https://xgboost.readthedocs.io/en/stable/c.html", "title": "Proxy that callers can use to pass data to XGBoost", "page_title": "XGBoost C Package — xgboost 3.0.4 documentation", "breadcrumbs": "Proxy that callers can use to pass data to XGBoost", "content": "Proxy that callers can use to pass data to XGBoost XGProxyDMatrixCreate XGDMatrixCallbackNext DataIterResetCallback XGProxyDMatrixSetDataCudaArrayInterface XGProxyDMatrixSetDataColumnar XGProxyDMatrixSetDataCudaColumnar XGProxyDMatrixSetDataDense XGProxyDMatrixSetDataCSR … (data setters)", "prev_chunk_id": "chunk_98", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_100", "url": "https://xgboost.readthedocs.io/en/stable/c%2B%2B.html", "title": "XGBoost C++ API", "page_title": "XGBoost C++ API — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost C++ API", "content": "XGBoost C++ API Starting from 1.0 release, CMake will generate installation rules to export all C++ headers. But the c++ interface is much closer to the internal of XGBoost than other language bindings. As a result it’s changing quite often and we don’t maintain its stability. Along with the plugin system (see plugin/example in XGBoost’s source tree), users can utilize some existing c++ headers for gaining more access to the internal of XGBoost. - C++ interface documentation (latest master branch) - C++ interface documentation (last stable release)", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_101", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Text Input Format of DMatrix", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Text Input Format of DMatrix", "content": "Text Input Format of DMatrix Here we will briefly describe the text input formats for XGBoost. However, for users with access to a supported language environment like Python or R, it’s recommended to use data parsers from that ecosystem instead. For instance, sklearn.datasets.load_svmlight_file().", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_102", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Basic Input Format", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Basic Input Format", "content": "Basic Input Format XGBoost currently supports two text formats for ingesting data: LIBSVM and CSV. The rest of this document will describe the LIBSVM format. (See this Wikipedia article for a description of the CSV format.). Please be careful that, XGBoost does not understand file extensions, nor try to guess the file format, as there is no universal agreement upon file extension of LIBSVM or CSV. Instead it employs URI format for specifying the precise input file type. For example if you provide a csv file ./data.train.csv as input, XGBoost will blindly use the default LIBSVM parser to digest it and generate a parser error. Instead, users need to provide an URI in the form of train.csv?format=csv or train.csv?format=libsvm. For external memory input, the URI should of a form similar to train.csv?format=csv#dtrain.cache. See Data Interface and Using XGBoost External Memory Version also. For training or predicting, XGBoost takes an instance file with the format as below: Each line represent a single instance, and in the first line ‘1’ is the instance label, ‘101’ and ‘102’ are feature indices, ‘1.2’ and ‘0.03’ are feature values. In the binary classification case, ‘1’ is used to indicate positive samples, and ‘0’ is used to indicate negative samples. We also support probability values in [0,1] as label, to indicate the probability of the instance being positive.", "prev_chunk_id": "chunk_101", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_103", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Auxiliary Files for Additional Information", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Auxiliary Files for Additional Information", "content": "Auxiliary Files for Additional Information Note: all information below is applicable only to single-node version of the package. If you’d like to perform distributed training with multiple nodes, skip to the section Embedding additional information inside LIBSVM file.", "prev_chunk_id": "chunk_102", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_104", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Group Input Format", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Group Input Format", "content": "Group Input Format For ranking task, XGBoost supports the group input format. In ranking task, instances are categorized into query groups in real world scenarios. For example, in the learning to rank web pages scenario, the web page instances are grouped by their queries. XGBoost requires an file that indicates the group information. For example, if the instance file is the train.txt shown above, the group file should be named train.txt.group and be of the following format: This means that, the data set contains 5 instances, and the first two instances are in a group and the other three are in another group. The numbers in the group file are actually indicating the number of instances in each group in the instance file in order. At the time of configuration, you do not have to indicate the path of the group file. If the instance file name is xxx, XGBoost will check whether there is a file named xxx.group in the same directory.", "prev_chunk_id": "chunk_103", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_105", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Instance Weight File", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Instance Weight File", "content": "Instance Weight File Instances in the training data may be assigned weights to differentiate relative importance among them. For example, if we provide an instance weight file for the train.txt file in the example as below: It means that XGBoost will emphasize more on the first and fourth instance (i.e. the positive instances) while training. The configuration is similar to configuring the group information. If the instance file name is xxx, XGBoost will look for a file named xxx.weight in the same directory. If the file exists, the instance weights will be extracted and used at the time of training.", "prev_chunk_id": "chunk_104", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_106", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Initial Margin File", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Initial Margin File", "content": "Initial Margin File XGBoost supports providing each instance an initial margin prediction. For example, if we have a initial prediction using logistic regression for train.txt file, we can create the following file: XGBoost will take these values as initial margin prediction and boost from that. An important note about base_margin is that it should be margin prediction before transformation, so if you are doing logistic loss, you will need to put in value before logistic transformation. If you are using XGBoost predictor, use pred_margin=1 to output margin values.", "prev_chunk_id": "chunk_105", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_107", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Embedding additional information inside LIBSVM file", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Embedding additional information inside LIBSVM file", "content": "Embedding additional information inside LIBSVM file This section is applicable to both single- and multiple-node settings.", "prev_chunk_id": "chunk_106", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_108", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Query ID Columns", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Query ID Columns", "content": "Query ID Columns This is most useful for ranking task, where the instances are grouped into query groups. You may embed query group ID for each instance in the LIBSVM file by adding a token of form qid:xx in each row: Keep in mind the following restrictions: - You are not allowed to specify query ID’s for some instances but not for others. Either every row is assigned query ID’s or none at all. - The rows have to be sorted in ascending order by the query IDs. So, for instance, you may not have one row having large query ID than any of the following rows.", "prev_chunk_id": "chunk_107", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_109", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/input_format.html", "title": "Instance weights", "page_title": "Text Input Format of DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Instance weights", "content": "Instance weights You may specify instance weights in the LIBSVM file by appending each instance label with the corresponding weight in the form of [label]:[weight], as shown by the following example: where the negative instances are assigned half weights compared to the positive instances.", "prev_chunk_id": "chunk_108", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_110", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "2.1.4 Patch Release (2025 Feb 6)", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "2.1.4 Patch Release (2025 Feb 6)", "content": "2.1.4 Patch Release (2025 Feb 6) The 2.1.4 patch release incorporates the following fixes on top of the 2.1.3 release: - XGBoost is now compatible with scikit-learn 1.6 (#11021, #11162) - Build wheels with CUDA 12.8 and enable Blackwell support (#11187, #11202) - Adapt to RMM 25.02 logger changes (#11153)", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_111", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "2.1.3 Patch Release (2024 Nov 26)", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "2.1.3 Patch Release (2024 Nov 26)", "content": "2.1.3 Patch Release (2024 Nov 26) The 2.1.3 patch release makes the following bug fixes: - [pyspark] Support large model size (#10984). - Fix rng for the column sampler (#10998). - Handlecudf.pandasproxy objects properly (#11014).", "prev_chunk_id": "chunk_110", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_112", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "2.1.2 Patch Release (2024 Oct 23)", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "2.1.2 Patch Release (2024 Oct 23)", "content": "2.1.2 Patch Release (2024 Oct 23) The 2.1.2 patch release makes the following bug fixes: - Clean up and modernize release-artifacts.py (#10818) - Fix ellpack categorical feature with missing values. (#10906) - Fix unbiased ltr with training continuation. (#10908) - Fix potential race in feature constraint. (#10719) - Fix boolean array for arrow-backed DF. (#10527) - Ensure that pip check does not fail due to a bad platform tag (#10755) - Check cub errors (#10721) - Limit the maximum number of threads. (#10872) - Fixes for large size clusters. (#10880) - POSIX compliant poll.h and mmap (#10767)", "prev_chunk_id": "chunk_111", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_113", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "2.1.1 Patch Release (2024 Jul 31)", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "2.1.1 Patch Release (2024 Jul 31)", "content": "2.1.1 Patch Release (2024 Jul 31) The 2.1.1 patch release makes the following bug fixes: - [Dask] Disable broadcast in the scatter call so that predict function won’t hang (#10632) - [Dask] Handle empty partitions correctly (#10559) - Fix federated learning for the encrypted GRPC backend (#10503) - Fix a race condition in column splitter (#10572) - Gracefully handle cases where system files like /sys/fs/cgroup/cpu.max are not readable by the user (#10623) - Fix build and C++ tests for FreeBSD (#10480) - Clarify the requirement Pandas 1.2+ (#10476) - More robust endianness detection in R package build (#10642) In addition, it contains several enhancements: - Publish JVM packages targeting Linux ARM64 (#10487) - Publish a CPU-only wheel under name xgboost-cpu (#10603) - Support building with CUDA Toolkit 12.5 and latest CCCL (#10624, #10633, #10574)", "prev_chunk_id": "chunk_112", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_114", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "2.1.0 (2024 Jun 20)", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "2.1.0 (2024 Jun 20)", "content": "2.1.0 (2024 Jun 20) We are thrilled to announce the XGBoost 2.1 release. This note will start by summarizing some general changes and then highlighting specific package updates. As we are working on a new R interface, this release will not include the R package. We’ll update the R package as soon as it’s ready. Stay tuned!", "prev_chunk_id": "chunk_113", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_115", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Networking Improvements", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Networking Improvements", "content": "Networking Improvements An important ongoing work for XGBoost, which we’ve been collaborating on, is to support resilience for improved scaling and federated learning on various platforms. The existing networking library in XGBoost, adopted from the RABIT project, can no longer meet the feature demand. We’ve revamped the RABIT module in this release to pave the way for future development. The choice of using an in-house version instead of an existing library is due to the active development status with frequent new feature requests like loading extra plugins for federated learning. The new implementation features: - Both CPU and GPU communication (based on NCCL). - A reusable tracker for both the Python package and JVM packages. With the new release, the JVM packages no longer require Python as a runtime dependency. - Supports federated communication patterns for both CPU and GPU. - Supports timeout. The high-level interface parameter is currently hard-coded to 30 minutes, which we plan to improve. - Supports significantly more data types. - Supports thread-based workers. - Improved handling for worker errors, including better error messages when one of the peers dies during training. - Work with IPv6. Currently, this is only supported by the dask interface. - Built-in support for various operations like broadcast, allgatherV, allreduce, etc. Related PRs (#9597, #9576, #9523, #9524, #9593, #9596, #9661, #10319, #10152, #10125, #10332, #10306, #10208, #10203, #10199, #9784, #9777, #9773, #9772, #9759, #9745, #9695, #9738, #9732, #9726, #9688, #9681, #9679, #9659, #9650, #9644, #9649, #9917, #9990, #10313, #10315, #10112, #9531, #10075, #9805, #10198, #10414). The existing option of using MPI in RABIT is removed in the release. (#9525)", "prev_chunk_id": "chunk_114", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_116", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "NCCL is now fetched from PyPI", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "NCCL is now fetched from PyPI", "content": "NCCL is now fetched from PyPI In the previous version, XGBoost statically linked NCCL, which significantly increased the binary size and led to hitting the PyPI repository limit. With the new release, we have made a significant improvement. The new release can now dynamically load NCCL from an external source, reducing the binary size. For the PyPI package, the nvidia-nccl-cu12 package will be fetched during installation. With more downstream packages reusing NCCL, we expect the user environments to be slimmer in the future as well. (#9796, #9804, #10447)", "prev_chunk_id": "chunk_115", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_117", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Parts of the Python package now require glibc 2.28+", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Parts of the Python package now require glibc 2.28+", "content": "Parts of the Python package now require glibc 2.28+ Starting from 2.1.0, XGBoost Python package will be distributed in two variants: - manylinux_2_28: for recent Linux distros with glibc 2.28 or newer. This variant comes with all features enabled. - manylinux2014: for old Linux distros with glibc older than 2.28. This variant does not support GPU algorithms or federated learning. The pip package manager will automatically choose the correct variant depending on your system. Starting from May 31, 2025, we will stop distributing the manylinux2014 variant and exclusively distribute the manylinux_2_28 variant. We made this decision so that our CI/CD pipeline won’t have depend on software components that reached end-of-life (such as CentOS 7). We strongly encourage everyone to migrate to recent Linux distros in order to use future versions of XGBoost. Note. If you want to use GPU algorithms or federated learning on an older Linux distro, you have two alternatives: - Upgrade to a recent Linux distro with glibc 2.28+. OR - Build XGBoost from the source.", "prev_chunk_id": "chunk_116", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_118", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Multi-output", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Multi-output", "content": "Multi-output We continue the work on multi-target and vector leaf in this release: - Revise the support for custom objectives with a new API,XGBoosterTrainOneIter. This new function supports strided matrices and CUDA inputs. In addition, custom objectives now return the correct shape for prediction. (#9508) - Thehingeobjective now supports multi-target regression (#9850) - Fix the gain calculation with vector leaf (#9978) - Support graphviz plot for multi-target tree. (#10093) - Fix multi-output with alternating strategies. (#9933) Please note that the feature is still in progress and not suitable for production use.", "prev_chunk_id": "chunk_117", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_119", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Federated Learning", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Federated Learning", "content": "Federated Learning Progress has been made on federated learning with improved support for column-split, including the following updates: - Column split work for both CPU and GPU. In addition, categorical data is now compatible with column split. (#9562, #9609, #9611, #9628, #9539, #9578, #9685, #9623, #9613, #9511, #9384, #9595) - The use of UBJson to serialize split entries for column split has been implemented, aiding vector-leaf with column-based data split. (#10059, #10055, #9702) - Documentation and small fixes. (#9610, #9552, #9614, #9867)", "prev_chunk_id": "chunk_118", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_120", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Ongoing work for SYCL support", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Ongoing work for SYCL support", "content": "Ongoing work for SYCL support XGBoost is developing a SYCL plugin for SYCL devices, starting with the hist tree method. (#10216, #9800, #10311, #9691, #10269, #10251, #10222, #10174, #10080, #10057, #10011, #10138, #10119, #10045, #9876, #9846, #9682) XGBoost now supports launchable inference on SYCL devices, and that work on adding SYCL support for training is ongoing. Looking ahead, we plan to complete the training in coming releases and then focus on improving test coverage for SYCL, particularly for Python tests.", "prev_chunk_id": "chunk_119", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_121", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Optimizations", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Optimizations", "content": "Optimizations - Implement column sampler in CUDA for GPU-based tree methods. This helps us get faster training time when column sampling is employed (#9785) - CMake LTO and CUDA arch (#9677) - Small optimization to external memory with a thread pool. This reduces the number of threads launched during iteration. (#9605, #10288, #10374)", "prev_chunk_id": "chunk_120", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_122", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Deprecation and breaking changes", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Deprecation and breaking changes", "content": "Deprecation and breaking changes Package-specific breaking changes are outlined in respective sections. Here we list general breaking changes in this release: - The command line interface is deprecated due to the increasing complexity of the machine learning ecosystem. Building a machine learning model using a command shell is no longer feasible and could mislead newcomers. (#9485) - UniversalbinaryJSONis now the default format for saving models (#9947, #9958, #9954, #9955). Seehttps://github.com/dmlc/xgboost/issues/7547for more info. - TheXGBoosterGetModelRawis now removed after deprecation in 1.6. (#9617) - Drop support for loading remote files. This feature lacks any test. Users are encouraged to use dedicated libraries to fetch remote content. (#9504) - Remove the dense libsvm parser plugin. This plugin is never tested or documented (#9799) - XGDMatrixSetDenseInfoandXGDMatrixSetUIntInfoare now deprecated. Use the array interface based alternatives instead.", "prev_chunk_id": "chunk_121", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_123", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Features", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Features", "content": "Features This section lists some new features that are general to all language bindings. For package-specific changes, please visit respective sections. - Adopt a new XGBoost logo (#10270) - Now supports dataframe data format in native XGBoost. This improvement enhances performance and reduces memory usage when working with dataframe-based structures such as pandas, arrow, and R dataframe. (#9828, #9616, #9905) - Change default metric for gamma regression todeviance. (#9757) - Normalization for learning to rank is now optional with the introduction of the newlambdarank_normalizationparameter. (#10094) - Contribution prediction withQuantileDMatrixon CPU. (#10043) - XGBoost on macos no longer bundles OpenMP runtime. Users can install the latest runtime from their dependency manager of choice. (#10440). Along with which, JVM packages on MacoOS are now built with OpenMP support (#10449).", "prev_chunk_id": "chunk_122", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_124", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Bug fixes", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Bug fixes", "content": "Bug fixes - Fix training with categorical data from external memory. (#10433) - Fix compilation with CTK-12. (#10123) - Fix inconsistent runtime library on Windows. (#10404) - Fix default metric configuration. (#9575) - Fix feature names with special characters. (#9923) - Fix global configuration for external memory training. (#10173) - Disable column sample by node for the exact tree method. (#10083) - Fix theFieldEntryconstructor specialization syntax error (#9980) - Fix pairwise objective with NDCG metric along with custom gain. (#10100) - Fix the default value forlambdarank_pair_method. (#10098) - Fix UBJSON with boolean values. No existing code is affected by this fix. (#10054) - Be more lenient on floating point errors for AUC. This prevents the AUC > 1.0 error. (#10264) - Check support status for categorical features. This preventsgblinearfrom treating categorical features as numerical. (#9946)", "prev_chunk_id": "chunk_123", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_125", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Document", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Document", "content": "Document Here is a list of documentation changes not specific to any XGBoost package. - A new coarse map for XGBoost features to assist development. (#10310) - New language binding consistency guideline. (#9755, #9866) - Fixes, cleanups, small updates (#9501, #9988, #10023, #10013, #10143, #9904, #10179, #9781, #10340, #9658, #10182, #9822) - Update document for parameters (#9900) - Brief introduction tobase_score. (#9882) - Mention data consistency for categorical features. (#9678)", "prev_chunk_id": "chunk_124", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_126", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Dask", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Dask", "content": "Dask Other than the changes in networking, we have some optimizations and document updates in dask: - Filter models on workers instead of clients; this prevents an OOM error on the client machine. (#9518) - Users are now encouraged to usefrom xgboost import daskinstead ofimport xgboost.daskto avoid drawing in unnecessary dependencies for non-dask users. (#9742) - Add seed to demos. (#10009) - New document for using dask XGBoost with k8s. (#10271) - Workaround potentially unaligned pointer from an empty partition. (#10418) - Workaround a race condition in the latest dask. (#10419) - [doc] Add typing to dask demos. (#10207)", "prev_chunk_id": "chunk_125", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_127", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "PySpark", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "PySpark", "content": "PySpark PySpark has several new features along with some small fixes: - Support stage-level scheduling for training on various platforms, including yarn/k8s. (#9519, #10209, #9786, #9727) - Support GPU-based transform methods (#9542) - Avoid expensive repartition when appropriate. (#10408) - Refactor the logging and the GPU code path (#10077, 9724) - Sort workers by task ID. This helps the PySpark interface obtain deterministic results. (#10220) - Fix PySpark withverbosity=3. (#10172) - Fix spark estimator doc. (#10066) - Rework transform for improved code reusing. (#9292)", "prev_chunk_id": "chunk_126", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_128", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Breaking changes", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Breaking changes", "content": "Breaking changes For the Python package, eval_metric, early_stopping_rounds, and callbacks from now removed from the fit method in the sklearn interface. They were deprecated in 1.6. Use the parameters with the same name in constructors instead. (#9986)", "prev_chunk_id": "chunk_127", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_129", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Features", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Features", "content": "Features Following is a list of new features in the Python package: - Support sample weight in sklearn custom objective. (#10050) - New supported data types, includingcudf.pandas(#9602),torch.Tensor(#9971), and more scipy types (#9881). - Support pandas 2.2 and numpy 2.0. (#10266, #9557, #10252, #10175) - Support the latest rapids including rmm. (#10435) - Improved data cache option in data iterator. (#10286) - Accept numpy generators asrandom_state(#9743) - Support returning base score as intercept in the sklearn interface. (#9486) - Support arrow through pandas ext types. This is built on top of the new DataFrame API in XGBoost. See general features for more info. (#9612) - Handle np integer in model slice and prediction. (#10007) - Improved sklearn tags support. (#10230) - The base image for building Linux binary wheels is updated to rockylinux8. (#10399) - Improved handling for float128. (#10322)", "prev_chunk_id": "chunk_128", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_130", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Fixes", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Fixes", "content": "Fixes - FixDMatrixwithNoneinput. (#10052) - Fix native library discovery logic. (#9712, #9860) - Fix using categorical data with the score function for the ranker. (#9753)", "prev_chunk_id": "chunk_129", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_131", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Document", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Document", "content": "Document - Clarify the effect ofenable_categorical(#9877, #9884) - Update the Python introduction. (#10033) - Fixes. (#10058, #9991, #9573)", "prev_chunk_id": "chunk_130", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_132", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Maintenance", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Maintenance", "content": "Maintenance - Use array interface in Python prediction return. (#9855) - Synthesize the AMES housing dataset for tests. (#9963) - linter, formatting, etc. (#10296, #10014) - Tests. (#9962, #10285, #9997, #9943, #9934)", "prev_chunk_id": "chunk_131", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_133", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "JVM packages", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "JVM packages", "content": "JVM packages Here is a list of JVM-specific changes. Like the PySpark package, the JVM package also gains stage-level scheduling.", "prev_chunk_id": "chunk_132", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_134", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Features and related documents", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Features and related documents", "content": "Features and related documents - Support stage-level scheduling (#9775) - Allow JVM-Package to access inplace predict method (#9167) - Support JDK 17 for test (#9959) - Various dependency updates.(#10211, #10210, #10217, #10156, #10070, #9809, #9517, #10235, #10276, #9331, #10335, #10309, #10240, #10244, #10260, #9489, #9326, #10294, #10197, #10196, #10193, #10202, #10191, #10188, #9328, #9311, #9951, #10151, #9827, #9820, #10253) - Update and fixes for document. (#9752, #10385) - Remove rabit checkpoint. (#9599)", "prev_chunk_id": "chunk_133", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_135", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Bug Fixes", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Bug Fixes", "content": "Bug Fixes - Fixes memory leak in error handling. (#10307) - Fixes group col for GPU packages (#10254)", "prev_chunk_id": "chunk_134", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_136", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "Maintenance", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "Maintenance", "content": "Maintenance - Add formatting and linting requirements to the CMake script. (#9653, #9641, #9637, #9728, #9674) - Refactors and cleanups (#10085, #10120, #10074, #9645, #9992, #9568, #9731, #9527). - Update nvtx. (#10227) - Tests. (#9499, #9553, #9737) - Throw error for 32-bit architectures (#10005) - Helpers. (#9505, #9572, #9750, #9541, #9983, #9714) - Fix mingw hanging on regex in context (#9729) - Linters. (#10010, #9634)", "prev_chunk_id": "chunk_135", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_137", "url": "https://xgboost.readthedocs.io/en/stable/changes/v2.1.0.html", "title": "CI", "page_title": "2.1.4 Patch Release (2025 Feb 6) — xgboost 3.0.4 documentation", "breadcrumbs": "CI", "content": "CI - Meta info about the Python package is uploaded for easier parsing (#10295) - Various dependency updates (#10274, #10280, #10278, #10275, #10320, #10305, #10267, #9544, #10228, #10133, #10187, #9857, #10042, #10268, #9654, #9835) - GitHub Action fixes (#10067, #10134, #10064) - Improved support for Apple devices. (#10225, #9886, #9699, #9748, #9704, #9749) - Stop Windows pipeline upon a failing pytest (#10003) - Cancel GH Action job if a newer commit is published (#10088) - CI images. (#9666, #10201, #9932) - Test R package with CMake (#10087) - Test building for the 32-bit arch (#10021) - Test federated plugin using GitHub action. (#10336)", "prev_chunk_id": "chunk_136", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_138", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Automated testing in XGBoost project", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Automated testing in XGBoost project", "content": "Automated testing in XGBoost project This document collects tips for using the Continuous Integration (CI) service of the XGBoost project. Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_139", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Running R tests with noLD option", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Running R tests with noLD option", "content": "Running R tests with noLD option You can run R tests using a custom-built R with compilation flag --disable-long-double. See this page for more details about noLD. This is a requirement for keeping XGBoost on CRAN (the R package index). Unlike other tests, this test must be invoked manually. Simply add a review comment /gha run r-nold-test to a pull request to kick off the test. (Ordinary comment won’t work. It needs to be a review comment.)", "prev_chunk_id": "chunk_138", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_140", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Making changes to CI containers", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Making changes to CI containers", "content": "Making changes to CI containers Many of the CI pipelines use Docker containers to ensure consistent testing environment with a variety of software packages. We have a separate repo, dmlc/xgboost-devops, to host the logic for building and publishing CI containers. To make changes to the CI container, carry out the following steps: - Identify which container needs updating. Example:492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main - Clonedmlc/xgboost-devopsand make changes to the corresponding Dockerfile. Example:containers/dockerfile/Dockerfile.gpu. - Locally build the container, to ensure that the container successfully builds. ConsultReproducing CI testing environments locallyfor this step. - Submit a pull request todmlc/xgboost-devopswith the proposed changes to the Dockerfile. Make note of the pull request number. Example:#204 - Clonedmlc/xgboost. Locate the fileops/pipeline/get-image-tag.sh, which should have a single lineIMAGE_TAG=mainTo use the new container, revise the file as follows:IMAGE_TAG=PR-XXwhereXXis the pull request number. - Now submit a pull request todmlc/xgboost. The CI will run tests using the new container. Verify that all tests pass. - Merge the pull request indmlc/xgboost-devops. Wait until the CI completes on themainbranch. - Go back to the the pull request fordmlc/xgboostand changeops/pipeline/get-image-tag.shback toIMAGE_TAG=main. - Merge the pull request indmlc/xgboost.", "prev_chunk_id": "chunk_139", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_141", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Reproducing CI testing environments locally", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Reproducing CI testing environments locally", "content": "Reproducing CI testing environments locally You can reproduce the same testing environment as the CI pipelines by building and running Docker containers locally. Prerequisites - Install Docker:https://docs.docker.com/engine/install/ubuntu/ - Install NVIDIA Docker runtime:https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/latest/install-guide.html. The runtime lets you access NVIDIA GPUs inside a Docker container.", "prev_chunk_id": "chunk_140", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_142", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "To build a Docker container", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "To build a Docker container", "content": "To build a Docker container Clone the repository dmlc/xgboost-devops and invoke containers/docker_build.sh as follows: # The following env vars are only relevant for CI # For local testing, set them to \"main\" export GITHUB_SHA=\"main\" export BRANCH_NAME=\"main\" bash containers/docker_build.sh IMAGE_REPO where IMAGE_REPO is the name of the container image. The wrapper script will look up the YAML file containers/ci_container.yml. For example, when IMAGE_REPO is set to xgb-ci.gpu, the script will use the corresponding entry from containers/ci_container.yml: xgb-ci.gpu: container_def: gpu build_args: CUDA_VERSION_ARG: \"12.4.1\" NCCL_VERSION_ARG: \"2.23.4-1\" RAPIDS_VERSION_ARG: \"24.10\" The container_def entry indicates where the Dockerfile is located. The container definition will be fetched from containers/dockerfile/Dockerfile.CONTAINER_DEF where CONTAINER_DEF is the value of container_def entry. In this example, the Dockerfile is containers/dockerfile/Dockerfile.gpu. The build_args entry lists all the build arguments for the Docker build. In this example, the build arguments are: --build-arg CUDA_VERSION_ARG=12.4.1 --build-arg NCCL_VERSION_ARG=2.23.4-1 \\ --build-arg RAPIDS_VERSION_ARG=24.10 The build arguments provide inputs to the ARG instructions in the Dockerfile. When containers/docker_build.sh completes, you will have access to the container with the (fully qualified) URI 492475357299.dkr.ecr.us-west-2.amazonaws.com/[image_repo]:main. The prefix 492475357299.dkr.ecr.us-west-2.amazonaws.com/ was added so that the container could later be uploaded to AWS Elastic Container Registry (ECR), a private Docker registry.", "prev_chunk_id": "chunk_141", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_143", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "To run commands within a Docker container", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "To run commands within a Docker container", "content": "To run commands within a Docker container Invoke ops/docker_run.py from the main dmlc/xgboost repo as follows: python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/[image_repo]:[image_tag] \\ [--use-gpus] \\ -- \"command to run inside the container\" where --use-gpus should be specified to expose NVIDIA GPUs to the Docker container. For example: # Run without GPU python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.cpu:main \\ -- bash ops/pipeline/build-cpu-impl.sh cpu # Run with NVIDIA GPU python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ --use-gpus \\ -- bash ops/pipeline/test-python-wheel-impl.sh gpu Optionally, you can specify --run-args to pass extra arguments to docker run: # Allocate extra space in /dev/shm to enable NCCL # Also run the container with elevated privileges python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ --use-gpus \\ --run-args='--shm-size=4g --privileged' \\ -- bash ops/pipeline/test-python-wheel-impl.sh gpu See Infra for building and publishing CI containers and VM images to read about how containers are built and managed in the CI pipelines.", "prev_chunk_id": "chunk_142", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_144", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Examples: useful tasks for local development", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Examples: useful tasks for local development", "content": "Examples: useful tasks for local development - Build XGBoost with GPU support + package it as a Python wheelexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.com python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.gpu_build_rockylinux8:main\\--ops/pipeline/build-cuda-impl.sh - Run Python testsexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.com python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.cpu:main\\--ops/pipeline/test-python-wheel-impl.shcpu - Run Python tests with GPU algorithmexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.com python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.gpu:main\\--use-gpus\\--ops/pipeline/test-python-wheel-impl.shgpu - Run Python tests with GPU algorithm, with multiple GPUsexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.com python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.gpu:main\\--use-gpus\\--run-args='--shm-size=4g'\\--ops/pipeline/test-python-wheel-impl.shmgpu# --shm-size=4g is needed for multi-GPU algorithms to function - Build and test JVM packagesexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.comexportSCALA_VERSION=2.12# Specify Scala version (2.12 or 2.13)python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.jvm:main\\--run-args\"-e SCALA_VERSION\"\\--ops/pipeline/build-test-jvm-packages-impl.sh - Build and test JVM packages, with GPU supportexportDOCKER_REGISTRY=492475357299.dkr.ecr.us-west-2.amazonaws.comexportSCALA_VERSION=2.12# Specify Scala version (2.12 or 2.13)exportUSE_CUDA=1python3ops/docker_run.py\\--image-uri${DOCKER_REGISTRY}/xgb-ci.jvm_gpu_build:main\\--use-gpus\\--run-args\"-e SCALA_VERSION -e USE_CUDA --shm-size=4g\"\\--ops/pipeline/build-test-jvm-packages-impl.sh# --shm-size=4g is needed for multi-GPU algorithms to function", "prev_chunk_id": "chunk_143", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_145", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "GitHub Actions", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "GitHub Actions", "content": "GitHub Actions We make the extensive use of GitHub Actions to host our CI pipelines. Most of the tests listed in the configuration files run automatically for every incoming pull requests and every update to branches.", "prev_chunk_id": "chunk_144", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_146", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Self-Hosted Runners with RunsOn", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Self-Hosted Runners with RunsOn", "content": "Self-Hosted Runners with RunsOn RunsOn is a SaaS (Software as a Service) app that lets us to easily create self-hosted runners to use with GitHub Actions pipelines. RunsOn uses Amazon Web Services (AWS) under the hood to provision runners with access to various amount of CPUs, memory, and NVIDIA GPUs. Thanks to this app, we are able to test GPU-accelerated and distributed algorithms of XGBoost while using the familar interface of GitHub Actions. In GitHub Actions, jobs run on Microsoft-hosted runners by default. To opt into self-hosted runners (enabled by RunsOn), we use the following special syntax: runs-on: - runs-on - runner=runner-name - run-id=${{ github.run_id }} - tag=[unique tag that uniquely identifies the job in the GH Action workflow] where the runner is defined in .github/runs-on.yml.", "prev_chunk_id": "chunk_145", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_147", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "The Lay of the Land: how CI pipelines are organized in the codebase", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "The Lay of the Land: how CI pipelines are organized in the codebase", "content": "The Lay of the Land: how CI pipelines are organized in the codebase The XGBoost project stores the configuration for its CI pipelines as part of the codebase. The git repository therefore stores not only the change history for its source code but also the change history for the CI pipelines. The CI pipelines are organized into the following directories and files: - .github/workflows/: Definition of CI pipelines, using the GitHub Actions syntax - .github/runs-on.yml: Configuration for the RunsOn service. Specifies the spec for the self-hosted CI runners. - ops/conda_env/: Definitions for Conda environments - ops/patch/: Patch files - ops/pipeline/: Shell scripts defining CI/CD pipelines. Most of these scripts can be run locally (to assist with development and debugging); a few must run in the CI. - ops/script/: Various utility scripts useful for testing - ops/docker_run.py: Wrapper script to run commands inside a container To inspect a given CI pipeline, inspect files in the following order: Many of the CI pipelines use Docker containers to ensure consistent testing environment with a variety of software packages. We have a separate repo, dmlc/xgboost-devops, that hosts the code for building the CI containers. The repository is organized as follows: - actions/: Custom actions to be used with GitHub Actions. SeeCustom actions for GitHub Actionsfor more details. - containers/dockerfile/: Dockerfiles to define containers - containers/ci_container.yml: Defines the mapping between Dockerfiles and containers. Also specifies the build arguments to be used with each container. - containers/docker_build.{py,sh}: Wrapper scripts to build and test CI containers. - vm_images/: Defines bootstrap scripts to build VM images for Amazon EC2. SeeNotes on VM imagesto learn about how VM images relate to container images. See Reproducing CI testing environments locally to learn about the utility scripts for building and using containers.", "prev_chunk_id": "chunk_146", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_148", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Artifact sharing between jobs via Amazon S3", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Artifact sharing between jobs via Amazon S3", "content": "Artifact sharing between jobs via Amazon S3 We make artifacts from one workflow job available to another job, by uploading the artifacts to Amazon S3. In the CI, we utilize the script ops/pipeline/manage-artifacts.py to coordinate artifact sharing. To upload files to S3: In the workflow YAML, add the following lines: - name: Upload files to S3 run: | REMOTE_PREFIX=\"remote directory to place the artifact(s)\" python3 ops/pipeline/manage-artifacts.py upload \\ --s3-bucket ${{ env.RUNS_ON_S3_BUCKET_CACHE }} \\ --prefix cache/${{ github.run_id }}/${REMOTE_PREFIX} \\ path/to/file The --prefix argument specifies the remote directory in which the artifact(s) should be placed. The artifact(s) will be placed in s3://{RUNS_ON_S3_BUCKET_CACHE}/cache/{GITHUB_RUN_ID}/{REMOTE_PREFIX}/ where RUNS_ON_S3_BUCKET_CACHE and GITHUB_RUN_ID are set by the CI. You can upload multiple files, possibly with wildcard globbing: - name: Upload files to S3 run: | python3 ops/pipeline/manage-artifacts.py upload \\ --s3-bucket ${{ env.RUNS_ON_S3_BUCKET_CACHE }} \\ --prefix cache/${{ github.run_id }}/build-cuda \\ build/testxgboost python-package/dist/*.whl To download files from S3: In the workflow YAML, add the following lines: - name: Download files from S3 run: | REMOTE_PREFIX=\"remote directory where the artifact(s) were placed\" python3 ops/pipeline/manage-artifacts.py download \\ --s3-bucket ${{ env.RUNS_ON_S3_BUCKET_CACHE }} \\ --prefix cache/${{ github.run_id }}/${REMOTE_PREFIX} \\ --dest-dir path/to/destination_directory \\ artifacts You can also use the wildcard globbing. The script will locate all artifacts under the given prefix that matches the wildcard pattern. - name: Download files from S3 run: | # Locate all artifacts with name *.whl under prefix # cache/${GITHUB_RUN_ID}/${REMOTE_PREFIX} and # download them to wheelhouse/. python3 ops/pipeline/manage-artifacts.py download \\ --s3-bucket ${{ env.RUNS_ON_S3_BUCKET_CACHE }} \\ --prefix cache/${{ github.run_id }}/${REMOTE_PREFIX} \\ --dest-dir wheelhouse/ \\ *.whl", "prev_chunk_id": "chunk_147", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_149", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Custom actions for GitHub Actions", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Custom actions for GitHub Actions", "content": "Custom actions for GitHub Actions XGBoost implements a few custom composite actions to reduce duplicated code within workflow YAML files. The custom actions are hosted in a separate repository, dmlc/xgboost-devops, to make it easy to test changes to the custom actions in a pull request or a fork. In a workflow file, we’d refer to dmlc/xgboost-devops/actions/{custom-action}@main. For example: - uses: dmlc/xgboost-devops/actions/miniforge-setup@main with: environment-name: cpp_test environment-file: ops/conda_env/cpp_test.yml Each custom action consists of two components: - Main script (dmlc/xgboost-devops/actions/{custom-action}/action.yml): dispatches to a specific version of the implementation script (see the next item). The main script clonesxgboost-devopsfrom a specified fork at a particular ref, allowing us to easily test changes to the custom action. - Implementation script (dmlc/xgboost-devops/actions/impls/{custom-action}/action.yml): Implements the custom script. This design was inspired by Mike Sarahan’s work in rapidsai/shared-actions.", "prev_chunk_id": "chunk_148", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_150", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Notes on Docker containers", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Notes on Docker containers", "content": "Notes on Docker containers CI pipeline for containers The dmlc/xgboost-devops repo hosts a CI pipeline to build new Docker containers at a regular schedule. New containers are built in the following occasions: - New commits are added to themainbranch ofdmlc/xgboost-devops. - New pull requests are submitted todmlc/xgboost-devops. - Every week, at a set day and hour. This setup ensures that the CI containers remain up-to-date. How wrapper scripts work The wrapper scripts docker_build.sh, docker_build.py (in dmlc/xgboost-devops) and docker_run.py (in dmlc/xgboost) are designed to transparently log what commands are being carried out under the hood. For example, when you run bash containers/docker_build.sh xgb-ci.gpu, the logs will show the following: # docker_build.sh calls docker_build.py... python3 containers/docker_build.py --container-def gpu \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ --build-arg CUDA_VERSION_ARG=12.4.1 --build-arg NCCL_VERSION_ARG=2.23.4-1 \\ --build-arg RAPIDS_VERSION_ARG=24.10 ... # .. and docker_build.py in turn calls \"docker build\"... docker build --build-arg CUDA_VERSION_ARG=12.4.1 \\ --build-arg NCCL_VERSION_ARG=2.23.4-1 \\ --build-arg RAPIDS_VERSION_ARG=24.10 \\ --load --progress=plain \\ --ulimit nofile=1024000:1024000 \\ -t 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ -f containers/dockerfile/Dockerfile.gpu \\ containers/ The logs come in handy when debugging the container builds. Here is an example with docker_run.py: # Run without GPU python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.cpu:main \\ -- bash ops/pipeline/build-cpu-impl.sh cpu # Run with NVIDIA GPU # Allocate extra space in /dev/shm to enable NCCL # Also run the container with elevated privileges python3 ops/docker_run.py \\ --image-uri 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ --use-gpus \\ --run-args='--shm-size=4g --privileged' \\ -- bash ops/pipeline/test-python-wheel-impl.sh gpu which are translated to the following docker run invocations: docker run --rm --pid=host \\ -w /workspace -v /path/to/xgboost:/workspace \\ -e CI_BUILD_UID=<uid> -e CI_BUILD_USER=<user_name> \\ -e CI_BUILD_GID=<gid> -e CI_BUILD_GROUP=<group_name> \\ 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.cpu:main \\ bash ops/pipeline/build-cpu-impl.sh cpu docker run --rm --pid=host --gpus all \\ -w /workspace -v /path/to/xgboost:/workspace \\ -e CI_BUILD_UID=<uid> -e CI_BUILD_USER=<user_name> \\ -e CI_BUILD_GID=<gid> -e CI_BUILD_GROUP=<group_name> \\ --shm-size=4g --privileged \\ 492475357299.dkr.ecr.us-west-2.amazonaws.com/xgb-ci.gpu:main \\ bash ops/pipeline/test-python-wheel-impl.sh gpu", "prev_chunk_id": "chunk_149", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_151", "url": "https://xgboost.readthedocs.io/en/stable/contrib/ci.html", "title": "Notes on VM images", "page_title": "Automated testing in XGBoost project — xgboost 3.0.4 documentation", "breadcrumbs": "Notes on VM images", "content": "Notes on VM images In the vm_images/ directory of dmlc/xgboost-devops, we define Packer scripts to build images for Virtual Machines (VM) on Amazon EC2. The VM image contains the minimal set of drivers and system software that are needed to run the containers. We update container images much more often than VM images. Whereas it takes only 10 minutes to build a new container image, it takes 1-2 hours to build a new VM image. To enable quick development iteration cycle, we place the most of the development environment in containers and keep VM images small. Packages need for testing should be baked into containers, not VM images. Developers can make changes to containers and see the results of the changes quickly. The dmlc/xgboost-devops repo hosts a CI pipeline to build new VM images at a regular schedule (currently monthly).", "prev_chunk_id": "chunk_150", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_152", "url": "https://xgboost.readthedocs.io/en/stable/python/gpu-examples/tree_shap.html", "title": "Use GPU to speedup SHAP value computation", "page_title": "Use GPU to speedup SHAP value computation — xgboost 3.0.4 documentation", "breadcrumbs": "Use GPU to speedup SHAP value computation", "content": "Use GPU to speedup SHAP value computation Demonstrates using GPU acceleration to compute SHAP values for feature importance. import shap from sklearn.datasets import fetch_california_housing import xgboost as xgb # Fetch dataset using sklearn data = fetch_california_housing() print(data.DESCR) X = data.data y = data.target num_round = 500 param = { \"eta\": 0.05, \"max_depth\": 10, \"tree_method\": \"hist\", \"device\": \"cuda\", } # GPU accelerated training dtrain = xgb.DMatrix(X, label=y, feature_names=data.feature_names) model = xgb.train(param, dtrain, num_round) # Compute shap values using GPU with xgboost model.set_param({\"device\": \"cuda\"}) shap_values = model.predict(dtrain, pred_contribs=True) # Compute shap interaction values using GPU shap_interaction_values = model.predict(dtrain, pred_interactions=True) # shap will call the GPU accelerated version as long as the device parameter is set to # \"cuda\" explainer = shap.TreeExplainer(model) shap_values = explainer.shap_values(X) # visualize the first prediction's explanation shap.force_plot( explainer.expected_value, shap_values[0, :], X[0, :], feature_names=data.feature_names, matplotlib=True, ) # Show a summary of feature importance shap.summary_plot(shap_values, X, plot_type=\"bar\", feature_names=data.feature_names) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_153", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/quantile_regression.html", "title": "Quantile Regression", "page_title": "Quantile Regression — xgboost 3.0.4 documentation", "breadcrumbs": "Quantile Regression", "content": "Quantile Regression The script is inspired by this awesome example in sklearn: https://scikit-learn.org/stable/auto_examples/ensemble/plot_gradient_boosting_quantile.html import argparse from typing import Dict import numpy as np from sklearn.model_selection import train_test_split import xgboost as xgb def f(x: np.ndarray) -> np.ndarray: \"\"\"The function to predict.\"\"\" return x * np.sin(x) def quantile_loss(args: argparse.Namespace) -> None: \"\"\"Train a quantile regression model.\"\"\" rng = np.random.RandomState(1994) # Generate a synthetic dataset for demo, the generate process is from the sklearn # example. X = np.atleast_2d(rng.uniform(0, 10.0, size=1000)).T expected_y = f(X).ravel() sigma = 0.5 + X.ravel() / 10.0 noise = rng.lognormal(sigma=sigma) - np.exp(sigma**2.0 / 2.0) y = expected_y + noise # Train on 0.05 and 0.95 quantiles. The model is similar to multi-class and # multi-target models. alpha = np.array([0.05, 0.5, 0.95]) evals_result: Dict[str, Dict] = {} X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=rng) # We will be using the `hist` tree method, quantile DMatrix can be used to preserve # memory (which has nothing to do with quantile regression itself, see its document # for details). # Do not use the `exact` tree method for quantile regression, otherwise the # performance might drop. Xy = xgb.QuantileDMatrix(X_train, y_train) # use Xy as a reference Xy_test = xgb.QuantileDMatrix(X_test, y_test, ref=Xy) booster = xgb.train( { # Use the quantile objective function. \"objective\": \"reg:quantileerror\", \"tree_method\": \"hist\", \"quantile_alpha\": alpha, # Let's try not to overfit. \"learning_rate\": 0.04, \"max_depth\": 5, }, Xy, num_boost_round=32, early_stopping_rounds=2, # The evaluation result is a weighted average across multiple quantiles. evals=[(Xy, \"Train\"), (Xy_test, \"Test\")], evals_result=evals_result, ) xx = np.atleast_2d(np.linspace(0, 10, 1000)).T scores = booster.inplace_predict(xx) # dim 1 is the quantiles assert scores.shape[0] == xx.shape[0] assert scores.shape[1] == alpha.shape[0] y_lower = scores[:, 0] # alpha=0.05 y_med = scores[:, 1] # alpha=0.5, median y_upper = scores[:, 2] # alpha=0.95 # Train a mse model for comparison booster = xgb.train( { \"objective\":", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_154", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/quantile_regression.html", "title": "Quantile Regression", "page_title": "Quantile Regression — xgboost 3.0.4 documentation", "breadcrumbs": "Quantile Regression", "content": "\"reg:squarederror\", \"tree_method\": \"hist\", # Let's try not to overfit. \"learning_rate\": 0.04, \"max_depth\": 5, }, Xy, num_boost_round=32, early_stopping_rounds=2, evals=[(Xy, \"Train\"), (Xy_test, \"Test\")], evals_result=evals_result, ) xx = np.atleast_2d(np.linspace(0, 10, 1000)).T y_pred = booster.inplace_predict(xx) if args.plot: from matplotlib import pyplot as plt fig = plt.figure(figsize=(10, 10)) plt.plot(xx, f(xx), \"g:\", linewidth=3, label=r\"$f(x) = x\\,\\sin(x)$\") plt.plot(X_test, y_test, \"b.\", markersize=10, label=\"Test observations\") plt.plot(xx, y_med, \"r-\", label=\"Predicted median\") plt.plot(xx, y_pred, \"m-\", label=\"Predicted mean\") plt.plot(xx, y_upper, \"k-\") plt.plot(xx, y_lower, \"k-\") plt.fill_between( xx.ravel(), y_lower, y_upper, alpha=0.4, label=\"Predicted 90% interval\" ) plt.xlabel(\"$x$\") plt.ylabel(\"$f(x)$\") plt.ylim(-10, 25) plt.legend(loc=\"upper left\") plt.show() if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument( \"--plot\", action=\"store_true\", help=\"Specify it to enable plotting the outputs.\", ) args = parser.parse_args() quantile_loss(args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_153", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_155", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/rmm_mgpu_with_dask.html", "title": "Using rmm with Dask", "page_title": "Using rmm with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Using rmm with Dask", "content": "Using rmm with Dask import dask from dask.distributed import Client from dask_cuda import LocalCUDACluster from sklearn.datasets import make_classification import xgboost as xgb def main(client): # Optionally force XGBoost to use RMM for all GPU memory allocation, see ./README.md # xgb.set_config(use_rmm=True) X, y = make_classification(n_samples=10000, n_informative=5, n_classes=3) # In pratice one should prefer loading the data with dask collections instead of # using `from_array`. X = dask.array.from_array(X) y = dask.array.from_array(y) dtrain = xgb.dask.DaskDMatrix(client, X, label=y) params = { \"max_depth\": 8, \"eta\": 0.01, \"objective\": \"multi:softprob\", \"num_class\": 3, \"tree_method\": \"hist\", \"eval_metric\": \"merror\", \"device\": \"cuda\", } output = xgb.dask.train( client, params, dtrain, num_boost_round=100, evals=[(dtrain, \"train\")] ) bst = output[\"booster\"] history = output[\"history\"] for i, e in enumerate(history[\"train\"][\"merror\"]): print(f\"[{i}] train-merror: {e}\") if __name__ == \"__main__\": # To use RMM pool allocator with a GPU Dask cluster, just add rmm_pool_size option # to LocalCUDACluster constructor. with LocalCUDACluster(rmm_pool_size=\"2GB\") as cluster: with Client(cluster) as client: main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_156", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/model_parser.html", "title": "Demonstration for parsing JSON/UBJSON tree model files", "page_title": "Demonstration for parsing JSON/UBJSON tree model files — xgboost 3.0.4 documentation", "breadcrumbs": "Demonstration for parsing JSON/UBJSON tree model files", "content": "Demonstration for parsing JSON/UBJSON tree model files See Introduction to Model IO for details about the model serialization. import argparse import json from dataclasses import dataclass from enum import IntEnum, unique from typing import Any, Dict, List, Sequence, Union import numpy as np try: import ubjson except ImportError: ubjson = None ParamT = Dict[str, str] def to_integers(data: Union[bytes, List[int]]) -> List[int]: \"\"\"Convert a sequence of bytes to a list of Python integer\"\"\" return [v for v in data] @unique class SplitType(IntEnum): numerical = 0 categorical = 1 @dataclass class Node: # properties left: int right: int parent: int split_idx: int split_cond: float default_left: bool split_type: SplitType categories: List[int] # statistic base_weight: float loss_chg: float sum_hess: float class Tree: \"\"\"A tree built by XGBoost.\"\"\" def __init__(self, tree_id: int, nodes: Sequence[Node]) -> None: self.tree_id = tree_id self.nodes = nodes def loss_change(self, node_id: int) -> float: \"\"\"Loss gain of a node.\"\"\" return self.nodes[node_id].loss_chg def sum_hessian(self, node_id: int) -> float: \"\"\"Sum Hessian of a node.\"\"\" return self.nodes[node_id].sum_hess def base_weight(self, node_id: int) -> float: \"\"\"Base weight of a node.\"\"\" return self.nodes[node_id].base_weight def split_index(self, node_id: int) -> int: \"\"\"Split feature index of node.\"\"\" return self.nodes[node_id].split_idx def split_condition(self, node_id: int) -> float: \"\"\"Split value of a node.\"\"\" return self.nodes[node_id].split_cond def split_categories(self, node_id: int) -> List[int]: \"\"\"Categories in a node.\"\"\" return self.nodes[node_id].categories def is_categorical(self, node_id: int) -> bool: \"\"\"Whether a node has categorical split.\"\"\" return self.nodes[node_id].split_type == SplitType.categorical def is_numerical(self, node_id: int) -> bool: return not self.is_categorical(node_id) def parent(self, node_id: int) -> int: \"\"\"Parent ID of a node.\"\"\" return self.nodes[node_id].parent def left_child(self, node_id: int) -> int: \"\"\"Left child ID of a node.\"\"\" return self.nodes[node_id].left def right_child(self, node_id: int) -> int: \"\"\"Right child ID of a node.\"\"\" return self.nodes[node_id].right def is_leaf(self, node_id: int) -> bool: \"\"\"Whether a node is leaf.\"\"\" return self.nodes[node_id].left == -1 def is_deleted(self, node_id: int) ->", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_157", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/model_parser.html", "title": "Demonstration for parsing JSON/UBJSON tree model files", "page_title": "Demonstration for parsing JSON/UBJSON tree model files — xgboost 3.0.4 documentation", "breadcrumbs": "Demonstration for parsing JSON/UBJSON tree model files", "content": "bool: \"\"\"Whether a node is deleted.\"\"\" return self.split_index(node_id) == np.iinfo(np.uint32).max def __str__(self) -> str: stack = [0] nodes = [] while stack: node: Dict[str, Union[float, int, List[int]]] = {} nid = stack.pop() node[\"node id\"] = nid node[\"gain\"] = self.loss_change(nid) node[\"cover\"] = self.sum_hessian(nid) nodes.append(node) if not self.is_leaf(nid) and not self.is_deleted(nid): left = self.left_child(nid) right = self.right_child(nid) stack.append(left) stack.append(right) categories = self.split_categories(nid) if categories: assert self.is_categorical(nid) node[\"categories\"] = categories else: assert self.is_numerical(nid) node[\"condition\"] = self.split_condition(nid) if self.is_leaf(nid): node[\"weight\"] = self.split_condition(nid) string = \"\\n\".join(map(lambda x: \" \" + str(x), nodes)) return string class Model: \"\"\"Gradient boosted tree model.\"\"\" def __init__(self, model: dict) -> None: \"\"\"Construct the Model from a JSON object. parameters ---------- model : A dictionary loaded by json representing a XGBoost boosted tree model. \"\"\" # Basic properties of a model self.learner_model_shape: ParamT = model[\"learner\"][\"learner_model_param\"] self.num_output_group = int(self.learner_model_shape[\"num_class\"]) self.num_feature = int(self.learner_model_shape[\"num_feature\"]) self.base_score = float(self.learner_model_shape[\"base_score\"]) # A field encoding which output group a tree belongs self.tree_info = model[\"learner\"][\"gradient_booster\"][\"model\"][\"tree_info\"] model_shape: ParamT = model[\"learner\"][\"gradient_booster\"][\"model\"][ \"gbtree_model_param\" ] # JSON representation of trees j_trees = model[\"learner\"][\"gradient_booster\"][\"model\"][\"trees\"] # Load the trees self.num_trees = int(model_shape[\"num_trees\"]) trees: List[Tree] = [] for i in range(self.num_trees): tree: Dict[str, Any] = j_trees[i] tree_id = int(tree[\"id\"]) assert tree_id == i, (tree_id, i) # - properties left_children: List[int] = tree[\"left_children\"] right_children: List[int] = tree[\"right_children\"] parents: List[int] = tree[\"parents\"] split_conditions: List[float] = tree[\"split_conditions\"] split_indices: List[int] = tree[\"split_indices\"] # when ubjson is used, this is a byte array with each element as uint8 default_left = to_integers(tree[\"default_left\"]) # - categorical features # when ubjson is used, this is a byte array with each element as uint8 split_types = to_integers(tree[\"split_type\"]) # categories for each node is stored in a CSR style storage with segment as # the begin ptr and the `categories' as values. cat_segments: List[int] = tree[\"categories_segments\"] cat_sizes: List[int] = tree[\"categories_sizes\"] # node index for categorical nodes", "prev_chunk_id": "chunk_156", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_158", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/model_parser.html", "title": "Demonstration for parsing JSON/UBJSON tree model files", "page_title": "Demonstration for parsing JSON/UBJSON tree model files — xgboost 3.0.4 documentation", "breadcrumbs": "Demonstration for parsing JSON/UBJSON tree model files", "content": "cat_nodes: List[int] = tree[\"categories_nodes\"] assert len(cat_segments) == len(cat_sizes) == len(cat_nodes) cats = tree[\"categories\"] assert len(left_children) == len(split_types) # The storage for categories is only defined for categorical nodes to # prevent unnecessary overhead for numerical splits, we track the # categorical node that are processed using a counter. cat_cnt = 0 if cat_nodes: last_cat_node = cat_nodes[cat_cnt] else: last_cat_node = -1 node_categories: List[List[int]] = [] for node_id in range(len(left_children)): if node_id == last_cat_node: beg = cat_segments[cat_cnt] size = cat_sizes[cat_cnt] end = beg + size node_cats = cats[beg:end] # categories are unique for each node assert len(set(node_cats)) == len(node_cats) cat_cnt += 1 if cat_cnt == len(cat_nodes): last_cat_node = -1 # continue to process the rest of the nodes else: last_cat_node = cat_nodes[cat_cnt] assert node_cats node_categories.append(node_cats) else: # append an empty node, it's either a numerical node or a leaf. node_categories.append([]) # - stats base_weights: List[float] = tree[\"base_weights\"] loss_changes: List[float] = tree[\"loss_changes\"] sum_hessian: List[float] = tree[\"sum_hessian\"] # Construct a list of nodes that have complete information nodes: List[Node] = [ Node( left_children[node_id], right_children[node_id], parents[node_id], split_indices[node_id], split_conditions[node_id], default_left[node_id] == 1, # to boolean SplitType(split_types[node_id]), node_categories[node_id], base_weights[node_id], loss_changes[node_id], sum_hessian[node_id], ) for node_id in range(len(left_children)) ] pytree = Tree(tree_id, nodes) trees.append(pytree) self.trees = trees def print_model(self) -> None: for i, tree in enumerate(self.trees): print(\"\\ntree_id:\", i) print(tree) if __name__ == \"__main__\": parser = argparse.ArgumentParser( description=\"Demonstration for loading XGBoost JSON/UBJSON model.\" ) parser.add_argument( \"--model\", type=str, required=True, help=\"Path to .json/.ubj model file.\" ) args = parser.parse_args() if args.model.endswith(\"json\"): # use json format with open(args.model, \"r\") as fd: model = json.load(fd) elif args.model.endswith(\"ubj\"): if ubjson is None: raise ImportError(\"ubjson is not installed.\") # use ubjson format with open(args.model, \"rb\") as bfd: model = ubjson.load(bfd) else: raise ValueError( \"Unexpected file extension. Supported file extension are json and ubj.\" ) model = Model(model) model.print_model() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_157", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_159", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/distributed_extmem_basic.html", "title": "Experimental support for distributed training with external memory", "page_title": "Experimental support for distributed training with external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for distributed training with external memory", "content": "Experimental support for distributed training with external memory See the tutorial for more details. To run the example, following packages in addition to XGBoost native dependencies are required: - scikit-learn - loky If device is cuda, following are also needed: - cupy - python-cuda - rmm import argparse import multiprocessing as mp import os import sys import tempfile import traceback from functools import partial, update_wrapper, wraps from typing import Callable, List, ParamSpec, Tuple, TypeVar import numpy as np from loky import get_reusable_executor from sklearn.datasets import make_regression import xgboost from xgboost import collective as coll from xgboost.tracker import RabitTracker def make_batches( n_samples_per_batch: int, n_features: int, n_batches: int, tmpdir: str, rank: int ) -> List[Tuple[str, str]]: files: List[Tuple[str, str]] = [] rng = np.random.RandomState(rank) for i in range(n_batches): X, y = make_regression(n_samples_per_batch, n_features, random_state=rng) X_path = os.path.join(tmpdir, f\"X-r{rank}-{i}.npy\") y_path = os.path.join(tmpdir, f\"y-r{rank}-{i}.npy\") np.save(X_path, X) np.save(y_path, y) files.append((X_path, y_path)) return files class Iterator(xgboost.DataIter): \"\"\"A custom iterator for loading files in batches.\"\"\" def __init__(self, device: str, file_paths: List[Tuple[str, str]]) -> None: self.device = device self._file_paths = file_paths self._it = 0 # XGBoost will generate some cache files under the current directory with the # prefix \"cache\" super().__init__(cache_prefix=os.path.join(\".\", \"cache\")) def load_file(self) -> Tuple[np.ndarray, np.ndarray]: \"\"\"Load a single batch of data.\"\"\" X_path, y_path = self._file_paths[self._it] # When the `ExtMemQuantileDMatrix` is used, the device must match. GPU cannot # consume CPU input data and vice-versa. if self.device == \"cpu\": X = np.load(X_path) y = np.load(y_path) else: X = cp.load(X_path) y = cp.load(y_path) assert X.shape[0] == y.shape[0] return X, y def next(self, input_data: Callable) -> bool: \"\"\"Advance the iterator by 1 step and pass the data to XGBoost. This function is called by XGBoost during the construction of ``DMatrix`` \"\"\" if self._it == len(self._file_paths): # return False to let XGBoost know this is the end of iteration return", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_160", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/distributed_extmem_basic.html", "title": "Experimental support for distributed training with external memory", "page_title": "Experimental support for distributed training with external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for distributed training with external memory", "content": "False # input_data is a keyword-only function passed in by XGBoost and has the similar # signature to the ``DMatrix`` constructor. X, y = self.load_file() input_data(data=X, label=y) self._it += 1 return True def reset(self) -> None: \"\"\"Reset the iterator to its beginning\"\"\" self._it = 0 def setup_rmm() -> None: \"\"\"Setup RMM for GPU-based external memory training. It's important to use RMM with `CudaAsyncMemoryResource` or `ArenaMemoryResource` for GPU-based external memory to improve performance. If XGBoost is not built with RMM support, a warning is raised when constructing the `DMatrix`. \"\"\" import rmm from cuda import cudart from rmm.allocators.cupy import rmm_cupy_allocator from rmm.mr import ArenaMemoryResource if not xgboost.build_info()[\"USE_RMM\"]: return status, free, total = cudart.cudaMemGetInfo() if status != cudart.cudaError_t.cudaSuccess: raise RuntimeError(cudart.cudaGetErrorString(status)) mr = rmm.mr.CudaMemoryResource() mr = ArenaMemoryResource(mr, arena_size=int(total * 0.9)) rmm.mr.set_current_device_resource(mr) # Set the allocator for cupy as well. cp.cuda.set_allocator(rmm_cupy_allocator) R = TypeVar(\"R\") P = ParamSpec(\"P\") def try_run(fn: Callable[P, R]) -> Callable[P, R]: \"\"\"Loky aborts the process without printing out any error message if there's an exception. \"\"\" @wraps(fn) def inner(*args: P.args, **kwargs: P.kwargs) -> R: try: return fn(*args, **kwargs) except Exception as e: print(traceback.format_exc(), file=sys.stderr) raise RuntimeError(\"Running into exception in worker.\") from e return inner @try_run def hist_train(worker_idx: int, tmpdir: str, device: str, rabit_args: dict) -> None: \"\"\"The hist tree method can use a special data structure `ExtMemQuantileDMatrix` for faster initialization and lower memory usage. \"\"\" # Make sure XGBoost is using RMM for all allocations. with coll.CommunicatorContext(**rabit_args), xgboost.config_context(use_rmm=True): # Generate the data for demonstration. The sythetic data is sharded by workers. files = make_batches( n_samples_per_batch=4096, n_features=16, n_batches=17, tmpdir=tmpdir, rank=coll.get_rank(), ) # Since we are running two workers on a single node, we should divide the number # of threads between workers. n_threads = os.cpu_count() assert n_threads is not None n_threads = max(n_threads // coll.get_world_size(), 1) it = Iterator(device, files) Xy =", "prev_chunk_id": "chunk_159", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_161", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/distributed_extmem_basic.html", "title": "Experimental support for distributed training with external memory", "page_title": "Experimental support for distributed training with external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for distributed training with external memory", "content": "xgboost.ExtMemQuantileDMatrix( it, missing=np.nan, enable_categorical=False, nthread=n_threads ) # Check the device is correctly set. if device == \"cuda\": # Check the first device assert ( int(os.environ[\"CUDA_VISIBLE_DEVICES\"].split(\",\")[0]) < coll.get_world_size() ) booster = xgboost.train( { \"tree_method\": \"hist\", \"max_depth\": 4, \"device\": it.device, \"nthread\": n_threads, }, Xy, evals=[(Xy, \"Train\")], num_boost_round=10, ) booster.predict(Xy) def main(tmpdir: str, args: argparse.Namespace) -> None: n_workers = 2 tracker = RabitTracker(host_ip=\"127.0.0.1\", n_workers=n_workers) tracker.start() rabit_args = tracker.worker_args() def initializer(device: str) -> None: # Set CUDA device before launching child processes. if device == \"cuda\": # name: LokyProcess-1 lop, sidx = mp.current_process().name.split(\"-\") idx = int(sidx) - 1 # 1-based indexing from loky # Assuming two workers for demo. devices = \",\".join([str(idx), str((idx + 1) % n_workers)]) # P0: CUDA_VISIBLE_DEVICES=0,1 # P1: CUDA_VISIBLE_DEVICES=1,0 os.environ[\"CUDA_VISIBLE_DEVICES\"] = devices setup_rmm() with get_reusable_executor( max_workers=n_workers, initargs=(args.device,), initializer=initializer ) as pool: # Poor man's currying fn = update_wrapper( partial( hist_train, tmpdir=tmpdir, device=args.device, rabit_args=rabit_args ), hist_train, ) pool.map(fn, range(n_workers)) if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--device\", choices=[\"cpu\", \"cuda\"], default=\"cpu\") args = parser.parse_args() if args.device == \"cuda\": import cupy as cp with tempfile.TemporaryDirectory() as tmpdir: main(tmpdir, args) else: with tempfile.TemporaryDirectory() as tmpdir: main(tmpdir, args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_160", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_162", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/rmm_singlegpu.html", "title": "Using rmm on a single node device", "page_title": "Using rmm on a single node device — xgboost 3.0.4 documentation", "breadcrumbs": "Using rmm on a single node device", "content": "Using rmm on a single node device import rmm from sklearn.datasets import make_classification import xgboost as xgb # Initialize RMM pool allocator rmm.reinitialize(pool_allocator=True) # Optionally force XGBoost to use RMM for all GPU memory allocation, see ./README.md # xgb.set_config(use_rmm=True) X, y = make_classification(n_samples=10000, n_informative=5, n_classes=3) dtrain = xgb.DMatrix(X, label=y) params = { \"max_depth\": 8, \"eta\": 0.01, \"objective\": \"multi:softprob\", \"num_class\": 3, \"tree_method\": \"hist\", \"device\": \"cuda\", } # XGBoost will automatically use the RMM pool allocator bst = xgb.train(params, dtrain, num_boost_round=100, evals=[(dtrain, \"train\")]) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_163", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_rmsle.html", "title": "Demo for defining a custom regression objective and metric", "page_title": "Demo for defining a custom regression objective and metric — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for defining a custom regression objective and metric", "content": "Demo for defining a custom regression objective and metric Demo for defining customized metric and objective. Notice that for simplicity reason weight is not used in following example. In this script, we implement the Squared Log Error (SLE) objective and RMSLE metric as customized functions, then compare it with native implementation in XGBoost. See Custom Objective and Evaluation Metric for a step by step walkthrough, with other details. The SLE objective reduces impact of outliers in training dataset, hence here we also compare its performance with standard squared error. import argparse from time import time from typing import Dict, List, Tuple import matplotlib import numpy as np from matplotlib import pyplot as plt import xgboost as xgb # shape of generated data. kRows = 4096 kCols = 16 kOutlier = 10000 # mean of generated outliers kNumberOfOutliers = 64 kRatio = 0.7 kSeed = 1994 kBoostRound = 20 np.random.seed(seed=kSeed) def generate_data() -> Tuple[xgb.DMatrix, xgb.DMatrix]: '''Generate data containing outliers.''' x = np.random.randn(kRows, kCols) y = np.random.randn(kRows) y += np.abs(np.min(y)) # Create outliers for i in range(0, kNumberOfOutliers): ind = np.random.randint(0, len(y)-1) y[ind] += np.random.randint(0, kOutlier) train_portion = int(kRows * kRatio) # rmsle requires all label be greater than -1. assert np.all(y > -1.0) train_x: np.ndarray = x[: train_portion] train_y: np.ndarray = y[: train_portion] dtrain = xgb.DMatrix(train_x, label=train_y) test_x = x[train_portion:] test_y = y[train_portion:] dtest = xgb.DMatrix(test_x, label=test_y) return dtrain, dtest def native_rmse(dtrain: xgb.DMatrix, dtest: xgb.DMatrix) -> Dict[str, Dict[str, List[float]]]: '''Train using native implementation of Root Mean Squared Loss.''' print('Squared Error') squared_error = { 'objective': 'reg:squarederror', 'eval_metric': 'rmse', 'tree_method': 'hist', 'seed': kSeed } start = time() results: Dict[str, Dict[str, List[float]]] = {} xgb.train(squared_error, dtrain=dtrain, num_boost_round=kBoostRound, evals=[(dtrain, 'dtrain'), (dtest, 'dtest')], evals_result=results) print('Finished Squared Error in:', time() - start, '\\n') return results def native_rmsle(dtrain: xgb.DMatrix, dtest: xgb.DMatrix) -> Dict[str, Dict[str, List[float]]]: '''Train using native", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_164", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_rmsle.html", "title": "Demo for defining a custom regression objective and metric", "page_title": "Demo for defining a custom regression objective and metric — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for defining a custom regression objective and metric", "content": "implementation of Squared Log Error.''' print('Squared Log Error') results: Dict[str, Dict[str, List[float]]] = {} squared_log_error = { 'objective': 'reg:squaredlogerror', 'eval_metric': 'rmsle', 'tree_method': 'hist', 'seed': kSeed } start = time() xgb.train(squared_log_error, dtrain=dtrain, num_boost_round=kBoostRound, evals=[(dtrain, 'dtrain'), (dtest, 'dtest')], evals_result=results) print('Finished Squared Log Error in:', time() - start) return results def py_rmsle(dtrain: xgb.DMatrix, dtest: xgb.DMatrix) -> Dict: '''Train using Python implementation of Squared Log Error.''' def gradient(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: '''Compute the gradient squared log error.''' y = dtrain.get_label() return (np.log1p(predt) - np.log1p(y)) / (predt + 1) def hessian(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: '''Compute the hessian for squared log error.''' y = dtrain.get_label() return ((-np.log1p(predt) + np.log1p(y) + 1) / np.power(predt + 1, 2)) def squared_log(predt: np.ndarray, dtrain: xgb.DMatrix) -> Tuple[np.ndarray, np.ndarray]: '''Squared Log Error objective. A simplified version for RMSLE used as objective function. :math:`\\frac{1}{2}[log(pred + 1) - log(label + 1)]^2` ''' predt[predt < -1] = -1 + 1e-6 grad = gradient(predt, dtrain) hess = hessian(predt, dtrain) return grad, hess def rmsle(predt: np.ndarray, dtrain: xgb.DMatrix) -> Tuple[str, float]: ''' Root mean squared log error metric. :math:`\\sqrt{\\frac{1}{N}[log(pred + 1) - log(label + 1)]^2}` ''' y = dtrain.get_label() predt[predt < -1] = -1 + 1e-6 elements = np.power(np.log1p(y) - np.log1p(predt), 2) return 'PyRMSLE', float(np.sqrt(np.sum(elements) / len(y))) results: Dict[str, Dict[str, List[float]]] = {} xgb.train({'tree_method': 'hist', 'seed': kSeed, 'disable_default_eval_metric': 1}, dtrain=dtrain, num_boost_round=kBoostRound, obj=squared_log, custom_metric=rmsle, evals=[(dtrain, 'dtrain'), (dtest, 'dtest')], evals_result=results) return results def plot_history(rmse_evals, rmsle_evals, py_rmsle_evals): fig, axs = plt.subplots(3, 1) ax0: matplotlib.axes.Axes = axs[0] ax1: matplotlib.axes.Axes = axs[1] ax2: matplotlib.axes.Axes = axs[2] x = np.arange(0, kBoostRound, 1) ax0.plot(x, rmse_evals['dtrain']['rmse'], label='train-RMSE') ax0.plot(x, rmse_evals['dtest']['rmse'], label='test-RMSE') ax0.legend() ax1.plot(x, rmsle_evals['dtrain']['rmsle'], label='train-native-RMSLE') ax1.plot(x, rmsle_evals['dtest']['rmsle'], label='test-native-RMSLE') ax1.legend() ax2.plot(x, py_rmsle_evals['dtrain']['PyRMSLE'], label='train-PyRMSLE') ax2.plot(x, py_rmsle_evals['dtest']['PyRMSLE'], label='test-PyRMSLE') ax2.legend() def main(args): dtrain, dtest = generate_data() rmse_evals = native_rmse(dtrain, dtest) rmsle_evals = native_rmsle(dtrain, dtest) py_rmsle_evals = py_rmsle(dtrain, dtest) if args.plot != 0: plot_history(rmse_evals, rmsle_evals, py_rmsle_evals)", "prev_chunk_id": "chunk_163", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_165", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_rmsle.html", "title": "Demo for defining a custom regression objective and metric", "page_title": "Demo for defining a custom regression objective and metric — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for defining a custom regression objective and metric", "content": "plt.show() if __name__ == \"__main__\": parser = argparse.ArgumentParser( description='Arguments for custom RMSLE objective function demo.') parser.add_argument( '--plot', type=int, default=1, help='Set to 0 to disable plotting the evaluation history.') args = parser.parse_args() main(args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_164", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_166", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/learning_to_rank.html", "title": "Getting started with learning to rank", "page_title": "Getting started with learning to rank — xgboost 3.0.4 documentation", "breadcrumbs": "Getting started with learning to rank", "content": "Getting started with learning to rank This is a demonstration of using XGBoost for learning to rank tasks using the MSLR_10k_letor dataset. For more infomation about the dataset, please visit its description page. This is a two-part demo, the first one contains a basic example of using XGBoost to train on relevance degree, and the second part simulates click data and enable the position debiasing training. For an overview of learning to rank in XGBoost, please see Learning to Rank. from __future__ import annotations import argparse import json import os import pickle as pkl import numpy as np import pandas as pd from sklearn.datasets import load_svmlight_file import xgboost as xgb from xgboost.testing.data import RelDataCV, simulate_clicks, sort_ltr_samples def load_mslr_10k(data_path: str, cache_path: str) -> RelDataCV: \"\"\"Load the MSLR10k dataset from data_path and cache a pickle object in cache_path. Returns ------- A list of tuples [(X, y, qid), ...]. \"\"\" root_path = os.path.expanduser(args.data) cacheroot_path = os.path.expanduser(args.cache) cache_path = os.path.join(cacheroot_path, \"MSLR_10K_LETOR.pkl\") # Use only the Fold1 for demo: # Train, Valid, Test # {S1,S2,S3}, S4, S5 fold = 1 if not os.path.exists(cache_path): fold_path = os.path.join(root_path, f\"Fold{fold}\") train_path = os.path.join(fold_path, \"train.txt\") valid_path = os.path.join(fold_path, \"vali.txt\") test_path = os.path.join(fold_path, \"test.txt\") X_train, y_train, qid_train = load_svmlight_file( train_path, query_id=True, dtype=np.float32 ) y_train = y_train.astype(np.int32) qid_train = qid_train.astype(np.int32) X_valid, y_valid, qid_valid = load_svmlight_file( valid_path, query_id=True, dtype=np.float32 ) y_valid = y_valid.astype(np.int32) qid_valid = qid_valid.astype(np.int32) X_test, y_test, qid_test = load_svmlight_file( test_path, query_id=True, dtype=np.float32 ) y_test = y_test.astype(np.int32) qid_test = qid_test.astype(np.int32) data = RelDataCV( train=(X_train, y_train, qid_train), test=(X_test, y_test, qid_test), max_rel=4, ) with open(cache_path, \"wb\") as fd: pkl.dump(data, fd) with open(cache_path, \"rb\") as fd: data = pkl.load(fd) return data def ranking_demo(args: argparse.Namespace) -> None: \"\"\"Demonstration for learning to rank with relevance degree.\"\"\" data = load_mslr_10k(args.data, args.cache) # Sort data according to query index X_train, y_train, qid_train = data.train sorted_idx = np.argsort(qid_train) X_train", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_167", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/learning_to_rank.html", "title": "Getting started with learning to rank", "page_title": "Getting started with learning to rank — xgboost 3.0.4 documentation", "breadcrumbs": "Getting started with learning to rank", "content": "= X_train[sorted_idx] y_train = y_train[sorted_idx] qid_train = qid_train[sorted_idx] X_test, y_test, qid_test = data.test sorted_idx = np.argsort(qid_test) X_test = X_test[sorted_idx] y_test = y_test[sorted_idx] qid_test = qid_test[sorted_idx] ranker = xgb.XGBRanker( tree_method=\"hist\", device=\"cuda\", lambdarank_pair_method=\"topk\", lambdarank_num_pair_per_sample=13, eval_metric=[\"ndcg@1\", \"ndcg@8\"], ) ranker.fit( X_train, y_train, qid=qid_train, eval_set=[(X_test, y_test)], eval_qid=[qid_test], verbose=True, ) def click_data_demo(args: argparse.Namespace) -> None: \"\"\"Demonstration for learning to rank with click data.\"\"\" data = load_mslr_10k(args.data, args.cache) train, test = simulate_clicks(data) assert test is not None assert train.X.shape[0] == train.click.size assert test.X.shape[0] == test.click.size assert test.score.dtype == np.float32 assert test.click.dtype == np.int32 X_train, clicks_train, y_train, qid_train = sort_ltr_samples( train.X, train.y, train.qid, train.click, train.pos, ) X_test, clicks_test, y_test, qid_test = sort_ltr_samples( test.X, test.y, test.qid, test.click, test.pos, ) class ShowPosition(xgb.callback.TrainingCallback): def after_iteration( self, model: xgb.Booster, epoch: int, evals_log: xgb.callback.TrainingCallback.EvalsLog, ) -> bool: config = json.loads(model.save_config()) ti_plus = np.array(config[\"learner\"][\"objective\"][\"ti+\"]) tj_minus = np.array(config[\"learner\"][\"objective\"][\"tj-\"]) df = pd.DataFrame({\"ti+\": ti_plus, \"tj-\": tj_minus}) print(df) return False ranker = xgb.XGBRanker( n_estimators=512, tree_method=\"hist\", device=\"cuda\", learning_rate=0.01, reg_lambda=1.5, subsample=0.8, sampling_method=\"gradient_based\", # LTR specific parameters objective=\"rank:ndcg\", # - Enable bias estimation lambdarank_unbiased=True, # - normalization (1 / (norm + 1)) lambdarank_bias_norm=1, # - Focus on the top 12 documents lambdarank_num_pair_per_sample=12, lambdarank_pair_method=\"topk\", ndcg_exp_gain=True, eval_metric=[\"ndcg@1\", \"ndcg@3\", \"ndcg@5\", \"ndcg@10\"], callbacks=[ShowPosition()], ) ranker.fit( X_train, clicks_train, qid=qid_train, eval_set=[(X_test, y_test), (X_test, clicks_test)], eval_qid=[qid_test, qid_test], verbose=True, ) ranker.predict(X_test) if __name__ == \"__main__\": parser = argparse.ArgumentParser( description=\"Demonstration of learning to rank using XGBoost.\" ) parser.add_argument( \"--data\", type=str, help=\"Root directory of the MSLR-WEB10K data.\", required=True, ) parser.add_argument( \"--cache\", type=str, help=\"Directory for caching processed data.\", required=True, ) args = parser.parse_args() ranking_demo(args) click_data_demo(args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_166", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_168", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_softmax.html", "title": "Demo for creating customized multi-class objective function", "page_title": "Demo for creating customized multi-class objective function — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for creating customized multi-class objective function", "content": "Demo for creating customized multi-class objective function This demo is only applicable after (excluding) XGBoost 1.0.0, as before this version XGBoost returns transformed prediction for multi-class objective function. More details in comments. See Custom Objective and Evaluation Metric and Advanced Usage of Custom Objectives for detailed tutorial and notes. import argparse import numpy as np from matplotlib import pyplot as plt import xgboost as xgb np.random.seed(1994) kRows = 100 kCols = 10 kClasses = 4 # number of classes kRounds = 10 # number of boosting rounds. # Generate some random data for demo. X = np.random.randn(kRows, kCols) y = np.random.randint(0, 4, size=kRows) m = xgb.DMatrix(X, y) def softmax(x): '''Softmax function with x as input vector.''' e = np.exp(x) return e / np.sum(e) def softprob_obj(predt: np.ndarray, data: xgb.DMatrix): '''Loss function. Computing the gradient and upper bound on the Hessian with a diagonal structure for XGBoost (note that this is not the true Hessian). Reimplements the `multi:softprob` inside XGBoost. ''' labels = data.get_label() if data.get_weight().size == 0: # Use 1 as weight if we don't have custom weight. weights = np.ones((kRows, 1), dtype=float) else: weights = data.get_weight() # The prediction is of shape (rows, classes), each element in a row # represents a raw prediction (leaf weight, hasn't gone through softmax # yet). In XGBoost 1.0.0, the prediction is transformed by a softmax # function, fixed in later versions. assert predt.shape == (kRows, kClasses) grad = np.zeros((kRows, kClasses), dtype=float) hess = np.zeros((kRows, kClasses), dtype=float) eps = 1e-6 # compute the gradient and hessian upper bound, slow iterations in Python, only # suitable for demo. Also the one in native XGBoost core is more robust to # numeric overflow as we don't do anything to mitigate the `exp` in # `softmax` here. for r in range(predt.shape[0]): target = labels[r] p = softmax(predt[r,", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_169", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_softmax.html", "title": "Demo for creating customized multi-class objective function", "page_title": "Demo for creating customized multi-class objective function — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for creating customized multi-class objective function", "content": ":]) for c in range(predt.shape[1]): assert target >= 0 or target <= kClasses g = p[c] - 1.0 if c == target else p[c] g = g * weights[r] h = max((2.0 * p[c] * (1.0 - p[c]) * weights[r]).item(), eps) grad[r, c] = g hess[r, c] = h # After 2.1.0, pass the gradient as it is. return grad, hess def predict(booster: xgb.Booster, X): '''A customized prediction function that converts raw prediction to target class. ''' # Output margin means we want to obtain the raw prediction obtained from # tree leaf weight. predt = booster.predict(X, output_margin=True) out = np.zeros(kRows) for r in range(predt.shape[0]): # the class with maximum prob (not strictly prob as it haven't gone # through softmax yet so it doesn't sum to 1, but result is the same # for argmax). i = np.argmax(predt[r]) out[r] = i return out def merror(predt: np.ndarray, dtrain: xgb.DMatrix): y = dtrain.get_label() # Like custom objective, the predt is untransformed leaf weight when custom objective # is provided. # With the use of `custom_metric` parameter in train function, custom metric receives # raw input only when custom objective is also being used. Otherwise custom metric # will receive transformed prediction. assert predt.shape == (kRows, kClasses) out = np.zeros(kRows) for r in range(predt.shape[0]): i = np.argmax(predt[r]) out[r] = i assert y.shape == out.shape errors = np.zeros(kRows) errors[y != out] = 1.0 return 'PyMError', np.sum(errors) / kRows def plot_history(custom_results, native_results): fig, axs = plt.subplots(2, 1) ax0 = axs[0] ax1 = axs[1] pymerror = custom_results['train']['PyMError'] merror = native_results['train']['merror'] x = np.arange(0, kRounds, 1) ax0.plot(x, pymerror, label='Custom objective') ax0.legend() ax1.plot(x, merror, label='multi:softmax') ax1.legend() plt.show() def main(args): custom_results = {} # Use our custom objective function booster_custom = xgb.train({'num_class': kClasses, 'disable_default_eval_metric': True}, m, num_boost_round=kRounds, obj=softprob_obj, custom_metric=merror, evals_result=custom_results, evals=[(m, 'train')]) predt_custom = predict(booster_custom, m) native_results =", "prev_chunk_id": "chunk_168", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_170", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/custom_softmax.html", "title": "Demo for creating customized multi-class objective function", "page_title": "Demo for creating customized multi-class objective function — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for creating customized multi-class objective function", "content": "{} # Use the same objective function defined in XGBoost. booster_native = xgb.train({'num_class': kClasses, \"objective\": \"multi:softmax\", 'eval_metric': 'merror'}, m, num_boost_round=kRounds, evals_result=native_results, evals=[(m, 'train')]) predt_native = booster_native.predict(m) # We are reimplementing the loss function in XGBoost, so it should # be the same for normal cases. assert np.all(predt_custom == predt_native) np.testing.assert_allclose(custom_results['train']['PyMError'], native_results['train']['merror']) if args.plot != 0: plot_history(custom_results, native_results) if __name__ == '__main__': parser = argparse.ArgumentParser( description='Arguments for custom softmax objective function demo.') parser.add_argument( '--plot', type=int, default=1, help='Set to 0 to disable plotting the evaluation history.') args = parser.parse_args() main(args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_169", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_171", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/external_memory.html", "title": "Experimental support for external memory", "page_title": "Experimental support for external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for external memory", "content": "Experimental support for external memory This is similar to the one in quantile_data_iterator.py, but for external memory instead of Quantile DMatrix. The feature is not ready for production use yet. See the tutorial for more details. To run the example, following packages in addition to XGBoost native dependencies are required: - scikit-learn If device is cuda, following are also needed: - cupy - rmm - python-cuda import argparse import os import tempfile from typing import Callable, List, Tuple import numpy as np from sklearn.datasets import make_regression import xgboost def make_batches( n_samples_per_batch: int, n_features: int, n_batches: int, tmpdir: str, ) -> List[Tuple[str, str]]: files: List[Tuple[str, str]] = [] rng = np.random.RandomState(1994) for i in range(n_batches): X, y = make_regression(n_samples_per_batch, n_features, random_state=rng) X_path = os.path.join(tmpdir, \"X-\" + str(i) + \".npy\") y_path = os.path.join(tmpdir, \"y-\" + str(i) + \".npy\") np.save(X_path, X) np.save(y_path, y) files.append((X_path, y_path)) return files class Iterator(xgboost.DataIter): \"\"\"A custom iterator for loading files in batches.\"\"\" def __init__(self, device: str, file_paths: List[Tuple[str, str]]) -> None: self.device = device self._file_paths = file_paths self._it = 0 # XGBoost will generate some cache files under the current directory with the # prefix \"cache\" super().__init__(cache_prefix=os.path.join(\".\", \"cache\")) def load_file(self) -> Tuple[np.ndarray, np.ndarray]: \"\"\"Load a single batch of data.\"\"\" X_path, y_path = self._file_paths[self._it] # When the `ExtMemQuantileDMatrix` is used, the device must match. GPU cannot # consume CPU input data and vice-versa. if self.device == \"cpu\": X = np.load(X_path) y = np.load(y_path) else: X = cp.load(X_path) y = cp.load(y_path) assert X.shape[0] == y.shape[0] return X, y def next(self, input_data: Callable) -> bool: \"\"\"Advance the iterator by 1 step and pass the data to XGBoost. This function is called by XGBoost during the construction of ``DMatrix`` \"\"\" if self._it == len(self._file_paths): # return False to let XGBoost know this is the end of iteration return False # input_data is", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_172", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/external_memory.html", "title": "Experimental support for external memory", "page_title": "Experimental support for external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for external memory", "content": "a keyword-only function passed in by XGBoost and has the similar # signature to the ``DMatrix`` constructor. X, y = self.load_file() input_data(data=X, label=y) self._it += 1 return True def reset(self) -> None: \"\"\"Reset the iterator to its beginning\"\"\" self._it = 0 def hist_train(it: Iterator) -> None: \"\"\"The hist tree method can use a special data structure `ExtMemQuantileDMatrix` for faster initialization and lower memory usage. .. versionadded:: 3.0.0 \"\"\" # For non-data arguments, specify it here once instead of passing them by the `next` # method. Xy = xgboost.ExtMemQuantileDMatrix(it, missing=np.nan, enable_categorical=False) booster = xgboost.train( {\"tree_method\": \"hist\", \"max_depth\": 4, \"device\": it.device}, Xy, evals=[(Xy, \"Train\")], num_boost_round=10, ) booster.predict(Xy) def approx_train(it: Iterator) -> None: \"\"\"The approx tree method uses the basic `DMatrix`.\"\"\" # For non-data arguments, specify it here once instead of passing them by the `next` # method. Xy = xgboost.DMatrix(it, missing=np.nan, enable_categorical=False) # ``approx`` is also supported, but less efficient due to sketching. It's # recommended to use `hist` instead. booster = xgboost.train( {\"tree_method\": \"approx\", \"max_depth\": 4, \"device\": it.device}, Xy, evals=[(Xy, \"Train\")], num_boost_round=10, ) booster.predict(Xy) def main(tmpdir: str, args: argparse.Namespace) -> None: \"\"\"Entry point for training.\"\"\" # generate some random data for demo files = make_batches( n_samples_per_batch=1024, n_features=17, n_batches=31, tmpdir=tmpdir ) it = Iterator(args.device, files) hist_train(it) approx_train(it) def setup_rmm() -> None: \"\"\"Setup RMM for GPU-based external memory training. It's important to use RMM with `CudaAsyncMemoryResource` or `ArenaMemoryResource` for GPU-based external memory to improve performance. If XGBoost is not built with RMM support, a warning is raised when constructing the `DMatrix`. \"\"\" import rmm from cuda import cudart from rmm.allocators.cupy import rmm_cupy_allocator from rmm.mr import ArenaMemoryResource if not xgboost.build_info()[\"USE_RMM\"]: return status, free, total = cudart.cudaMemGetInfo() if status != cudart.cudaError_t.cudaSuccess: raise RuntimeError(cudart.cudaGetErrorString(status)) mr = rmm.mr.CudaMemoryResource() mr = ArenaMemoryResource(mr, arena_size=int(total * 0.9)) rmm.mr.set_current_device_resource(mr) # Set the allocator for cupy as well. cp.cuda.set_allocator(rmm_cupy_allocator) if __name__ ==", "prev_chunk_id": "chunk_171", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_173", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/external_memory.html", "title": "Experimental support for external memory", "page_title": "Experimental support for external memory — xgboost 3.0.4 documentation", "breadcrumbs": "Experimental support for external memory", "content": "\"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--device\", choices=[\"cpu\", \"cuda\"], default=\"cpu\") args = parser.parse_args() if args.device == \"cuda\": import cupy as cp setup_rmm() # Make sure XGBoost is using RMM for all allocations. with xgboost.config_context(use_rmm=True): with tempfile.TemporaryDirectory() as tmpdir: main(tmpdir, args) else: with tempfile.TemporaryDirectory() as tmpdir: main(tmpdir, args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_172", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_174", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/callbacks.html", "title": "Demo for using and defining callback functions", "page_title": "Demo for using and defining callback functions — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using and defining callback functions", "content": "Demo for using and defining callback functions import argparse import os import tempfile from typing import Dict import numpy as np from matplotlib import pyplot as plt from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split import xgboost as xgb class Plotting(xgb.callback.TrainingCallback): \"\"\"Plot evaluation result during training. Only for demonstration purpose as it's quite slow to draw using matplotlib. \"\"\" def __init__(self, rounds: int) -> None: self.fig = plt.figure() self.ax = self.fig.add_subplot(111) self.rounds = rounds self.lines: Dict[str, plt.Line2D] = {} self.fig.show() self.x = np.linspace(0, self.rounds, self.rounds) plt.ion() def _get_key(self, data: str, metric: str) -> str: return f\"{data}-{metric}\" def after_iteration( self, model: xgb.Booster, epoch: int, evals_log: Dict[str, dict] ) -> bool: \"\"\"Update the plot.\"\"\" if not self.lines: for data, metric in evals_log.items(): for metric_name, log in metric.items(): key = self._get_key(data, metric_name) expanded = log + [0] * (self.rounds - len(log)) (self.lines[key],) = self.ax.plot(self.x, expanded, label=key) self.ax.legend() else: # https://pythonspot.com/matplotlib-update-plot/ for data, metric in evals_log.items(): for metric_name, log in metric.items(): key = self._get_key(data, metric_name) expanded = log + [0] * (self.rounds - len(log)) self.lines[key].set_ydata(expanded) self.fig.canvas.draw() # False to indicate training should not stop. return False def custom_callback() -> None: \"\"\"Demo for defining a custom callback function that plots evaluation result during training.\"\"\" X, y = load_breast_cancer(return_X_y=True) X_train, X_valid, y_train, y_valid = train_test_split(X, y, random_state=0) D_train = xgb.DMatrix(X_train, y_train) D_valid = xgb.DMatrix(X_valid, y_valid) num_boost_round = 100 plotting = Plotting(num_boost_round) # Pass it to the `callbacks` parameter as a list. xgb.train( { \"objective\": \"binary:logistic\", \"eval_metric\": [\"error\", \"rmse\"], \"tree_method\": \"hist\", \"device\": \"cuda\", }, D_train, evals=[(D_train, \"Train\"), (D_valid, \"Valid\")], num_boost_round=num_boost_round, callbacks=[plotting], ) def check_point_callback() -> None: \"\"\"Demo for using the checkpoint callback. Custom logic for handling output is usually required and users are encouraged to define their own callback for checkpointing operations. The builtin one can be used as a starting point. \"\"\" # Only for demo,", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_175", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/callbacks.html", "title": "Demo for using and defining callback functions", "page_title": "Demo for using and defining callback functions — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using and defining callback functions", "content": "set a larger value (like 100) in practice as checkpointing is quite # slow. rounds = 2 def check(as_pickle: bool) -> None: for i in range(0, 10, rounds): if i == 0: continue if as_pickle: path = os.path.join(tmpdir, \"model_\" + str(i) + \".pkl\") else: path = os.path.join( tmpdir, f\"model_{i}.{xgb.callback.TrainingCheckPoint.default_format}\", ) assert os.path.exists(path) X, y = load_breast_cancer(return_X_y=True) m = xgb.DMatrix(X, y) # Check point to a temporary directory for demo with tempfile.TemporaryDirectory() as tmpdir: # Use callback class from xgboost.callback # Feel free to subclass/customize it to suit your need. check_point = xgb.callback.TrainingCheckPoint( directory=tmpdir, interval=rounds, name=\"model\" ) xgb.train( {\"objective\": \"binary:logistic\"}, m, num_boost_round=10, verbose_eval=False, callbacks=[check_point], ) check(False) # This version of checkpoint saves everything including parameters and # model. See: doc/tutorials/saving_model.rst check_point = xgb.callback.TrainingCheckPoint( directory=tmpdir, interval=rounds, as_pickle=True, name=\"model\" ) xgb.train( {\"objective\": \"binary:logistic\"}, m, num_boost_round=10, verbose_eval=False, callbacks=[check_point], ) check(True) if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--plot\", default=1, type=int) args = parser.parse_args() check_point_callback() if args.plot: custom_callback() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_174", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_176", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_pipeline.html", "title": "Feature engineering pipeline for categorical data", "page_title": "Feature engineering pipeline for categorical data — xgboost 3.0.4 documentation", "breadcrumbs": "Feature engineering pipeline for categorical data", "content": "Feature engineering pipeline for categorical data The script showcases how to keep the categorical data encoding consistent across training and inference. There are many ways to attain the same goal, this script can be used as a starting point.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_177", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_pipeline.html", "title": "See Also", "page_title": "Feature engineering pipeline for categorical data — xgboost 3.0.4 documentation", "breadcrumbs": "See Also", "content": "See Also - Tutorial - Getting started with categorical data - Train XGBoost with cat_in_the_dat dataset from typing import List, Tuple import numpy as np import pandas as pd from sklearn.compose import make_column_selector, make_column_transformer from sklearn.model_selection import train_test_split from sklearn.pipeline import make_pipeline from sklearn.preprocessing import OrdinalEncoder import xgboost as xgb def make_example_data() -> Tuple[pd.DataFrame, pd.Series, List[str]]: \"\"\"Generate data for demo.\"\"\" n_samples = 2048 rng = np.random.default_rng(1994) # We have three categorical features, while the rest are numerical. categorical_features = [\"brand_id\", \"retailer_id\", \"category_id\"] df = pd.DataFrame( np.random.randint(32, 96, size=(n_samples, 3)), columns=categorical_features, ) df[\"price\"] = rng.integers(100, 200, size=(n_samples,)) df[\"stock_status\"] = rng.choice([True, False], n_samples) df[\"on_sale\"] = rng.choice([True, False], n_samples) df[\"label\"] = rng.normal(loc=0.0, scale=1.0, size=n_samples) X = df.drop([\"label\"], axis=1) y = df[\"label\"] return X, y, categorical_features def native() -> None: \"\"\"Using the native XGBoost interface.\"\"\" X, y, cat_feats = make_example_data() X_train, X_test, y_train, y_test = train_test_split( X, y, random_state=1994, test_size=0.2 ) # Create an encoder based on training data. enc = OrdinalEncoder(handle_unknown=\"use_encoded_value\", unknown_value=np.nan) enc.set_output(transform=\"pandas\") enc = enc.fit(X_train[cat_feats]) def enc_transform(X: pd.DataFrame) -> pd.DataFrame: # don't make change inplace so that we can have demonstrations for encoding X = X.copy() cat_cols = enc.transform(X[cat_feats]) for i, name in enumerate(cat_feats): # create pd.Series based on the encoder cat_cols[name] = pd.Categorical.from_codes( codes=cat_cols[name].astype(np.int32), categories=enc.categories_[i] ) X[cat_feats] = cat_cols return X # Encode the data based on fitted encoder. X_train_enc = enc_transform(X_train) X_test_enc = enc_transform(X_test) # Train XGBoost model using the native interface. Xy_train = xgb.QuantileDMatrix(X_train_enc, y_train, enable_categorical=True) Xy_test = xgb.QuantileDMatrix( X_test_enc, y_test, enable_categorical=True, ref=Xy_train ) booster = xgb.train({}, Xy_train) booster.predict(Xy_test) # Following shows that data are encoded consistently. # We first obtain result from newly encoded data predt0 = booster.inplace_predict(enc_transform(X_train.head(16))) # then we obtain result from already encoded data from training. predt1 = booster.inplace_predict(X_train_enc.head(16)) np.testing.assert_allclose(predt0, predt1) def pipeline() -> None: \"\"\"Using the sklearn pipeline.\"\"\" X, y, cat_feats = make_example_data() X_train,", "prev_chunk_id": "chunk_176", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_178", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_pipeline.html", "title": "See Also", "page_title": "Feature engineering pipeline for categorical data — xgboost 3.0.4 documentation", "breadcrumbs": "See Also", "content": "X_test, y_train, y_test = train_test_split( X, y, random_state=3, test_size=0.2 ) enc = make_column_transformer( ( OrdinalEncoder(handle_unknown=\"use_encoded_value\", unknown_value=np.nan), # all categorical feature names end with \"_id\" make_column_selector(pattern=\".*_id\"), ), remainder=\"passthrough\", verbose_feature_names_out=False, ) # No need to set pandas output, we use `feature_types` to indicate the type of # features. # enc.set_output(transform=\"pandas\") feature_types = [\"c\" if fn in cat_feats else \"q\" for fn in X_train.columns] reg = xgb.XGBRegressor( feature_types=feature_types, enable_categorical=True, n_estimators=10 ) p = make_pipeline(enc, reg) p.fit(X_train, y_train) # check XGBoost is using the feature type correctly. model_types = reg.get_booster().feature_types assert model_types is not None for a, b in zip(model_types, feature_types): assert a == b # Following shows that data are encoded consistently. # We first create a slice of data that doesn't contain all the categories predt0 = p.predict(X_train.iloc[:16, :]) # Then we use the dataframe that contains all the categories predt1 = p.predict(X_train)[:16] # The resulting encoding is the same np.testing.assert_allclose(predt0, predt1) if __name__ == \"__main__\": pipeline() native() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_177", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_179", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/continuation.html", "title": "Demo for training continuation", "page_title": "Demo for training continuation — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for training continuation", "content": "Demo for training continuation import os import pickle import tempfile from sklearn.datasets import load_breast_cancer import xgboost def training_continuation(tmpdir: str, use_pickle: bool) -> None: \"\"\"Basic training continuation.\"\"\" # Train 128 iterations in 1 session X, y = load_breast_cancer(return_X_y=True) clf = xgboost.XGBClassifier(n_estimators=128, eval_metric=\"logloss\") clf.fit(X, y, eval_set=[(X, y)]) print(\"Total boosted rounds:\", clf.get_booster().num_boosted_rounds()) # Train 128 iterations in 2 sessions, with the first one runs for 32 iterations and # the second one runs for 96 iterations clf = xgboost.XGBClassifier(n_estimators=32, eval_metric=\"logloss\") clf.fit(X, y, eval_set=[(X, y)]) assert clf.get_booster().num_boosted_rounds() == 32 # load back the model, this could be a checkpoint if use_pickle: path = os.path.join(tmpdir, \"model-first-32.pkl\") with open(path, \"wb\") as fd: pickle.dump(clf, fd) with open(path, \"rb\") as fd: loaded = pickle.load(fd) else: path = os.path.join(tmpdir, \"model-first-32.json\") clf.save_model(path) loaded = xgboost.XGBClassifier() loaded.load_model(path) clf = xgboost.XGBClassifier(n_estimators=128 - 32, eval_metric=\"logloss\") clf.fit(X, y, eval_set=[(X, y)], xgb_model=loaded) print(\"Total boosted rounds:\", clf.get_booster().num_boosted_rounds()) assert clf.get_booster().num_boosted_rounds() == 128 def training_continuation_early_stop(tmpdir: str, use_pickle: bool) -> None: \"\"\"Training continuation with early stopping.\"\"\" early_stopping_rounds = 5 early_stop = xgboost.callback.EarlyStopping( rounds=early_stopping_rounds, save_best=True ) n_estimators = 512 X, y = load_breast_cancer(return_X_y=True) clf = xgboost.XGBClassifier( n_estimators=n_estimators, eval_metric=\"logloss\", callbacks=[early_stop] ) clf.fit(X, y, eval_set=[(X, y)]) print(\"Total boosted rounds:\", clf.get_booster().num_boosted_rounds()) best = clf.best_iteration # Train 512 iterations in 2 sessions, with the first one runs for 128 iterations and # the second one runs until early stop. clf = xgboost.XGBClassifier( n_estimators=128, eval_metric=\"logloss\", callbacks=[early_stop] ) # Reinitialize the early stop callback early_stop = xgboost.callback.EarlyStopping( rounds=early_stopping_rounds, save_best=True ) clf.set_params(callbacks=[early_stop]) clf.fit(X, y, eval_set=[(X, y)]) assert clf.get_booster().num_boosted_rounds() == 128 # load back the model, this could be a checkpoint if use_pickle: path = os.path.join(tmpdir, \"model-first-128.pkl\") with open(path, \"wb\") as fd: pickle.dump(clf, fd) with open(path, \"rb\") as fd: loaded = pickle.load(fd) else: path = os.path.join(tmpdir, \"model-first-128.json\") clf.save_model(path) loaded = xgboost.XGBClassifier() loaded.load_model(path) early_stop = xgboost.callback.EarlyStopping( rounds=early_stopping_rounds, save_best=True ) clf = xgboost.XGBClassifier( n_estimators=n_estimators - 128, eval_metric=\"logloss\", callbacks=[early_stop] ) clf.fit(", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_180", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/continuation.html", "title": "Demo for training continuation", "page_title": "Demo for training continuation — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for training continuation", "content": "X, y, eval_set=[(X, y)], xgb_model=loaded, ) print(\"Total boosted rounds:\", clf.get_booster().num_boosted_rounds()) assert clf.best_iteration == best if __name__ == \"__main__\": with tempfile.TemporaryDirectory() as tmpdir: training_continuation_early_stop(tmpdir, False) training_continuation_early_stop(tmpdir, True) training_continuation(tmpdir, True) training_continuation(tmpdir, False) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_179", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_181", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/multioutput_regression.html", "title": "A demo for multi-output regression", "page_title": "A demo for multi-output regression — xgboost 3.0.4 documentation", "breadcrumbs": "A demo for multi-output regression", "content": "A demo for multi-output regression The demo is adopted from scikit-learn: https://scikit-learn.org/stable/auto_examples/ensemble/plot_random_forest_regression_multioutput.html#sphx-glr-auto-examples-ensemble-plot-random-forest-regression-multioutput-py See Multiple Outputs for more information. import argparse from typing import Dict, List, Tuple import numpy as np from matplotlib import pyplot as plt import xgboost as xgb def plot_predt(y: np.ndarray, y_predt: np.ndarray, name: str) -> None: s = 25 plt.scatter(y[:, 0], y[:, 1], c=\"navy\", s=s, edgecolor=\"black\", label=\"data\") plt.scatter( y_predt[:, 0], y_predt[:, 1], c=\"cornflowerblue\", s=s, edgecolor=\"black\" ) plt.xlim([-1, 2]) plt.ylim([-1, 2]) plt.show() def gen_circle() -> Tuple[np.ndarray, np.ndarray]: \"Generate a sample dataset that y is a 2 dim circle.\" rng = np.random.RandomState(1994) X = np.sort(200 * rng.rand(100, 1) - 100, axis=0) y = np.array([np.pi * np.sin(X).ravel(), np.pi * np.cos(X).ravel()]).T y[::5, :] += 0.5 - rng.rand(20, 2) y = y - y.min() y = y / y.max() return X, y def rmse_model(plot_result: bool, strategy: str) -> None: \"\"\"Draw a circle with 2-dim coordinate as target variables.\"\"\" X, y = gen_circle() # Train a regressor on it reg = xgb.XGBRegressor( tree_method=\"hist\", n_estimators=128, n_jobs=16, max_depth=8, multi_strategy=strategy, subsample=0.6, ) reg.fit(X, y, eval_set=[(X, y)]) y_predt = reg.predict(X) if plot_result: plot_predt(y, y_predt, \"multi\") def custom_rmse_model(plot_result: bool, strategy: str) -> None: \"\"\"Train using Python implementation of Squared Error.\"\"\" def gradient(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: \"\"\"Compute the gradient squared error.\"\"\" y = dtrain.get_label().reshape(predt.shape) return predt - y def hessian(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: \"\"\"Compute the hessian for squared error.\"\"\" return np.ones(predt.shape) def squared_log( predt: np.ndarray, dtrain: xgb.DMatrix ) -> Tuple[np.ndarray, np.ndarray]: grad = gradient(predt, dtrain) hess = hessian(predt, dtrain) # both numpy.ndarray and cupy.ndarray works. return grad, hess def rmse(predt: np.ndarray, dtrain: xgb.DMatrix) -> Tuple[str, float]: y = dtrain.get_label().reshape(predt.shape) v = np.sqrt(np.sum(np.power(y - predt, 2))) return \"PyRMSE\", v X, y = gen_circle() Xy = xgb.DMatrix(X, y) results: Dict[str, Dict[str, List[float]]] = {} # Make sure the `num_target` is passed to XGBoost when custom objective is", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_182", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/multioutput_regression.html", "title": "A demo for multi-output regression", "page_title": "A demo for multi-output regression — xgboost 3.0.4 documentation", "breadcrumbs": "A demo for multi-output regression", "content": "used. # When builtin objective is used, XGBoost can figure out the number of targets # automatically. booster = xgb.train( { \"tree_method\": \"hist\", \"num_target\": y.shape[1], \"multi_strategy\": strategy, }, dtrain=Xy, num_boost_round=128, obj=squared_log, evals=[(Xy, \"Train\")], evals_result=results, custom_metric=rmse, ) y_predt = booster.inplace_predict(X) if plot_result: plot_predt(y, y_predt, \"multi\") if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument(\"--plot\", choices=[0, 1], type=int, default=1) args = parser.parse_args() # Train with builtin RMSE objective # - One model per output. rmse_model(args.plot == 1, \"one_output_per_tree\") # - One model for all outputs, this is still working in progress, many features are # missing. rmse_model(args.plot == 1, \"multi_output_tree\") # Train with custom objective. # - One model per output. custom_rmse_model(args.plot == 1, \"one_output_per_tree\") # - One model for all outputs, this is still working in progress, many features are # missing. custom_rmse_model(args.plot == 1, \"multi_output_tree\") Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_181", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_183", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_in_the_dat.html", "title": "Train XGBoost with cat_in_the_dat dataset", "page_title": "Train XGBoost with cat_in_the_dat dataset — xgboost 3.0.4 documentation", "breadcrumbs": "Train XGBoost with cat_in_the_dat dataset", "content": "Train XGBoost with cat_in_the_dat dataset A simple demo for categorical data support using dataset from Kaggle categorical data tutorial. The excellent tutorial is at: https://www.kaggle.com/shahules/an-overview-of-encoding-techniques And the data can be found at: https://www.kaggle.com/shahules/an-overview-of-encoding-techniques/data", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_184", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_in_the_dat.html", "title": "See Also", "page_title": "Train XGBoost with cat_in_the_dat dataset — xgboost 3.0.4 documentation", "breadcrumbs": "See Also", "content": "See Also - Tutorial - Getting started with categorical data - Feature engineering pipeline for categorical data from __future__ import annotations import os from tempfile import TemporaryDirectory from time import time import pandas as pd from sklearn.metrics import roc_auc_score from sklearn.model_selection import train_test_split import xgboost as xgb def load_cat_in_the_dat() -> tuple[pd.DataFrame, pd.Series]: \"\"\"Assuming you have already downloaded the data into `input` directory.\"\"\" df_train = pd.read_csv(\"./input/cat-in-the-dat/train.csv\") print( \"train data set has got {} rows and {} columns\".format( df_train.shape[0], df_train.shape[1] ) ) X = df_train.drop([\"target\"], axis=1) y = df_train[\"target\"] for i in range(0, 5): X[\"bin_\" + str(i)] = X[\"bin_\" + str(i)].astype(\"category\") for i in range(0, 5): X[\"nom_\" + str(i)] = X[\"nom_\" + str(i)].astype(\"category\") for i in range(5, 10): X[\"nom_\" + str(i)] = X[\"nom_\" + str(i)].apply(int, base=16) for i in range(0, 6): X[\"ord_\" + str(i)] = X[\"ord_\" + str(i)].astype(\"category\") print( \"train data set has got {} rows and {} columns\".format(X.shape[0], X.shape[1]) ) return X, y params = { \"tree_method\": \"hist\", \"device\": \"cuda\", \"n_estimators\": 32, \"colsample_bylevel\": 0.7, } def categorical_model(X: pd.DataFrame, y: pd.Series, output_dir: str) -> None: \"\"\"Train using builtin categorical data support from XGBoost\"\"\" X_train, X_test, y_train, y_test = train_test_split( X, y, random_state=1994, test_size=0.2 ) # Be aware that the encoding for X_train and X_test are the same here. In practice, # we should try to use an encoder like (sklearn OrdinalEncoder) to obtain the # categorical values. # Specify `enable_categorical` to True. clf = xgb.XGBClassifier( **params, eval_metric=\"auc\", enable_categorical=True, max_cat_to_onehot=1, # We use optimal partitioning exclusively ) clf.fit(X_train, y_train, eval_set=[(X_test, y_test), (X_train, y_train)]) clf.save_model(os.path.join(output_dir, \"categorical.json\")) y_score = clf.predict_proba(X_test)[:, 1] # proba of positive samples auc = roc_auc_score(y_test, y_score) print(\"AUC of using builtin categorical data support:\", auc) def onehot_encoding_model(X: pd.DataFrame, y: pd.Series, output_dir: str) -> None: \"\"\"Train using one-hot encoded data.\"\"\" X_train, X_test, y_train, y_test = train_test_split( X, y, random_state=42, test_size=0.2 ) # Specify", "prev_chunk_id": "chunk_183", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_185", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cat_in_the_dat.html", "title": "See Also", "page_title": "Train XGBoost with cat_in_the_dat dataset — xgboost 3.0.4 documentation", "breadcrumbs": "See Also", "content": "`enable_categorical` to False as we are using encoded data. clf = xgb.XGBClassifier(**params, eval_metric=\"auc\", enable_categorical=False) clf.fit( X_train, y_train, eval_set=[(X_test, y_test), (X_train, y_train)], ) clf.save_model(os.path.join(output_dir, \"one-hot.json\")) y_score = clf.predict_proba(X_test)[:, 1] # proba of positive samples auc = roc_auc_score(y_test, y_score) print(\"AUC of using onehot encoding:\", auc) if __name__ == \"__main__\": X, y = load_cat_in_the_dat() with TemporaryDirectory() as tmpdir: start = time() categorical_model(X, y, tmpdir) end = time() print(\"Duration:categorical\", end - start) X = pd.get_dummies(X) start = time() onehot_encoding_model(X, y, tmpdir) end = time() print(\"Duration:onehot\", end - start) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_184", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_186", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/quantile_data_iterator.html", "title": "Demo for using data iterator with Quantile DMatrix", "page_title": "Demo for using data iterator with Quantile DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using data iterator with Quantile DMatrix", "content": "Demo for using data iterator with Quantile DMatrix The demo that defines a customized iterator for passing batches of data into xgboost.QuantileDMatrix and use this QuantileDMatrix for training. The feature is primarily designed to reduce the required GPU memory for training on distributed environment. Aftering going through the demo, one might ask why don’t we use more native Python iterator? That’s because XGBoost requires a reset function, while using itertools.tee might incur significant memory usage according to: from typing import Callable import cupy import numpy import xgboost COLS = 64 ROWS_PER_BATCH = 1000 # data is splited by rows BATCHES = 32 class IterForDMatrixDemo(xgboost.core.DataIter): \"\"\"A data iterator for XGBoost DMatrix. `reset` and `next` are required for any data iterator, other functions here are utilites for demonstration's purpose. \"\"\" def __init__(self) -> None: \"\"\"Generate some random data for demostration. Actual data can be anything that is currently supported by XGBoost. \"\"\" self.rows = ROWS_PER_BATCH self.cols = COLS rng = cupy.random.RandomState(numpy.uint64(1994)) self._data = [rng.randn(self.rows, self.cols)] * BATCHES self._labels = [rng.randn(self.rows)] * BATCHES self._weights = [rng.uniform(size=self.rows)] * BATCHES self.it = 0 # set iterator to 0 super().__init__() def as_array(self) -> cupy.ndarray: return cupy.concatenate(self._data) def as_array_labels(self) -> cupy.ndarray: return cupy.concatenate(self._labels) def as_array_weights(self) -> cupy.ndarray: return cupy.concatenate(self._weights) def data(self) -> cupy.ndarray: \"\"\"Utility function for obtaining current batch of data.\"\"\" return self._data[self.it] def labels(self) -> cupy.ndarray: \"\"\"Utility function for obtaining current batch of label.\"\"\" return self._labels[self.it] def weights(self) -> cupy.ndarray: return self._weights[self.it] def reset(self) -> None: \"\"\"Reset the iterator\"\"\" self.it = 0 def next(self, input_data: Callable) -> bool: \"\"\"Yield the next batch of data.\"\"\" if self.it == len(self._data): # Return False to let XGBoost know this is the end of iteration return False # input_data is a keyword-only function passed in by XGBoost and has the similar # signature to the ``DMatrix`` constructor. input_data(data=self.data(), label=self.labels(), weight=self.weights())", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_187", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/quantile_data_iterator.html", "title": "Demo for using data iterator with Quantile DMatrix", "page_title": "Demo for using data iterator with Quantile DMatrix — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using data iterator with Quantile DMatrix", "content": "self.it += 1 return True def main() -> None: rounds = 100 it = IterForDMatrixDemo() # Use iterator, must be `QuantileDMatrix`. # In this demo, the input batches are created using cupy, and the data processing # (quantile sketching) will be performed on GPU. If data is loaded with CPU based # data structures like numpy or pandas, then the processing step will be performed # on CPU instead. m_with_it = xgboost.QuantileDMatrix(it) # Use regular DMatrix. m = xgboost.DMatrix( it.as_array(), it.as_array_labels(), weight=it.as_array_weights() ) assert m_with_it.num_col() == m.num_col() assert m_with_it.num_row() == m.num_row() # Tree method must be `hist`. reg_with_it = xgboost.train( {\"tree_method\": \"hist\", \"device\": \"cuda\"}, m_with_it, num_boost_round=rounds, evals=[(m_with_it, \"Train\")], ) predict_with_it = reg_with_it.predict(m_with_it) reg = xgboost.train( {\"tree_method\": \"hist\", \"device\": \"cuda\"}, m, num_boost_round=rounds, evals=[(m, \"Train\")], ) predict = reg.predict(m) if __name__ == \"__main__\": main() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_186", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_188", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/spark_estimator_examples.html", "title": "Collection of examples for using xgboost.spark estimator interface", "page_title": "Collection of examples for using xgboost.spark estimator interface — xgboost 3.0.4 documentation", "breadcrumbs": "Collection of examples for using xgboost.spark estimator interface", "content": "Collection of examples for using xgboost.spark estimator interface @author: Weichen Xu import sklearn.datasets from pyspark.ml.evaluation import MulticlassClassificationEvaluator, RegressionEvaluator from pyspark.ml.linalg import Vectors from pyspark.sql import SparkSession from pyspark.sql.functions import rand from sklearn.model_selection import train_test_split from xgboost.spark import SparkXGBClassifier, SparkXGBRegressor spark = SparkSession.builder.master(\"local[*]\").getOrCreate() def create_spark_df(X, y): return spark.createDataFrame( spark.sparkContext.parallelize( [(Vectors.dense(features), float(label)) for features, label in zip(X, y)] ), [\"features\", \"label\"], ) # load diabetes dataset (regression dataset) diabetes_X, diabetes_y = sklearn.datasets.load_diabetes(return_X_y=True) diabetes_X_train, diabetes_X_test, diabetes_y_train, diabetes_y_test = train_test_split( diabetes_X, diabetes_y, test_size=0.3, shuffle=True ) diabetes_train_spark_df = create_spark_df(diabetes_X_train, diabetes_y_train) diabetes_test_spark_df = create_spark_df(diabetes_X_test, diabetes_y_test) # train xgboost regressor model xgb_regressor = SparkXGBRegressor(max_depth=5) xgb_regressor_model = xgb_regressor.fit(diabetes_train_spark_df) transformed_diabetes_test_spark_df = xgb_regressor_model.transform( diabetes_test_spark_df ) regressor_evaluator = RegressionEvaluator(metricName=\"rmse\") print( f\"regressor rmse={regressor_evaluator.evaluate(transformed_diabetes_test_spark_df)}\" ) diabetes_train_spark_df2 = diabetes_train_spark_df.withColumn( \"validationIndicatorCol\", rand(1) > 0.7 ) # train xgboost regressor model with validation dataset xgb_regressor2 = SparkXGBRegressor( max_depth=5, validation_indicator_col=\"validationIndicatorCol\" ) xgb_regressor_model2 = xgb_regressor2.fit(diabetes_train_spark_df2) transformed_diabetes_test_spark_df2 = xgb_regressor_model2.transform( diabetes_test_spark_df ) print( f\"regressor2 rmse={regressor_evaluator.evaluate(transformed_diabetes_test_spark_df2)}\" ) # load iris dataset (classification dataset) iris_X, iris_y = sklearn.datasets.load_iris(return_X_y=True) iris_X_train, iris_X_test, iris_y_train, iris_y_test = train_test_split( iris_X, iris_y, test_size=0.3, shuffle=True ) iris_train_spark_df = create_spark_df(iris_X_train, iris_y_train) iris_test_spark_df = create_spark_df(iris_X_test, iris_y_test) # train xgboost classifier model xgb_classifier = SparkXGBClassifier(max_depth=5) xgb_classifier_model = xgb_classifier.fit(iris_train_spark_df) transformed_iris_test_spark_df = xgb_classifier_model.transform(iris_test_spark_df) classifier_evaluator = MulticlassClassificationEvaluator(metricName=\"f1\") print(f\"classifier f1={classifier_evaluator.evaluate(transformed_iris_test_spark_df)}\") iris_train_spark_df2 = iris_train_spark_df.withColumn( \"validationIndicatorCol\", rand(1) > 0.7 ) # train xgboost classifier model with validation dataset xgb_classifier2 = SparkXGBClassifier( max_depth=5, validation_indicator_col=\"validationIndicatorCol\" ) xgb_classifier_model2 = xgb_classifier2.fit(iris_train_spark_df2) transformed_iris_test_spark_df2 = xgb_classifier_model2.transform(iris_test_spark_df) print( f\"classifier2 f1={classifier_evaluator.evaluate(transformed_iris_test_spark_df2)}\" ) spark.stop() Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_189", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/individual_trees.html", "title": "Demo for prediction using individual trees and model slices", "page_title": "Demo for prediction using individual trees and model slices — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for prediction using individual trees and model slices", "content": "Demo for prediction using individual trees and model slices import os import numpy as np from scipy.special import logit from sklearn.datasets import load_svmlight_file import xgboost as xgb CURRENT_DIR = os.path.dirname(__file__) train = os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train\") test = os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test\") def individual_tree() -> None: \"\"\"Get prediction from each individual tree and combine them together.\"\"\" X_train, y_train = load_svmlight_file(train) X_test, y_test = load_svmlight_file(test) Xy_train = xgb.QuantileDMatrix(X_train, y_train) n_rounds = 4 # Specify the base score, otherwise xgboost will estimate one from the training # data. base_score = 0.5 params = { \"max_depth\": 2, \"eta\": 1, \"objective\": \"reg:logistic\", \"tree_method\": \"hist\", \"base_score\": base_score, } booster = xgb.train(params, Xy_train, num_boost_round=n_rounds) # Use logit to inverse the base score back to raw leaf value (margin) scores = np.full((X_test.shape[0],), logit(base_score)) for i in range(n_rounds): # - Use output_margin to get raw leaf values # - Use iteration_range to get prediction for only one tree # - Use previous prediction as base marign for the model Xy_test = xgb.DMatrix(X_test, base_margin=scores) if i == n_rounds - 1: # last round, get the transformed prediction scores = booster.predict( Xy_test, iteration_range=(i, i + 1), output_margin=False ) else: # get raw leaf value for accumulation scores = booster.predict( Xy_test, iteration_range=(i, i + 1), output_margin=True ) full = booster.predict(xgb.DMatrix(X_test), output_margin=False) np.testing.assert_allclose(scores, full) def model_slices() -> None: \"\"\"Inference with each individual tree using model slices.\"\"\" X_train, y_train = load_svmlight_file(train) X_test, y_test = load_svmlight_file(test) Xy_train = xgb.QuantileDMatrix(X_train, y_train) n_rounds = 4 # Specify the base score, otherwise xgboost will estimate one from the training # data. base_score = 0.5 params = { \"max_depth\": 2, \"eta\": 1, \"objective\": \"reg:logistic\", \"tree_method\": \"hist\", \"base_score\": base_score, } booster = xgb.train(params, Xy_train, num_boost_round=n_rounds) trees = [booster[t] for t in range(n_rounds)] # Use logit to inverse the base score back to raw leaf value (margin) scores = np.full((X_test.shape[0],), logit(base_score)) for i, t", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_190", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/individual_trees.html", "title": "Demo for prediction using individual trees and model slices", "page_title": "Demo for prediction using individual trees and model slices — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for prediction using individual trees and model slices", "content": "in enumerate(trees): # Feed previous scores into base margin. Xy_test = xgb.DMatrix(X_test, base_margin=scores) if i == n_rounds - 1: # last round, get the transformed prediction scores = t.predict(Xy_test, output_margin=False) else: # get raw leaf value for accumulation scores = t.predict(Xy_test, output_margin=True) full = booster.predict(xgb.DMatrix(X_test), output_margin=False) np.testing.assert_allclose(scores, full) if __name__ == \"__main__\": individual_tree() model_slices() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_189", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_191", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/update_process.html", "title": "Demo for using process_type with prune and refresh", "page_title": "Demo for using process_type with prune and refresh — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using process_type with prune and refresh", "content": "Demo for using process_type with prune and refresh Modifying existing trees is not a well established use for XGBoost, so feel free to experiment. import numpy as np from sklearn.datasets import fetch_california_housing import xgboost as xgb def main(): n_rounds = 32 X, y = fetch_california_housing(return_X_y=True) # Train a model first X_train = X[: X.shape[0] // 2] y_train = y[: y.shape[0] // 2] Xy = xgb.DMatrix(X_train, y_train) evals_result: xgb.callback.EvaluationMonitor.EvalsLog = {} booster = xgb.train( {\"tree_method\": \"hist\", \"max_depth\": 6, \"device\": \"cuda\"}, Xy, num_boost_round=n_rounds, evals=[(Xy, \"Train\")], evals_result=evals_result, ) SHAP = booster.predict(Xy, pred_contribs=True) # Refresh the leaf value and tree statistic X_refresh = X[X.shape[0] // 2 :] y_refresh = y[y.shape[0] // 2 :] Xy_refresh = xgb.DMatrix(X_refresh, y_refresh) # The model will adapt to other half of the data by changing leaf value (no change in # split condition) with refresh_leaf set to True. refresh_result: xgb.callback.EvaluationMonitor.EvalsLog = {} refreshed = xgb.train( {\"process_type\": \"update\", \"updater\": \"refresh\", \"refresh_leaf\": True}, Xy_refresh, num_boost_round=n_rounds, xgb_model=booster, evals=[(Xy, \"Original\"), (Xy_refresh, \"Train\")], evals_result=refresh_result, ) # Refresh the model without changing the leaf value, but tree statistic including # cover and weight are refreshed. refresh_result: xgb.callback.EvaluationMonitor.EvalsLog = {} refreshed = xgb.train( {\"process_type\": \"update\", \"updater\": \"refresh\", \"refresh_leaf\": False}, Xy_refresh, num_boost_round=n_rounds, xgb_model=booster, evals=[(Xy, \"Original\"), (Xy_refresh, \"Train\")], evals_result=refresh_result, ) # Without refreshing the leaf value, resulting trees should be the same with original # model except for accumulated statistic. The rtol is for floating point error in # prediction. np.testing.assert_allclose( refresh_result[\"Original\"][\"rmse\"], evals_result[\"Train\"][\"rmse\"], rtol=1e-5 ) # But SHAP value is changed as cover in tree nodes are changed. refreshed_SHAP = refreshed.predict(Xy, pred_contribs=True) assert not np.allclose(SHAP, refreshed_SHAP, rtol=1e-3) # Prune the trees with smaller max_depth X_update = X_train y_update = y_train Xy_update = xgb.DMatrix(X_update, y_update) prune_result: xgb.callback.EvaluationMonitor.EvalsLog = {} pruned = xgb.train( {\"process_type\": \"update\", \"updater\": \"prune\", \"max_depth\": 2}, Xy_update, num_boost_round=n_rounds, xgb_model=booster, evals=[(Xy, \"Original\"), (Xy_update, \"Train\")], evals_result=prune_result, ) # Have", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_192", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/update_process.html", "title": "Demo for using process_type with prune and refresh", "page_title": "Demo for using process_type with prune and refresh — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using process_type with prune and refresh", "content": "a smaller model, but similar accuracy. np.testing.assert_allclose( np.array(prune_result[\"Original\"][\"rmse\"]), np.array(prune_result[\"Train\"][\"rmse\"]), atol=1e-5, ) if __name__ == \"__main__\": main() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_191", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_193", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cross_validation.html", "title": "Demo for using cross validation", "page_title": "Demo for using cross validation — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using cross validation", "content": "Demo for using cross validation import os import numpy as np import xgboost as xgb # load data in do training CURRENT_DIR = os.path.dirname(__file__) dtrain = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train?format=libsvm\") ) param = {\"max_depth\": 2, \"eta\": 1, \"objective\": \"binary:logistic\"} num_round = 2 print(\"running cross validation\") # do cross validation, this will print result out as # [iteration] metric_name:mean_value+std_value # std_value is standard deviation of the metric xgb.cv( param, dtrain, num_round, nfold=5, metrics={\"error\"}, seed=0, callbacks=[xgb.callback.EvaluationMonitor(show_stdv=True)], ) print(\"running cross validation, disable standard deviation display\") # do cross validation, this will print result out as # [iteration] metric_name:mean_value res = xgb.cv( param, dtrain, num_boost_round=10, nfold=5, metrics={\"error\"}, seed=0, callbacks=[ xgb.callback.EvaluationMonitor(show_stdv=False), xgb.callback.EarlyStopping(3), ], ) print(res) print(\"running cross validation, with preprocessing function\") # define the preprocessing function # used to return the preprocessed training, test data, and parameter # we can use this to do weight rescale, etc. # as a example, we try to set scale_pos_weight def fpreproc(dtrain, dtest, param): label = dtrain.get_label() ratio = float(np.sum(label == 0)) / np.sum(label == 1) param[\"scale_pos_weight\"] = ratio return (dtrain, dtest, param) # do cross validation, for each fold # the dtrain, dtest, param will be passed into fpreproc # then the return value of fpreproc will be used to generate # results of that fold xgb.cv(param, dtrain, num_round, nfold=5, metrics={\"auc\"}, seed=0, fpreproc=fpreproc) ### # you can also do cross validation with customized loss function # See custom_objective.py ## print(\"running cross validation, with customized loss function\") def logregobj(preds, dtrain): labels = dtrain.get_label() preds = 1.0 / (1.0 + np.exp(-preds)) grad = preds - labels hess = preds * (1.0 - preds) return grad, hess def evalerror(preds, dtrain): labels = dtrain.get_label() preds = 1.0 / (1.0 + np.exp(-preds)) return \"error\", float(sum(labels != (preds > 0.0))) / len(labels) param = {\"max_depth\": 2, \"eta\": 1} # train with customized objective xgb.cv( param,", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_194", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/cross_validation.html", "title": "Demo for using cross validation", "page_title": "Demo for using cross validation — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using cross validation", "content": "dtrain, num_round, nfold=5, seed=0, obj=logregobj, custom_metric=evalerror ) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_193", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_195", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/categorical.html", "title": "Getting started with categorical data", "page_title": "Getting started with categorical data — xgboost 3.0.4 documentation", "breadcrumbs": "Getting started with categorical data", "content": "Getting started with categorical data Experimental support for categorical data. In before, users need to run an encoder themselves before passing the data into XGBoost, which creates a sparse matrix and potentially increase memory usage. This demo showcases the experimental categorical data support, more advanced features are planned.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_196", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/categorical.html", "title": "See Also", "page_title": "Getting started with categorical data — xgboost 3.0.4 documentation", "breadcrumbs": "See Also", "content": "See Also - Tutorial - Train XGBoost with cat_in_the_dat dataset - Feature engineering pipeline for categorical data from typing import Tuple import numpy as np import pandas as pd import xgboost as xgb def make_categorical( n_samples: int, n_features: int, n_categories: int, onehot: bool ) -> Tuple[pd.DataFrame, pd.Series]: \"\"\"Make some random data for demo.\"\"\" rng = np.random.RandomState(1994) pd_dict = {} for i in range(n_features + 1): c = rng.randint(low=0, high=n_categories, size=n_samples) pd_dict[str(i)] = pd.Series(c, dtype=np.int64) df = pd.DataFrame(pd_dict) label = df.iloc[:, 0] df = df.iloc[:, 1:] for i in range(0, n_features): label += df.iloc[:, i] label += 1 df = df.astype(\"category\") categories = np.arange(0, n_categories) for col in df.columns: df[col] = df[col].cat.set_categories(categories) if onehot: return pd.get_dummies(df), label return df, label def main() -> None: # Use builtin categorical data support # For scikit-learn interface, the input data should be pandas DataFrame or cudf # DataFrame with categorical features. If an numpy/cupy array is used instead, the # `feature_types` for `XGBRegressor` should be set accordingly. X, y = make_categorical(100, 10, 4, False) # Specify `enable_categorical` to True, also we use onehot-encoding-based split here # for demonstration. For details see the document of `max_cat_to_onehot`. reg = xgb.XGBRegressor( tree_method=\"hist\", enable_categorical=True, max_cat_to_onehot=5, device=\"cuda\" ) reg.fit(X, y, eval_set=[(X, y)]) # Pass in already encoded data X_enc, y_enc = make_categorical(100, 10, 4, True) reg_enc = xgb.XGBRegressor(tree_method=\"hist\", device=\"cuda\") reg_enc.fit(X_enc, y_enc, eval_set=[(X_enc, y_enc)]) reg_results = np.array(reg.evals_result()[\"validation_0\"][\"rmse\"]) reg_enc_results = np.array(reg_enc.evals_result()[\"validation_0\"][\"rmse\"]) # Check that they have same results np.testing.assert_allclose(reg_results, reg_enc_results) # Convert to DMatrix for SHAP value booster: xgb.Booster = reg.get_booster() m = xgb.DMatrix(X, enable_categorical=True) # specify categorical data support. SHAP = booster.predict(m, pred_contribs=True) margin = booster.predict(m, output_margin=True) np.testing.assert_allclose( np.sum(SHAP, axis=len(SHAP.shape) - 1), margin, rtol=1e-3 ) if __name__ == \"__main__\": main() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_195", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_197", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/sklearn_examples.html", "title": "Collection of examples for using sklearn interface", "page_title": "Collection of examples for using sklearn interface — xgboost 3.0.4 documentation", "breadcrumbs": "Collection of examples for using sklearn interface", "content": "Collection of examples for using sklearn interface For an introduction to XGBoost’s scikit-learn estimator interface, see Using the Scikit-Learn Estimator Interface. Created on 1 Apr 2015 @author: Jamie Hall import pickle import numpy as np from sklearn.datasets import fetch_california_housing, load_digits, load_iris from sklearn.metrics import confusion_matrix, mean_squared_error from sklearn.model_selection import GridSearchCV, KFold, train_test_split import xgboost as xgb rng = np.random.RandomState(31337) print(\"Zeros and Ones from the Digits dataset: binary classification\") digits = load_digits(n_class=2) y = digits[\"target\"] X = digits[\"data\"] kf = KFold(n_splits=2, shuffle=True, random_state=rng) for train_index, test_index in kf.split(X): xgb_model = xgb.XGBClassifier(n_jobs=1).fit(X[train_index], y[train_index]) predictions = xgb_model.predict(X[test_index]) actuals = y[test_index] print(confusion_matrix(actuals, predictions)) print(\"Iris: multiclass classification\") iris = load_iris() y = iris[\"target\"] X = iris[\"data\"] kf = KFold(n_splits=2, shuffle=True, random_state=rng) for train_index, test_index in kf.split(X): xgb_model = xgb.XGBClassifier(n_jobs=1).fit(X[train_index], y[train_index]) predictions = xgb_model.predict(X[test_index]) actuals = y[test_index] print(confusion_matrix(actuals, predictions)) print(\"California Housing: regression\") X, y = fetch_california_housing(return_X_y=True) kf = KFold(n_splits=2, shuffle=True, random_state=rng) for train_index, test_index in kf.split(X): xgb_model = xgb.XGBRegressor(n_jobs=1).fit(X[train_index], y[train_index]) predictions = xgb_model.predict(X[test_index]) actuals = y[test_index] print(mean_squared_error(actuals, predictions)) print(\"Parameter optimization\") xgb_model = xgb.XGBRegressor(n_jobs=1) clf = GridSearchCV( xgb_model, {\"max_depth\": [2, 4], \"n_estimators\": [50, 100]}, verbose=1, n_jobs=1, cv=3, ) clf.fit(X, y) print(clf.best_score_) print(clf.best_params_) # The sklearn API models are picklable print(\"Pickling sklearn API models\") # must open in binary format to pickle pickle.dump(clf, open(\"best_calif.pkl\", \"wb\")) clf2 = pickle.load(open(\"best_calif.pkl\", \"rb\")) print(np.allclose(clf.predict(X), clf2.predict(X))) # Early-stopping X = digits[\"data\"] y = digits[\"target\"] X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) clf = xgb.XGBClassifier(n_jobs=1, early_stopping_rounds=10, eval_metric=\"auc\") clf.fit(X_train, y_train, eval_set=[(X_test, y_test)]) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_198", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/basic_walkthrough.html", "title": "Getting started with XGBoost", "page_title": "Getting started with XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Getting started with XGBoost", "content": "Getting started with XGBoost This is a simple example of using the native XGBoost interface, there are other interfaces in the Python package like scikit-learn interface and Dask interface. See Python Package Introduction and XGBoost Tutorials for other references. import os import pickle import numpy as np from sklearn.datasets import load_svmlight_file import xgboost as xgb # Make sure the demo knows where to load the data. CURRENT_DIR = os.path.dirname(os.path.abspath(__file__)) XGBOOST_ROOT_DIR = os.path.dirname(os.path.dirname(CURRENT_DIR)) DEMO_DIR = os.path.join(XGBOOST_ROOT_DIR, \"demo\") # X is a scipy csr matrix, XGBoost supports many other input types, X, y = load_svmlight_file(os.path.join(DEMO_DIR, \"data\", \"agaricus.txt.train\")) dtrain = xgb.DMatrix(X, y) # validation set X_test, y_test = load_svmlight_file(os.path.join(DEMO_DIR, \"data\", \"agaricus.txt.test\")) dtest = xgb.DMatrix(X_test, y_test) # specify parameters via map, definition are same as c++ version param = {\"max_depth\": 2, \"eta\": 1, \"objective\": \"binary:logistic\"} # specify validations set to watch performance watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] # number of boosting rounds num_round = 2 bst = xgb.train(param, dtrain, num_boost_round=num_round, evals=watchlist) # run prediction preds = bst.predict(dtest) labels = dtest.get_label() print( \"error=%f\" % ( sum(1 for i in range(len(preds)) if int(preds[i] > 0.5) != labels[i]) / float(len(preds)) ) ) bst.save_model(\"model-0.json\") # dump model bst.dump_model(\"dump.raw.txt\") # dump model with feature map bst.dump_model(\"dump.nice.txt\", os.path.join(DEMO_DIR, \"data/featmap.txt\")) # save dmatrix into binary buffer dtest.save_binary(\"dtest.dmatrix\") # save model bst.save_model(\"model-1.json\") # load model and data in bst2 = xgb.Booster(model_file=\"model-1.json\") dtest2 = xgb.DMatrix(\"dtest.dmatrix\") preds2 = bst2.predict(dtest2) # assert they are the same assert np.sum(np.abs(preds2 - preds)) == 0 # alternatively, you can pickle the booster pks = pickle.dumps(bst2) # load model and data in bst3 = pickle.loads(pks) preds3 = bst3.predict(dtest2) # assert they are the same assert np.sum(np.abs(preds3 - preds)) == 0 Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_199", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/predict_first_ntree.html", "title": "Demo for prediction using number of trees", "page_title": "Demo for prediction using number of trees — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for prediction using number of trees", "content": "Demo for prediction using number of trees import os import numpy as np from sklearn.datasets import load_svmlight_file import xgboost as xgb CURRENT_DIR = os.path.dirname(__file__) train = os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train\") test = os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test\") def native_interface(): # load data in do training dtrain = xgb.DMatrix(train + \"?format=libsvm\") dtest = xgb.DMatrix(test + \"?format=libsvm\") param = {\"max_depth\": 2, \"eta\": 1, \"objective\": \"binary:logistic\"} watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] num_round = 3 bst = xgb.train(param, dtrain, num_round, watchlist) print(\"start testing prediction from first n trees\") # predict using first 1 tree label = dtest.get_label() ypred1 = bst.predict(dtest, iteration_range=(0, 1)) # by default, we predict using all the trees ypred2 = bst.predict(dtest) print(\"error of ypred1=%f\" % (np.sum((ypred1 > 0.5) != label) / float(len(label)))) print(\"error of ypred2=%f\" % (np.sum((ypred2 > 0.5) != label) / float(len(label)))) def sklearn_interface(): X_train, y_train = load_svmlight_file(train) X_test, y_test = load_svmlight_file(test) clf = xgb.XGBClassifier(n_estimators=3, max_depth=2, eta=1) clf.fit(X_train, y_train, eval_set=[(X_test, y_test)]) assert clf.n_classes_ == 2 print(\"start testing prediction from first n trees\") # predict using first 1 tree ypred1 = clf.predict(X_test, iteration_range=(0, 1)) # by default, we predict using all the trees ypred2 = clf.predict(X_test) print( \"error of ypred1=%f\" % (np.sum((ypred1 > 0.5) != y_test) / float(len(y_test))) ) print( \"error of ypred2=%f\" % (np.sum((ypred2 > 0.5) != y_test) / float(len(y_test))) ) if __name__ == \"__main__\": native_interface() sklearn_interface() Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_200", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/generalized_linear_model.html", "title": "Demo for GLM", "page_title": "Demo for GLM — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for GLM", "content": "Demo for GLM import os import xgboost as xgb ## # this script demonstrate how to fit generalized linear model in xgboost # basically, we are using linear model, instead of tree for our boosters ## CURRENT_DIR = os.path.dirname(__file__) dtrain = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train?format=libsvm\") ) dtest = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test?format=libsvm\") ) # change booster to gblinear, so that we are fitting a linear model # alpha is the L1 regularizer # lambda is the L2 regularizer # you can also set lambda_bias which is L2 regularizer on the bias term param = { \"objective\": \"binary:logistic\", \"booster\": \"gblinear\", \"alpha\": 0.0001, \"lambda\": 1, } # normally, you do not need to set eta (step_size) # XGBoost uses a parallel coordinate descent algorithm (shotgun), # there could be affection on convergence with parallelization on certain cases # setting eta to be smaller value, e.g 0.5 can make the optimization more stable # param['eta'] = 1 ## # the rest of settings are the same ## watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] num_round = 4 bst = xgb.train(param, dtrain, num_round, watchlist) preds = bst.predict(dtest) labels = dtest.get_label() print( \"error=%f\" % ( sum(1 for i in range(len(preds)) if int(preds[i] > 0.5) != labels[i]) / float(len(preds)) ) ) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_201", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/feature_weights.html", "title": "Demo for using feature weight to change column sampling", "page_title": "Demo for using feature weight to change column sampling — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using feature weight to change column sampling", "content": "Demo for using feature weight to change column sampling import argparse import numpy as np from matplotlib import pyplot as plt import xgboost def main(args: argparse.Namespace) -> None: rng = np.random.RandomState(1994) kRows = 4196 kCols = 10 X = rng.randn(kRows, kCols) y = rng.randn(kRows) fw = np.ones(shape=(kCols,)) for i in range(kCols): fw[i] *= float(i) dtrain = xgboost.DMatrix(X, y) dtrain.set_info(feature_weights=fw) # Perform column sampling for each node split evaluation, the sampling process is # weighted by feature weights. bst = xgboost.train( {\"tree_method\": \"hist\", \"colsample_bynode\": 0.2}, dtrain, num_boost_round=10, evals=[(dtrain, \"d\")], ) feature_map = bst.get_fscore() # feature zero has 0 weight assert feature_map.get(\"f0\", None) is None assert max(feature_map.values()) == feature_map.get(\"f9\") if args.plot: xgboost.plot_importance(bst) plt.show() if __name__ == \"__main__\": parser = argparse.ArgumentParser() parser.add_argument( \"--plot\", type=int, default=1, help=\"Set to 0 to disable plotting the evaluation history.\", ) args = parser.parse_args() main(args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_202", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/sklearn_evals_result.html", "title": "Demo for accessing the xgboost eval metrics by using sklearn interface", "page_title": "Demo for accessing the xgboost eval metrics by using sklearn interface — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for accessing the xgboost eval metrics by using sklearn interface", "content": "Demo for accessing the xgboost eval metrics by using sklearn interface import numpy as np from sklearn.datasets import make_hastie_10_2 import xgboost as xgb X, y = make_hastie_10_2(n_samples=2000, random_state=42) # Map labels from {-1, 1} to {0, 1} labels, y = np.unique(y, return_inverse=True) X_train, X_test = X[:1600], X[1600:] y_train, y_test = y[:1600], y[1600:] param_dist = {\"objective\": \"binary:logistic\", \"n_estimators\": 2} clf = xgb.XGBModel( **param_dist, eval_metric=\"logloss\", ) # Or you can use: clf = xgb.XGBClassifier(**param_dist) clf.fit( X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)], verbose=True, ) # Load evals result by calling the evals_result() function evals_result = clf.evals_result() print(\"Access logloss metric directly from validation_0:\") print(evals_result[\"validation_0\"][\"logloss\"]) print(\"\") print(\"Access metrics through a loop:\") for e_name, e_mtrs in evals_result.items(): print(\"- {}\".format(e_name)) for e_mtr_name, e_mtr_vals in e_mtrs.items(): print(\" - {}\".format(e_mtr_name)) print(\" - {}\".format(e_mtr_vals)) print(\"\") print(\"Access complete dict:\") print(evals_result) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_203", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/boost_from_prediction.html", "title": "Demo for boosting from prediction", "page_title": "Demo for boosting from prediction — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for boosting from prediction", "content": "Demo for boosting from prediction import os import xgboost as xgb CURRENT_DIR = os.path.dirname(__file__) dtrain = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train?format=libsvm\") ) dtest = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test?format=libsvm\") ) watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] ### # advanced: start from a initial base prediction # print(\"start running example to start from a initial prediction\") # specify parameters via map, definition are same as c++ version param = {\"max_depth\": 2, \"eta\": 1, \"objective\": \"binary:logistic\"} # train xgboost for 1 round bst = xgb.train(param, dtrain, 1, watchlist) # Note: we need the margin value instead of transformed prediction in # set_base_margin # do predict with output_margin=True, will always give you margin values # before logistic transformation ptrain = bst.predict(dtrain, output_margin=True) ptest = bst.predict(dtest, output_margin=True) dtrain.set_base_margin(ptrain) dtest.set_base_margin(ptest) print(\"this is result of running from initial prediction\") bst = xgb.train(param, dtrain, 1, watchlist) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_204", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/gamma_regression.html", "title": "Demo for gamma regression", "page_title": "Demo for gamma regression — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for gamma regression", "content": "Demo for gamma regression import numpy as np import xgboost as xgb # this script demonstrates how to fit gamma regression model (with log link function) # in xgboost, before running the demo you need to generate the autoclaims dataset # by running gen_autoclaims.R located in xgboost/demo/data. data = np.genfromtxt('../data/autoclaims.csv', delimiter=',') dtrain = xgb.DMatrix(data[0:4741, 0:34], data[0:4741, 34]) dtest = xgb.DMatrix(data[4741:6773, 0:34], data[4741:6773, 34]) # for gamma regression, we need to set the objective to 'reg:gamma', it also suggests # to set the base_score to a value between 1 to 5 if the number of iteration is small param = {'objective':'reg:gamma', 'booster':'gbtree', 'base_score':3} # the rest of settings are the same watchlist = [(dtest, 'eval'), (dtrain, 'train')] num_round = 30 # training and evaluation bst = xgb.train(param, dtrain, num_round, watchlist) preds = bst.predict(dtest) labels = dtest.get_label() print('test deviance=%f' % (2 * np.sum((labels - preds) / preds - np.log(labels) + np.log(preds)))) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_205", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/evals_result.html", "title": "This script demonstrate how to access the eval metrics", "page_title": "This script demonstrate how to access the eval metrics — xgboost 3.0.4 documentation", "breadcrumbs": "This script demonstrate how to access the eval metrics", "content": "This script demonstrate how to access the eval metrics import os import xgboost as xgb CURRENT_DIR = os.path.dirname(__file__) dtrain = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train?format=libsvm\") ) dtest = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test?format=libsvm\") ) param = [ (\"max_depth\", 2), (\"objective\", \"binary:logistic\"), (\"eval_metric\", \"logloss\"), (\"eval_metric\", \"error\"), ] num_round = 2 watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] evals_result = {} bst = xgb.train(param, dtrain, num_round, watchlist, evals_result=evals_result) print(\"Access logloss metric directly from evals_result:\") print(evals_result[\"eval\"][\"logloss\"]) print(\"\") print(\"Access metrics through a loop:\") for e_name, e_mtrs in evals_result.items(): print(\"- {}\".format(e_name)) for e_mtr_name, e_mtr_vals in e_mtrs.items(): print(\" - {}\".format(e_mtr_name)) print(\" - {}\".format(e_mtr_vals)) print(\"\") print(\"Access complete dictionary:\") print(evals_result) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_206", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/predict_leaf_indices.html", "title": "Demo for obtaining leaf index", "page_title": "Demo for obtaining leaf index — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for obtaining leaf index", "content": "Demo for obtaining leaf index import os import xgboost as xgb # load data in do training CURRENT_DIR = os.path.dirname(__file__) dtrain = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.train?format=libsvm\") ) dtest = xgb.DMatrix( os.path.join(CURRENT_DIR, \"../data/agaricus.txt.test?format=libsvm\") ) param = {\"max_depth\": 2, \"eta\": 1, \"objective\": \"binary:logistic\"} watchlist = [(dtest, \"eval\"), (dtrain, \"train\")] num_round = 3 bst = xgb.train(param, dtrain, num_round, watchlist) print(\"start testing predict the leaf indices\") # predict using first 2 tree leafindex = bst.predict( dtest, iteration_range=(0, 2), pred_leaf=True, strict_shape=True ) print(leafindex.shape) print(leafindex) # predict all trees leafindex = bst.predict(dtest, pred_leaf=True) print(leafindex.shape) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_207", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/sklearn_parallel.html", "title": "Demo for using xgboost with sklearn", "page_title": "Demo for using xgboost with sklearn — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for using xgboost with sklearn", "content": "Demo for using xgboost with sklearn import multiprocessing from sklearn.datasets import fetch_california_housing from sklearn.model_selection import GridSearchCV import xgboost as xgb if __name__ == \"__main__\": print(\"Parallel Parameter optimization\") X, y = fetch_california_housing(return_X_y=True) # Make sure the number of threads is balanced. xgb_model = xgb.XGBRegressor( n_jobs=multiprocessing.cpu_count() // 2, tree_method=\"hist\" ) clf = GridSearchCV( xgb_model, {\"max_depth\": [2, 4, 6], \"n_estimators\": [50, 100, 200]}, verbose=1, n_jobs=2, ) clf.fit(X, y) print(clf.best_score_) print(clf.best_params_) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_208", "url": "https://xgboost.readthedocs.io/en/stable/python/gpu-examples/cover_type.html", "title": "Using xgboost on GPU devices", "page_title": "Using xgboost on GPU devices — xgboost 3.0.4 documentation", "breadcrumbs": "Using xgboost on GPU devices", "content": "Using xgboost on GPU devices Shows how to train a model on the forest cover type dataset using GPU acceleration. The forest cover type dataset has 581,012 rows and 54 features, making it time consuming to process. We compare the run-time and accuracy of the GPU and CPU histogram algorithms. In addition, The demo showcases using GPU with other GPU-related libraries including cupy and cuml. These libraries are not strictly required. import time import cupy as cp from cuml.model_selection import train_test_split from sklearn.datasets import fetch_covtype import xgboost as xgb # Fetch dataset using sklearn X, y = fetch_covtype(return_X_y=True) X = cp.array(X) y = cp.array(y) y -= y.min() # Create 0.75/0.25 train/test split X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.25, train_size=0.75, random_state=42 ) # Specify sufficient boosting iterations to reach a minimum num_round = 3000 # Leave most parameters as default clf = xgb.XGBClassifier(device=\"cuda\", n_estimators=num_round) # Train model start = time.time() clf.fit(X_train, y_train, eval_set=[(X_test, y_test)]) gpu_res = clf.evals_result() print(\"GPU Training Time: %s seconds\" % (str(time.time() - start))) # Repeat for CPU algorithm clf = xgb.XGBClassifier(device=\"cpu\", n_estimators=num_round) start = time.time() cpu_res = clf.evals_result() print(\"CPU Training Time: %s seconds\" % (str(time.time() - start))) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_209", "url": "https://xgboost.readthedocs.io/en/stable/contrib/release.html", "title": "Versioning Policy", "page_title": "XGBoost Release Policy — xgboost 3.0.4 documentation", "breadcrumbs": "Versioning Policy", "content": "Versioning Policy Starting from XGBoost 1.0.0, each XGBoost release will be versioned as [MAJOR].[FEATURE].[MAINTENANCE] - MAJOR: We guarantee the API compatibility across releases with the same major version number. We expect to have a 1+ years development period for a new MAJOR release version. - FEATURE: We ship new features, improvements and bug fixes through feature releases. The cycle length of a feature is decided by the size of feature roadmap. The roadmap is decided right after the previous release. - MAINTENANCE: Maintenance version only contains bug fixes. This type of release only occurs when we found significant correctness and/or performance bugs and barrier for users to upgrade to a new version of XGBoost smoothly.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_210", "url": "https://xgboost.readthedocs.io/en/stable/contrib/release.html", "title": "Making a Release", "page_title": "XGBoost Release Policy — xgboost 3.0.4 documentation", "breadcrumbs": "Making a Release", "content": "Making a Release - Create an issue for the release, noting the estimated date and expected features or major fixes, pin that issue. - Create a release branch if this is a major release. Bump release version. There’s a helper scriptops/script/change_version.py. - Commit the change, create a PR on GitHub on release branch. Port the bumped version to default branch, optionally with the postfixSNAPSHOT. - Create a tag on release branch, either on GitHub or locally. - Make a release on GitHub tag page, which might be done with previous step if the tag is created on GitHub. - Submit pip, CRAN, and Maven packages.There are helper scripts for automating the process inxgboost/dev/.The pip package is maintained byHyunsu ChoandJiaming Yuan.The CRAN package is maintained byTong HeandJiaming Yuan.The Maven package is maintained byNan ZhuandHyunsu Cho.", "prev_chunk_id": "chunk_209", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_211", "url": "https://xgboost.readthedocs.io/en/stable/contrib/release.html", "title": "R CRAN Package", "page_title": "XGBoost Release Policy — xgboost 3.0.4 documentation", "breadcrumbs": "R CRAN Package", "content": "R CRAN Package Before submitting a release, one should test the package on R-hub and win-builder first. Please note that the R-hub Windows instance doesn’t have the exact same environment as the one hosted on win-builder. According to the CRAN policy: We need to check the number of CPUs used in examples. Export _R_CHECK_EXAMPLE_TIMING_CPU_TO_ELAPSED_THRESHOLD_=2.5 before running R CMD check --as-cran [1] and make sure the machine you are using has enough CPU cores to reveal any potential policy violation.", "prev_chunk_id": "chunk_210", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_212", "url": "https://xgboost.readthedocs.io/en/stable/contrib/release.html", "title": "References", "page_title": "XGBoost Release Policy — xgboost 3.0.4 documentation", "breadcrumbs": "References", "content": "References [1] https://stat.ethz.ch/pipermail/r-package-devel/2022q4/008610.html", "prev_chunk_id": "chunk_211", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_213", "url": "https://xgboost.readthedocs.io/en/stable/contrib/git_guide.html", "title": "Git Workflow Howtos", "page_title": "Git Workflow Howtos — xgboost 3.0.4 documentation", "breadcrumbs": "Git Workflow Howtos", "content": "Git Workflow Howtos Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_214", "url": "https://xgboost.readthedocs.io/en/stable/contrib/git_guide.html", "title": "How to resolve conflict with master", "page_title": "Git Workflow Howtos — xgboost 3.0.4 documentation", "breadcrumbs": "How to resolve conflict with master", "content": "How to resolve conflict with master - First rebase to most recent master# The first two steps can be skipped after you do it once.gitremoteaddupstreamhttps://github.com/dmlc/xgboost gitfetchupstream gitrebaseupstream/master - The git may show some conflicts it cannot merge, sayconflicted.py.Manually modify the file to resolve the conflict.After you resolved the conflict, mark it as resolved bygitaddconflicted.py - Then you can continue rebase bygitrebase--continue - Finally push to your fork, you may need to force push here.gitpush--force", "prev_chunk_id": "chunk_213", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_215", "url": "https://xgboost.readthedocs.io/en/stable/contrib/git_guide.html", "title": "How to combine multiple commits into one", "page_title": "Git Workflow Howtos — xgboost 3.0.4 documentation", "breadcrumbs": "How to combine multiple commits into one", "content": "How to combine multiple commits into one Sometimes we want to combine multiple commits, especially when later commits are only fixes to previous ones, to create a PR with set of meaningful commits. You can do it by following steps. - Before doing so, configure the default editor of git if you haven’t done so before.gitconfigcore.editorthe-editor-you-like - Assume we want to merge last 3 commits, type the following commandsgitrebase-iHEAD~3 - It will pop up an text editor. Set the first commit aspick, and change later ones tosquash. - After you saved the file, it will pop up another text editor to ask you modify the combined commit message. - Push the changes to your fork, you need to force push.gitpush--force", "prev_chunk_id": "chunk_214", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_216", "url": "https://xgboost.readthedocs.io/en/stable/contrib/git_guide.html", "title": "What is the consequence of force push", "page_title": "Git Workflow Howtos — xgboost 3.0.4 documentation", "breadcrumbs": "What is the consequence of force push", "content": "What is the consequence of force push The previous two tips requires force push, this is because we altered the path of the commits. It is fine to force push to your own fork, as long as the commits changed are only yours.", "prev_chunk_id": "chunk_215", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_217", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "XGBoost Internal Feature Map", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Internal Feature Map", "content": "XGBoost Internal Feature Map The following is a reference to the features supported by XGBoost. It is not a beginner’s guide, but rather a list meant to help those looking to add new features to XGBoost understand what needs to be covered.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_218", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Core Features", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Core Features", "content": "Core Features Core features are not dependent on language binding and any language binding can choose to support them.", "prev_chunk_id": "chunk_217", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_219", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Data Storage", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Data Storage", "content": "Data Storage The primary data structure in XGBoost for storing user inputs is DMatrix; it’s a container for all data that XGBoost can use. QuantileDMatrix is a variant specifically designed for the hist tree method. Both can take GPU-based inputs. They take an optional parameter missing to specify which input value should be ignored. For external memory support, please refer to Using XGBoost External Memory Version.", "prev_chunk_id": "chunk_218", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_220", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Single Node Training", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Single Node Training", "content": "Single Node Training There are two different model types in XGBoost: the tree model, which we primarily focus on, and the linear model. For the tree model, we have various methods to build decision trees; please see the Tree Methods for a complete reference. In addition to the tree method, we have many hyper-parameters for tuning the model and injecting prior knowledge into the training process. Two noteworthy examples are monotonic constraints and feature interaction constraints. These two constraints require special treatment during tree construction. Both the hist and the approx tree methods support GPU acceleration. Also, XGBoost GPU supports gradient-based sampling, which supports external-memory data as well. The objective function plays an important role in training. It not only provides the gradient, but also responsible for estimating a good starting point for Newton optimization. Please note that users can define custom objective functions for the task at hand. In addition to numerical features, XGBoost also supports categorical features with two different algorithms, including one-hot encoding and optimal partitioning. For more information, refer to the categorical feature tutorial. The hist and the approx tree methods support categorical features for CPU and GPU. There’s working-in-progress support for vector leaves, which are decision tree leaves that contain multiple values. This type of tree is used to support efficient multi-class and multi-target models.", "prev_chunk_id": "chunk_219", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_221", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Inference", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Inference", "content": "Inference By inference, we specifically mean getting model prediction for the response variable. XGBoost supports two inference methods. The first one is the prediction on the DMatrix object (or QuantileDMatrix, which is a subclass). Using a DMatrix object allows XGBoost to cache the prediction, hence getting faster performance when running prediction on the same data with new trees. The second method is inplace_predict, which bypasses the construction of DMatrix. It’s more efficient but doesn’t support cached prediction. In addtion to returning the estimated response, we also support returning the leaf index, which can be used to analyse the model and as a feature to another model.", "prev_chunk_id": "chunk_220", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_222", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Model IO", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Model IO", "content": "Model IO We have a set of methods for different model serialization methods, including complete serialization, saving to a file, and saving to a buffer. For more, refer to the Introduction to Model IO.", "prev_chunk_id": "chunk_221", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_223", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Model Explanation", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Model Explanation", "content": "Model Explanation XGBoost includes features designed to improve understanding of the model. Here’s a list: - Global feature importance. - SHAP value, including contribution and intervention. - Tree dump. - Tree visualization. - Tree as dataframe. For GPU support, the SHAP value uses the GPUTreeShap project in rapidsai. They all support categorical features, while vector-leaf is still in progress.", "prev_chunk_id": "chunk_222", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_224", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Evaluation", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Evaluation", "content": "Evaluation XGBoost has built-in support for a wide range of metrics, from basic regression to learning to rank and survival modeling. They can handle distributed training and GPU-based acceleration. Custom metrics are supported as well, please see Custom Objective and Evaluation Metric.", "prev_chunk_id": "chunk_223", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_225", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Distributed Training", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed Training", "content": "Distributed Training XGBoost has built-in support for three distributed frameworks, including Dask, PySpark, and Spark (Scala). In addition, there’s flink support for the Java binding and the ray-xgboost project. Please see the respective tutorial on how to use them. By default, XGBoost uses sample-based parallelism for distributed training. The column-based split is still working in progress and needs to be supported in these high-level framework integrations. On top of distributed training, we are also working on federated learning for both sample-based and column-based splits. Distributed training works with custom objective functions and metrics as well. XGBoost aggregates the evaluation result automatically during training. The distributed training is enabled by a built-in implementation of a collective library. It’s based on the RABIT project and has evolved significantly since its early adoption. The collective implementation supports GPU via NCCL, and has variants for handling federated learning and federated learning on GPU. Inference normally doesn’t require any special treatment since we are using sample-based split. However, with column-based data split, we need to initialize the communicator context as well.", "prev_chunk_id": "chunk_224", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_226", "url": "https://xgboost.readthedocs.io/en/stable/contrib/featuremap.html", "title": "Language Bindings", "page_title": "XGBoost Internal Feature Map — xgboost 3.0.4 documentation", "breadcrumbs": "Language Bindings", "content": "Language Bindings We have a list of bindings for various languages. Inside the XGBoost repository, there’s Python, R, Java, Scala, and C. All language bindings are built on top of the C version. Some others, like Julia and Rust, have their own repository. For guideline on adding a new binding, please see Consistency for Language Bindings.", "prev_chunk_id": "chunk_225", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_227", "url": "https://xgboost.readthedocs.io/en/stable/contrib/docs.html", "title": "Documentation and Examples", "page_title": "Documentation and Examples — xgboost 3.0.4 documentation", "breadcrumbs": "Documentation and Examples", "content": "Documentation and Examples Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_228", "url": "https://xgboost.readthedocs.io/en/stable/contrib/docs.html", "title": "Documentation", "page_title": "Documentation and Examples — xgboost 3.0.4 documentation", "breadcrumbs": "Documentation", "content": "Documentation - Python and C documentation is built usingSphinx. - Each document is written inreStructuredText. - The documentation is thedoc/directory. - You can build it locally usingmakehtmlcommand.makehtmlRunmakehelpto learn about the other commands. The online document is hosted by Read the Docs where the imported project is managed by Hyunsu Cho and Jiaming Yuan.", "prev_chunk_id": "chunk_227", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_229", "url": "https://xgboost.readthedocs.io/en/stable/contrib/docs.html", "title": "Build the Python Docs using pip and Conda", "page_title": "Documentation and Examples — xgboost 3.0.4 documentation", "breadcrumbs": "Build the Python Docs using pip and Conda", "content": "Build the Python Docs using pip and Conda - Create a conda environment.condacreate-nxgboost-docs--yespython=3.10NotePython 3.10 is required byxgboost_raypackage. - Activate the environmentcondaactivatexgboost-docs - Install required packages (in the current environment) usingpipcommand.pipinstall-rrequirements.txtNoteIt is currently not possible to install the required packages usingcondadue toxgboost_raybeing unavailable in conda channels.condainstall--filerequirements.txt--yes-cconda-forge - (optional) Installgraphvizcondainstallgraphviz--yes - Eventually, build the docs.makehtml", "prev_chunk_id": "chunk_228", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_230", "url": "https://xgboost.readthedocs.io/en/stable/contrib/docs.html", "title": "Read The Docs", "page_title": "Documentation and Examples — xgboost 3.0.4 documentation", "breadcrumbs": "Read The Docs", "content": "Read The Docs Read the Docs (RTD for short) is an online document hosting service and hosts the XGBoost document site. The document builder used by RTD is relatively lightweight. However some of the packages like the R binding require a compiled XGBoost along with all the optional dependencies to render the document. As a result, both jvm-based packages and the R package’s document is built with an independent CI pipeline and fetched during online document build. The sphinx configuration file xgboost/doc/conf.py acts as the fetcher. During build, the fetched artifacts are stored in xgboost/doc/tmp/jvm_docs and xgboost/doc/tmp/r_docs respectively. For the R package, there’s a dummy index file in xgboost/doc/R-package/r_docs . Jvm doc is similar. As for the C doc, it’s generated using doxygen and processed by breathe during build as it’s relatively cheap. The generated xml files are stored in xgboost/doc/tmp/dev . The xgboost/doc/tmp is part of the html_extra_path sphinx configuration specified in the conf.py file, which informs sphinx to copy the extracted html files to the build directory. Following is a list of environment variables used by the fetchers in conf.py: As of writing, RTD doesn’t provide any facility to be embedded as a GitHub action but we need a way to specify the dependency between the CI pipelines and the document build in order to fetch the correct artifact. The workaround is to use an extra GA step to notify RTD using its REST API.", "prev_chunk_id": "chunk_229", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_231", "url": "https://xgboost.readthedocs.io/en/stable/contrib/docs.html", "title": "Examples", "page_title": "Documentation and Examples — xgboost 3.0.4 documentation", "breadcrumbs": "Examples", "content": "Examples - Use cases and examples are indemodirectory. - We are super excited to hear about your story. If you have blog posts, tutorials, or code solutions using XGBoost, please tell us, and we will add a link in the example pages.", "prev_chunk_id": "chunk_230", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_232", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "Adding and running tests", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "Adding and running tests", "content": "Adding and running tests A high-quality suite of tests is crucial in ensuring correctness and robustness of the codebase. Here, we provide instructions how to run unit tests, and also how to add a new one. Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_233", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "Python package: pytest", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "Python package: pytest", "content": "Python package: pytest Add your test under the directories - tests/python/ - tests/python-gpu/(if you are testing GPU code) - tests/test_distributed. (if a distributed framework is used) Refer to the PyTest tutorial to learn how to write tests for Python code. You may try running your test by following instructions in this section.", "prev_chunk_id": "chunk_232", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_234", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "C++: Google Test", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "C++: Google Test", "content": "C++: Google Test Add your test under the directory tests/cpp/. Refer to this excellent tutorial on using Google Test. You may try running your test by following instructions in this section. Note. Google Test version 1.8.1 or later is required.", "prev_chunk_id": "chunk_233", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_235", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "JVM packages: JUnit / scalatest", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "JVM packages: JUnit / scalatest", "content": "JVM packages: JUnit / scalatest The JVM packages for XGBoost (XGBoost4J / XGBoost4J-Spark) use the Maven Standard Directory Layout. Specifically, the tests for the JVM packages are located in the following locations: - jvm-packages/xgboost4j/src/test/ - jvm-packages/xgboost4j-spark/src/test/ To write a test for Java code, see JUnit 5 tutorial. To write a test for Scala, see Scalatest tutorial. You may try running your test by following instructions in this section.", "prev_chunk_id": "chunk_234", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_236", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "R package: testthat", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "R package: testthat", "content": "R package: testthat Add your test under the directory R-package/tests/testthat. Refer to this excellent tutorial on testthat. You may try running your test by following instructions in this section.", "prev_chunk_id": "chunk_235", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_237", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "R package", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "R package", "content": "R package Run python ./ops/script/test_r_package.py --task=check at the root of the project directory. The command builds and checks the XGBoost r-package. Alternatively, if you want to just run the tests, you can use the following commands after installing XGBoost: cd R-package/tests/ Rscript testthat.R", "prev_chunk_id": "chunk_236", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_238", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "JVM packages", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "JVM packages", "content": "JVM packages Maven is used mvn test", "prev_chunk_id": "chunk_237", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_239", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "Python package: pytest", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "Python package: pytest", "content": "Python package: pytest To run Python unit tests, first install pytest package: pip3 install pytest Then compile XGBoost according to instructions in Building the Shared Library. Finally, invoke pytest at the project root directory: # Tell Python where to find XGBoost module export PYTHONPATH=./python-package pytest -v -s --fulltrace tests/python In addition, to test CUDA code, run: # Tell Python where to find XGBoost module export PYTHONPATH=./python-package pytest -v -s --fulltrace tests/python-gpu (For this step, you should have compiled XGBoost with CUDA enabled.) For testing with distributed frameworks like Dask and PySpark: # Tell Python where to find XGBoost module export PYTHONPATH=./python-package pytest -v -s --fulltrace tests/test_distributed", "prev_chunk_id": "chunk_238", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_240", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "C++: Google Test", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "C++: Google Test", "content": "C++: Google Test To build and run C++ unit tests enable tests while running CMake: cmake -B build -S . -GNinja -DGOOGLE_TEST=ON -DUSE_DMLC_GTEST=ON -DUSE_CUDA=ON -DUSE_NCCL=ON cmake --build build cd ./build ./testxgboost Flags like USE_CUDA, USE_DMLC_GTEST are optional. For more info about how to build XGBoost from source, see Building From Source. One can also run all unit tests using ctest tool which provides higher flexibility. For example: ctest --verbose If you need to debug errors on Windows using the debugger from VS, you can append the gtest flags in test_main.cc: ::testing::GTEST_FLAG(filter) = \"Suite.Test\"; ::testing::GTEST_FLAG(repeat) = 10;", "prev_chunk_id": "chunk_239", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_241", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "Sanitizers: Detect memory errors and data races", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "Sanitizers: Detect memory errors and data races", "content": "Sanitizers: Detect memory errors and data races By default, sanitizers are bundled in GCC and Clang/LLVM. One can enable sanitizers with GCC >= 4.8 or LLVM >= 3.1, But some distributions might package sanitizers separately. Here is a list of supported sanitizers with corresponding library names: - Address sanitizer: libasan - Undefined sanitizer: libubsan - Leak sanitizer: liblsan - Thread sanitizer: libtsan Memory sanitizer is exclusive to LLVM, hence not supported in XGBoost. With latest compilers like gcc-9, when sanitizer flags are specified, the compiler driver should be able to link the runtime libraries automatically.", "prev_chunk_id": "chunk_240", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_242", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "How to build XGBoost with sanitizers", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "How to build XGBoost with sanitizers", "content": "How to build XGBoost with sanitizers One can build XGBoost with sanitizer support by specifying -DUSE_SANITIZER=ON. By default, address sanitizer and leak sanitizer are used when you turn the USE_SANITIZER flag on. You can always change the default by providing a semicolon separated list of sanitizers to ENABLED_SANITIZERS. Note that thread sanitizer is not compatible with the other two sanitizers. cmake -DUSE_SANITIZER=ON -DENABLED_SANITIZERS=\"address;undefined\" /path/to/xgboost By default, CMake will search regular system paths for sanitizers, you can also supply a specified SANITIZER_PATH. cmake -DUSE_SANITIZER=ON -DENABLED_SANITIZERS=\"address;undefined\" \\ -DSANITIZER_PATH=/path/to/sanitizers /path/to/xgboost", "prev_chunk_id": "chunk_241", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_243", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "How to use sanitizers with CUDA support", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "How to use sanitizers with CUDA support", "content": "How to use sanitizers with CUDA support Running XGBoost on CUDA with address sanitizer (asan) will raise memory error. To use asan with CUDA correctly, you need to configure asan via ASAN_OPTIONS environment variable: ASAN_OPTIONS=protect_shadow_gap=0 ${BUILD_DIR}/testxgboost", "prev_chunk_id": "chunk_242", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_244", "url": "https://xgboost.readthedocs.io/en/stable/contrib/unit_tests.html", "title": "Other sanitizer runtime options", "page_title": "Adding and running tests — xgboost 3.0.4 documentation", "breadcrumbs": "Other sanitizer runtime options", "content": "Other sanitizer runtime options By default undefined sanitizer doesn’t print out the backtrace. You can enable it by exporting environment variable: UBSAN_OPTIONS=print_stacktrace=1 ${BUILD_DIR}/testxgboost For details, please consult official documentation for sanitizers.", "prev_chunk_id": "chunk_243", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_245", "url": "https://xgboost.readthedocs.io/en/stable/contrib/python_packaging.html", "title": "How to build binary wheels and source distributions", "page_title": "Notes on packaging XGBoost’s Python package — xgboost 3.0.4 documentation", "breadcrumbs": "How to build binary wheels and source distributions", "content": "How to build binary wheels and source distributions Wheels and source distributions (sdist for short) are the two main mechanisms for packaging and distributing Python packages. - Asource distribution(sdist) is a tarball (.tar.gzextension) that contains the source code. - Awheelis a ZIP-compressed archive (with.whlextension) representing abuiltdistribution. Unlike an sdist, a wheel can contain compiled components. The compiled components are compiled prior to distribution, making it more convenient for end-users to install a wheel. Wheels containing compiled components are referred to asbinary wheels. See Python Packaging User Guide to learn more about how Python packages in general are packaged and distributed. For the remainder of this document, we will focus on packaging and distributing XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_246", "url": "https://xgboost.readthedocs.io/en/stable/contrib/python_packaging.html", "title": "Building sdists", "page_title": "Notes on packaging XGBoost’s Python package — xgboost 3.0.4 documentation", "breadcrumbs": "Building sdists", "content": "Building sdists In the case of XGBoost, an sdist contains both the Python code as well as the C++ code, so that the core part of XGBoost can be compiled into the shared library libxgboost.so [1]. You can obtain an sdist as follows: $ python -m build --sdist . (You’ll need to install the build package first: pip install build or conda install python-build.) Running pip install with an sdist will launch CMake and a C++ compiler to compile the bundled C++ code into libxgboost.so: $ pip install -v xgboost-2.0.0.tar.gz # Add -v to show build progress", "prev_chunk_id": "chunk_245", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_247", "url": "https://xgboost.readthedocs.io/en/stable/contrib/python_packaging.html", "title": "Building binary wheels", "page_title": "Notes on packaging XGBoost’s Python package — xgboost 3.0.4 documentation", "breadcrumbs": "Building binary wheels", "content": "Building binary wheels You can also build a wheel as follows: $ pip wheel --no-deps -v . Notably, the resulting wheel contains a copy of the shared library libxgboost.so [1]. The wheel is a binary wheel, since it contains a compiled binary. Running pip install with the binary wheel will extract the content of the wheel into the current Python environment. Since the wheel already contains a pre-built copy of libxgboost.so, it does not have to be built at the time of install. So pip install with the binary wheel completes quickly: $ pip install xgboost-2.0.0-py3-none-linux_x86_64.whl # Completes quickly Footnotes", "prev_chunk_id": "chunk_246", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_248", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Consistency for Language Bindings", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Consistency for Language Bindings", "content": "Consistency for Language Bindings XGBoost has many different language bindings developed over the years, some are in the main repository while others live independently. Many features and interfaces are inconsistent with each others, this document aims to provide some guidelines and actionable items for language binding designers.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_249", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Model Serialization", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Model Serialization", "content": "Model Serialization XGBoost C API exposes a couple functions for serializing a model for persistence storage. These saved files are backward compatible, meaning one can load an older XGBoost model with a newer XGBoost version. If there’s change in the model format, we have deprecation notice inside the C++ implementation and public issue for tracking the status. See Introduction to Model IO for details. As a result, these are considered to be stable and should work across language bindings. For instance, a model trained in R should be fully functioning in C or Python. Please don’t pad anything to the output file or buffer. If there are extra fields that must be saved: - First review whether the attribute can be retrieved from known properties of the model. For instance, there’s aclasses_attribute in the scikit-learn interfaceXGBClassifier, which can be obtained throughnumpy.arange(n_classes)and doesn’t need to be saved into the model. Preserving version compatibility is not a trivial task and we are still spending a significant amount of time to maintain it. Please don’t make complication if it’s not necessary. - Then please consider whether it’s universal. For instance, we have addedfeature_typesto the model serialization for categorical features (which is a new feature after 1.6), the attribute is useful or will be useful in the future regardless of the language binding. - If the field is small, we can save it as model attribute (which is a key-value structure). These attributes are ignored by all other language bindings and mostly an ad-hoc storage. - Lastly, we should use the UBJSON as the default output format when given a chance (not to be burdened by the old binary format).", "prev_chunk_id": "chunk_248", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_250", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Training Continuation", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Training Continuation", "content": "Training Continuation There are cases where we want to train a model based on the previous model, for boosting trees, it’s either adding new trees or modifying the existing trees. This can be normal model update, error recovery, or other special cases we don’t know of yet. When it happens, the training iteration should start from 0, not from the last boosted rounds of the model. 0 is a special iteration number, we perform some extra checks like whether the label is valid during that iteration. These checks can be expensive but necessary for eliminating silent errors. Keeping the iteration starts from zero allows us to perform these checks only once for each input data.", "prev_chunk_id": "chunk_249", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_251", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Inference", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Inference", "content": "Inference The inference function is quite inconsistent among language bindings at the time of writing due to historical reasons, but this makes more important for us to have consistency in mind in the future development. - Firstly, it’s the output shape. There’s a relatively new parameter calledstrict_shapein XGBoost and is rarely used. We want to make it as the default behavior but couldn’t due to compatibility concerns. SeePredictionfor details. In short, if specified, XGBoost C++ implementation can output prediction with the correct shape, instead of letting the language binding to handle it. - Policy around early stopping is at the moment inconsistent between various interfaces. Some considers thebest_iterationattribute while others don’t. We should formalize that all interfaces in the future should use thebest_iterationduring inference unless user has explicitly specified theiteration_rangeparameter.", "prev_chunk_id": "chunk_250", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_252", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Parameter naming", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Parameter naming", "content": "Parameter naming There are many parameter naming conventions out there, Some XGBoost interfaces try to align with the larger communities. For example, the R package might support parameters naming like max.depth=3, while the Spark package might support MaxDepth=3. These are fine, it’s better for the users to keep their pipeline consistent. However, while supporting naming variants, the normal, XGBoost way of naming should also be supported, meaning max_depth=3 should be a valid parameter no-matter what language one is using. If someone were to write duplicated parameter max.depth=3, max_depth=3, a clear error should be preferred instead of prioritizing one over the other.", "prev_chunk_id": "chunk_251", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_253", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Default Parameters", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Default Parameters", "content": "Default Parameters Like many other machine learning libraries, all parameters from XGBoost can either be inferred from the data or have default values. Bindings should not make copies of these default values and let the XGBoost core decide. When the parameter key is not passed into the C++ core, XGBoost will pick the default accordingly. These defaults are not necessarily optimal, but they are there for consistency. If there’s a new choice of default parameter, we can change it inside the core and it will be automatically propagated to all bindings. Given the same set of parameters and data, various bindings should strive to produce the same model. One exception is the num_boost_rounds, which exists only in high-level bindings and has various alias like n_estimators. Its default value is close to arbitrary at the moment, we haven’t been able to get a good default yet.", "prev_chunk_id": "chunk_252", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_254", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Logging", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Logging", "content": "Logging XGBoost has a default logger builtin that can be a wrapper over binding-specific logging facility. For instance, the Python binding registers a callback to use Python warnings and print() function to output logging. We want to keep logging native to the larger communities instead of using the std::cerr from C++.", "prev_chunk_id": "chunk_253", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_255", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Minimum Amount of Data Manipulation", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Minimum Amount of Data Manipulation", "content": "Minimum Amount of Data Manipulation XGBoost is mostly a machine learning library providing boosting algorithm implementation. Some other implementations might perform some sort of data manipulation implicitly like deciding the coding of the data, and transforming the data according to some heuristic before training. We prefer to keep these operations based on necessities instead of convenience to keep the scope of the project well-defined. Whenever possible, we should leave these features to 3-party libraries and consider how a user can compose their pipeline. For instance, XGBoost itself should not perform ordinal encoding for categorical data, users will pick an encoder that fits their use cases (like out-of-core implementation, distributed implementation, known mapping, etc). If some transformations are decided to be part of the algorithm, we can have it inside the core instead of the language binding. Examples would be target-encoding or sketching the response variables. If we were to support them, we could have it inside the core implementation as part of the ML algorithm. This aligns with the same principles of default parameters, various bindings should provide similar (if not the same) results given the same set of parameters and data.", "prev_chunk_id": "chunk_254", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_256", "url": "https://xgboost.readthedocs.io/en/stable/contrib/consistency.html", "title": "Feature Info", "page_title": "Consistency for Language Bindings — xgboost 3.0.4 documentation", "breadcrumbs": "Feature Info", "content": "Feature Info XGBoost accepts data structures that contain meta info about predictors, including the names and types of features. Example inputs are pandas.DataFrame, R data.frame. We have the following heuristics: - When the input data structure contains such information, we set the feature_names and feature_types for DMatrix accordingly. - When a user provides this information as explicit parameters, the user-provided version should override the one provided by the data structure. - When both sources are missing, the DMatrix class contain empty info.", "prev_chunk_id": "chunk_255", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_257", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Coding Guideline", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Coding Guideline", "content": "Coding Guideline Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_258", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "C++ Coding Guideline", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "C++ Coding Guideline", "content": "C++ Coding Guideline - FollowGoogle style for C++, with two exceptions:Each line of text may contain up to 100 characters.The use of C++ exceptions is allowed. - Use C++17 features such as smart pointers, braced initializers, lambda functions, andstd::thread. - Use Doxygen to document all the interface code. - We have some comments around symbols imported by headers, some of those are hinted byinclude-what-you-use. It’s not required. - We use clang-tidy and clang-format. You can check their configuration in the root directory of the XGBoost source tree. - We have a series of automatic checks to ensure that all of our codebase complies with the Google style. Before submitting your pull request, you are encouraged to run the style checks on your machine. SeeR Coding Guideline.", "prev_chunk_id": "chunk_257", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_259", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Python Coding Guideline", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Python Coding Guideline", "content": "Python Coding Guideline - FollowPEP 8: Style Guide for Python Code. We use Pylint to automatically enforce PEP 8 style across our Python codebase. Before submitting your pull request, you are encouraged to run Pylint on your machine. SeeR Coding Guideline. - Docstrings should be inNumPy docstring format.", "prev_chunk_id": "chunk_258", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_260", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Code Style", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Code Style", "content": "Code Style - We follow Google’s C++ Style guide for C++ code.This is mainly to be consistent with the rest of the project.Another reason is we will be able to check style automatically with a linter. - When needed, you can disable the linter warning of certain line with//NOLINT(*)comments. - We useroxygenfor documenting the R package.", "prev_chunk_id": "chunk_259", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_261", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Rmarkdown Vignettes", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Rmarkdown Vignettes", "content": "Rmarkdown Vignettes Rmarkdown vignettes are placed in R-package/vignettes. These Rmarkdown files are not compiled. We host the compiled version on doc/R-package. The following steps are followed to add a new Rmarkdown vignettes: - Add the original rmarkdown toR-package/vignettes. - Modifydoc/R-package/Makefileto add the markdown files to be build. - Clone thedmlc/web-datarepo to folderdoc. - Now type the following command ondoc/R-package:makethe-markdown-to-make.md - This will generate the markdown, as well as the figures indoc/web-data/xgboost/knitr. - Modify thedoc/R-package/index.mdto point to the generated markdown. - Add the generated figure to thedmlc/web-datarepo.If you already cloned the repo to doc, this meansgitadd - Create PR for both the markdown anddmlc/web-data. - You can also build the document locally by typing the following command at thedocdirectory:makehtml The reason we do this is to avoid exploded repo size due to generated images.", "prev_chunk_id": "chunk_260", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_262", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "R package versioning", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "R package versioning", "content": "R package versioning See XGBoost Release Policy.", "prev_chunk_id": "chunk_261", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_263", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Testing R package with different compilers", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Testing R package with different compilers", "content": "Testing R package with different compilers You can change the default compiler of R by changing the configuration file in home directory. For instance, if you want to test XGBoost built with clang++ instead of g++ on Linux, put the following in your ~/.R/Makevars file: CC=clang-15 CXX17=clang++-15 Be aware that the variable name should match with the name used by R CMD: R CMD config CXX17", "prev_chunk_id": "chunk_262", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_264", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Registering native routines in R", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Registering native routines in R", "content": "Registering native routines in R According to R extension manual, it is good practice to register native routines and to disable symbol search. When any changes or additions are made to the C++ interface of the R package, please make corresponding changes in src/init.c as well.", "prev_chunk_id": "chunk_263", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_265", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Generating the Package and Running Tests", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Generating the Package and Running Tests", "content": "Generating the Package and Running Tests The source layout of XGBoost is a bit unusual to normal R packages as XGBoost is primarily written in C++ with multiple language bindings in mind. As a result, some special cares need to be taken to generate a standard R tarball. Most of the tests are being run on CI, and as a result, the best way to see how things work is by looking at the CI configuration files (GitHub action, at the time of writing). There are helper scripts in ops/script and R-package/tests/helper_scripts for running various checks including linter and making the standard tarball.", "prev_chunk_id": "chunk_264", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_266", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Running Formatting Checks Locally", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Running Formatting Checks Locally", "content": "Running Formatting Checks Locally Once you submit a pull request to dmlc/xgboost, we perform two automatic checks to enforce coding style conventions. To expedite the code review process, you are encouraged to run the checks locally on your machine prior to submitting your pull request.", "prev_chunk_id": "chunk_265", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_267", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Linter", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Linter", "content": "Linter We use a combination of linters to enforce style convention and find potential errors. Linting is especially useful for scripting languages like Python, as we can catch many errors that would have otherwise occurred at run-time. For Python scripts, pylint, black and isort are used for providing guidance on coding style, and mypy is required for type checking. For C++, cpplint is used along with clang-tidy. For R, lintr is used. To run checks for Python locally, install the checkers mentioned previously and run: cd /path/to/xgboost/ python ./ops/script/lint_python.py --fix To run checks for R: cd /path/to/xgboost/ R CMD INSTALL R-package/ Rscript ops/script/lint_r.R $(pwd) To run checks for cpplint locally: cd /path/to/xgboost/ python ./ops/script/lint_cpp.py See next section for clang-tidy. For CMake scripts: bash ./ops/script/lint_cmake.sh Lastly, the linter for jvm-packages is integrated into the maven build process.", "prev_chunk_id": "chunk_266", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_268", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Clang-tidy", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Clang-tidy", "content": "Clang-tidy Clang-tidy is an advance linter for C++ code, made by the LLVM team. We use it to conform our C++ codebase to modern C++ practices and conventions. To run this check locally, run the following command from the top level source tree: cd /path/to/xgboost/ python3 ops/script/run_clang_tidy.py Also, the script accepts two optional integer arguments, namely --cpp and --cuda. By default they are both set to 1, meaning that both C++ and CUDA code will be checked. If the CUDA toolkit is not installed on your machine, you’ll encounter an error. To exclude CUDA source from linting, use: cd /path/to/xgboost/ python3 ops/script/run_clang_tidy.py --cuda=0 Similarly, if you want to exclude C++ source from linting: cd /path/to/xgboost/ python3 ops/script/run_clang_tidy.py --cpp=0", "prev_chunk_id": "chunk_267", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_269", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Guide for handling user input data", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Guide for handling user input data", "content": "Guide for handling user input data This is an in-comprehensive guide for handling user input data. XGBoost has wide verity of native supported data structures, mostly come from higher level language bindings. The inputs ranges from basic contiguous 1 dimension memory buffer to more sophisticated data structures like columnar data with validity mask. Raw input data can be used in 2 places, firstly it’s the construction of various DMatrix, secondly it’s the in-place prediction. For plain memory buffer, there’s not much to discuss since it’s just a pointer with a size. But for general n-dimension array and columnar data, there are many subtleties. XGBoost has 3 different data structures for handling optionally masked arrays (tensors), for consuming user inputs ArrayInterface should be chosen. There are many existing functions that accept only plain pointer due to legacy reasons (XGBoost started as a much simpler library and didn’t care about memory usage that much back then). The ArrayInterface is a in memory representation of __array_interface__ protocol defined by numpy or the __cuda_array_interface__ defined by numba. Following is a check list of things to have in mind when accepting related user inputs: - [ ] Is it strided? (identified by thestridesfield) - [ ] If it’s a vector, is it row vector or column vector? (Identified by bothshapeandstrides). - [ ] Is the data type supported? Half type and 128 integer types should be converted before going into XGBoost. - [ ] Does it have higher than 1 dimension? (identified byshapefield) - [ ] Are some of dimensions trivial? (shape[dim] <= 1) - [ ] Does it have mask? (identified bymaskfield) - [ ] Can the mask be broadcasted? (unsupported at the moment) - [ ] Is it on CUDA memory? (identified bydatafield, and optionallystream) Most of the checks are handled by the", "prev_chunk_id": "chunk_268", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_270", "url": "https://xgboost.readthedocs.io/en/stable/contrib/coding_guide.html", "title": "Guide for handling user input data", "page_title": "Coding Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Guide for handling user input data", "content": "ArrayInterface during construction, except for the data type issue since it doesn’t know how to cast such pointers with C builtin types. But for safety reason one should still try to write related tests for the all items. The data type issue should be taken care of in language binding for each of the specific data input. For single-chunk columnar format, it’s just a masked array for each column so it should be treated uniformly as normal array. For input predictor X, we have adapters for each type of input. Some are composition of the others. For instance, CSR matrix has 3 potentially strided arrays for indptr, indices and values. No assumption should be made to these components (all the check boxes should be considered). Slicing row of CSR matrix should calculate the offset of each field based on respective strides. For meta info like labels, which is growing both in size and complexity, we accept only masked array at the moment (no specialized adapter). One should be careful about the input data shape. For base margin it can be 2 dim or higher if we have multiple targets in the future. The getters in DMatrix returns only 1 dimension flatten vectors at the moment, which can be improved in the future when it’s needed.", "prev_chunk_id": "chunk_269", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_271", "url": "https://xgboost.readthedocs.io/en/stable/contrib/donate.html", "title": "Motivation", "page_title": "Donations — xgboost 3.0.4 documentation", "breadcrumbs": "Motivation", "content": "Motivation DMLC/XGBoost has grown from a research project incubated in academia to one of the most widely used gradient boosting framework in production environment. On one side, with the growth of volume and variety of data in the production environment, users are putting accordingly growing expectation to XGBoost in terms of more functions, scalability and robustness. On the other side, as an open source project which develops in a fast pace, XGBoost has been receiving contributions from many individuals and organizations around the world. Given the high expectation from the users and the increasing channels of contribution to the project, delivering the high quality software presents a challenge to the project maintainers. A robust and efficient continuous integration (CI) infrastructure is one of the most critical solutions to address the above challenge. A CI service will monitor an open-source repository and run a suite of integration tests for every incoming contribution. This way, the CI ensures that every proposed change in the codebase is compatible with existing functionalities. Furthermore, XGBoost can enable more thorough tests with a powerful CI infrastructure to cover cases which are closer to the production environment. There are several CI services available free to open source projects, such as Travis CI and AppVeyor. The XGBoost project already utilizes GitHub Actions. However, the XGBoost project has needs that these free services do not adequately address. In particular, the limited usage quota of resources such as CPU and memory leaves XGBoost developers unable to bring “too-intensive” tests. In addition, they do not offer test machines with GPUs for testing XGBoost-GPU code base which has been attracting more and more interest across many organizations. Consequently, the XGBoost project uses a cloud-hosted test farm. We host Amazon Web Services (AWS) to host the test machines, along with GitHub Actions and", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_272", "url": "https://xgboost.readthedocs.io/en/stable/contrib/donate.html", "title": "Motivation", "page_title": "Donations — xgboost 3.0.4 documentation", "breadcrumbs": "Motivation", "content": "RunsOn (SaaS app) to organize the CI pipelines. The cloud-hosted test farm has recurring operating expenses. RunsOn launches worker machines on AWS on demand to run the test suite on incoming contributions. To save cost, the worker machines are terminated when they are no longer needed. To help defray the hosting cost, the XGBoost project seeks donations from third parties.", "prev_chunk_id": "chunk_271", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_273", "url": "https://xgboost.readthedocs.io/en/stable/contrib/donate.html", "title": "Donations and Sponsorships", "page_title": "Donations — xgboost 3.0.4 documentation", "breadcrumbs": "Donations and Sponsorships", "content": "Donations and Sponsorships Donors may choose to make one-time donations or recurring donations on monthly or yearly basis. Donors who commit to the Sponsor tier will have their logo displayed on the front page of the XGBoost project.", "prev_chunk_id": "chunk_272", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_274", "url": "https://xgboost.readthedocs.io/en/stable/contrib/donate.html", "title": "Fiscal host: Open Source Collective 501(c)(6)", "page_title": "Donations — xgboost 3.0.4 documentation", "breadcrumbs": "Fiscal host: Open Source Collective 501(c)(6)", "content": "Fiscal host: Open Source Collective 501(c)(6) The Project Management Committee (PMC) of the XGBoost project appointed Open Source Collective as their fiscal host. The platform is a 501(c)(6) registered entity and will manage the funds on the behalf of the PMC so that PMC members will not have to manage the funds directly. The platform currently hosts several well-known JavaScript frameworks such as Babel, Vue, and Webpack. All expenses incurred for hosting CI will be submitted to the fiscal host with receipts. Only the expenses in the following categories will be approved for reimbursement: - Cloud expenses for the cloud test farm - Cost of domainhttps://xgboost-ci.net - Annual subscription for RunsOn", "prev_chunk_id": "chunk_273", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_275", "url": "https://xgboost.readthedocs.io/en/stable/contrib/donate.html", "title": "Administration of cloud CI infrastructure", "page_title": "Donations — xgboost 3.0.4 documentation", "breadcrumbs": "Administration of cloud CI infrastructure", "content": "Administration of cloud CI infrastructure The PMC shall appoint committer(s) to administer the cloud CI infrastructure on their behalf. The current administrators are as follows: - Primary administrator:Hyunsu Cho - Secondary administrator:Jiaming Yuan The administrators shall make good-faith effort to keep the CI expenses under control. The expenses shall not exceed the available funds. The administrators should post regular updates on CI expenses.", "prev_chunk_id": "chunk_274", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_276", "url": "https://xgboost.readthedocs.io/en/stable/contrib/community.html", "title": "XGBoost Community Guideline", "page_title": "XGBoost Community Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Community Guideline", "content": "XGBoost Community Guideline XGBoost adopts the Apache style model and governs by merit. We believe that it is important to create an inclusive community where everyone can use, contribute to, and influence the direction of the project. See CONTRIBUTORS.md for the current list of contributors.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_277", "url": "https://xgboost.readthedocs.io/en/stable/contrib/community.html", "title": "General Development Process", "page_title": "XGBoost Community Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "General Development Process", "content": "General Development Process Everyone in the community is welcomed to send patches, documents, and propose new directions to the project. The key guideline here is to enable everyone in the community to get involved and participate the decision and development. When major changes are proposed, an RFC should be sent to allow discussion by the community. We encourage public discussion, archivable channels such as issues and discuss forum, so that everyone in the community can participate and review the process later. Code reviews are one of the key ways to ensure the quality of the code. High-quality code reviews prevent technical debt for long-term and are crucial to the success of the project. A pull request needs to be reviewed before it gets merged. A committer who has the expertise of the corresponding area would moderate the pull request and then merge the code when it is ready. The corresponding committer could request multiple reviewers who are familiar with the area of the code. We encourage contributors to request code reviews themselves and help review each other’s code – remember everyone is volunteering their time to the community, high-quality code review itself costs as much as the actual code contribution, you could get your code quickly reviewed if you do others the same favor. The community should strive to reach a consensus on technical decisions through discussion. We expect committers and PMCs to moderate technical discussions in a diplomatic way, and provide suggestions with clear technical reasoning when necessary.", "prev_chunk_id": "chunk_276", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_278", "url": "https://xgboost.readthedocs.io/en/stable/contrib/community.html", "title": "Committers", "page_title": "XGBoost Community Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Committers", "content": "Committers Committers are individuals who are granted the write access to the project. A committer is usually responsible for a certain area or several areas of the code where they oversee the code review process. The area of contribution can take all forms, including code contributions and code reviews, documents, education, and outreach. Committers are essential for a high quality and healthy project. The community actively look for new committers from contributors. Here is a list of useful traits that help the community to recognize potential committers: - Sustained contribution to the project, demonstrated by discussion over RFCs, code reviews and proposals of new features, and other development activities. Being familiar with, and being able to take ownership on one or several areas of the project. - Quality of contributions: High-quality, readable code contributions indicated by pull requests that can be merged without a substantial code review. History of creating clean, maintainable code and including good test cases. Informative code reviews to help other contributors that adhere to a good standard. - Community involvement: active participation in the discussion forum, promote the projects via tutorials, talks and outreach. We encourage committers to collaborate broadly, e.g. do code reviews and discuss designs with community members that they do not interact physically. The Project Management Committee(PMC) consists of a group of active committers that moderate the discussion, manage the project release, and proposes new committer/PMC members. Potential candidates are usually proposed via an internal discussion among PMCs, followed by a consensus approval, i.e. least 3 +1 votes, and no vetoes. Any veto must be accompanied by reasoning. PMCs should serve the community by upholding the community practices and guidelines in order to make XGBoost a better community for everyone. PMCs should strive to only nominate new candidates outside of their own organization.", "prev_chunk_id": "chunk_277", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_279", "url": "https://xgboost.readthedocs.io/en/stable/contrib/community.html", "title": "Committers", "page_title": "XGBoost Community Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Committers", "content": "The PMC is in charge of the project’s continuous integration (CI) and testing infrastructure. Currently, we host our own Jenkins server at https://xgboost-ci.net. The PMC shall appoint committer(s) to manage the CI infrastructure. The PMC may accept 3rd-party donations and sponsorships that would defray the cost of the CI infrastructure. See Donations.", "prev_chunk_id": "chunk_278", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_280", "url": "https://xgboost.readthedocs.io/en/stable/contrib/community.html", "title": "Reviewers", "page_title": "XGBoost Community Guideline — xgboost 3.0.4 documentation", "breadcrumbs": "Reviewers", "content": "Reviewers Reviewers are individuals who actively contributed to the project and are willing to participate in the code review of new contributions. We identify reviewers from active contributors. The committers should explicitly solicit reviews from reviewers. High-quality code reviews prevent technical debt for the long-term and are crucial to the success of the project. A pull request to the project has to be reviewed by at least one reviewer in order to be merged.", "prev_chunk_id": "chunk_279", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_281", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost_spark_migration.html", "title": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x", "page_title": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x — xgboost 3.0.4 documentation", "breadcrumbs": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x", "content": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x XGBoost4j-Spark jvm packages underwent significant modifications in version 3.0, which may cause compatibility issues with existing user code. This guide will walk you through the process of updating your code to ensure it’s compatible with XGBoost4j-Spark 3.0 and later versions.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_282", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost_spark_migration.html", "title": "XGBoost4j Spark Packages", "page_title": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost4j Spark Packages", "content": "XGBoost4j Spark Packages XGBoost4j-Spark 3.0 has assembled xgboost4j package into xgboost4j-spark_2.12-3.0.0.jar, which means you can now simply use xgboost4j-spark for your application. - For CPU<dependency><groupId>ml.dmlc</groupId><artifactId>xgboost4j-spark_${scala.binary.version}</artifactId><version>3.0.0</version></dependency> - For GPU<dependency><groupId>ml.dmlc</groupId><artifactId>xgboost4j-spark-gpu_${scala.binary.version}</artifactId><version>3.0.0</version></dependency> When submitting the XGBoost application to the Spark cluster, you only need to specify the single xgboost4j-spark package. - For CPUspark-submit\\--jarsxgboost4j-spark_2.12-3.0.0.jar\\...\\ - For GPUspark-submit\\--jarsxgboost4j-spark-gpu_2.12-3.0.0.jar\\...\\", "prev_chunk_id": "chunk_281", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_283", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost_spark_migration.html", "title": "XGBoost Ranking", "page_title": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Ranking", "content": "XGBoost Ranking Learning to rank using XGBoostRegressor has been replaced by a dedicated XGBoostRanker, which is specifically designed to support ranking algorithms. // before xgboost4j-spark 3.0 val regressor = new XGBoostRegressor().setObjective(\"rank:ndcg\") // after xgboost4j-spark 3.0 val ranker = new XGBoostRanker()", "prev_chunk_id": "chunk_282", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_284", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost_spark_migration.html", "title": "Removed Parameters", "page_title": "Migration Guide: How to migrate to XGBoost4j-Spark jvm 3.x — xgboost 3.0.4 documentation", "breadcrumbs": "Removed Parameters", "content": "Removed Parameters Starting from xgboost4j-spark 3.0, below parameters are removed. - cacheTrainingSetIf you wish to cache the training dataset, you have the option to implement caching in your code prior to fitting the data to an estimator.valdf=input.cache()valmodel=newXGBoostClassifier().fit(df) - trainTestRatioThe following method can be employed to do the evaluation.valArray(train,eval)=trainDf.randomSplit(Array(0.7,0.3))valclassifier=newXGBoostClassifer().setEvalDataset(eval)valmodel=classifier.fit(train) - tracker_confThe following method can be used to configure RabitTracker.valclassifier=newXGBoostClassifer().setRabitTrackerTimeout(100).setRabitTrackerHostIp(\"192.168.0.2\").setRabitTrackerPort(19203) - rabitRingReduceThreshold - rabitTimeout - rabitConnectRetry - singlePrecisionHistogram - lambdaBias - objectiveType", "prev_chunk_id": "chunk_283", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_285", "url": "https://xgboost.readthedocs.io/en/stable/jvm/api.html", "title": "API Docs for the JVM packages", "page_title": "API Docs for the JVM packages — xgboost 3.0.4 documentation", "breadcrumbs": "API Docs for the JVM packages", "content": "API Docs for the JVM packages - XGBoost4J Java API - XGBoost4J Scala API - XGBoost4J-Spark Scala API - XGBoost4J-Spark-GPU Scala API - XGBoost4J-Flink Scala API", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_286", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "XGBoost4J-Spark-GPU Tutorial", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost4J-Spark-GPU Tutorial", "content": "XGBoost4J-Spark-GPU Tutorial XGBoost4J-Spark-GPU is an open source library aiming to accelerate distributed XGBoost training on Apache Spark cluster from end to end with GPUs by leveraging the RAPIDS Accelerator for Apache Spark product. This tutorial will show you how to use XGBoost4J-Spark-GPU.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_287", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Add XGBoost to Your Project", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Add XGBoost to Your Project", "content": "Add XGBoost to Your Project Prior to delving into the tutorial on utilizing XGBoost4J-Spark-GPU, it is advisable to refer to Installation from Maven repository for instructions on adding XGBoost4J-Spark-GPU as a project dependency. We offer both stable releases and snapshots for your convenience.", "prev_chunk_id": "chunk_286", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_288", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Data Preparation", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Data Preparation", "content": "Data Preparation In this section, we use the Iris dataset as an example to showcase how we use Apache Spark to transform a raw dataset and make it fit the data interface of XGBoost. The Iris dataset is shipped in CSV format. Each instance contains 4 features, “sepal length”, “sepal width”, “petal length” and “petal width”. In addition, it contains the “class” column, which is essentially the label with three possible values: “Iris Setosa”, “Iris Versicolour” and “Iris Virginica”.", "prev_chunk_id": "chunk_287", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_289", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Read Dataset with Spark’s Built-In Reader", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Read Dataset with Spark’s Built-In Reader", "content": "Read Dataset with Spark’s Built-In Reader import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.{DoubleType, StringType, StructField, StructType} val spark = SparkSession.builder().getOrCreate() val labelName = \"class\" val schema = new StructType(Array( StructField(\"sepal length\", DoubleType, true), StructField(\"sepal width\", DoubleType, true), StructField(\"petal length\", DoubleType, true), StructField(\"petal width\", DoubleType, true), StructField(labelName, StringType, true))) val xgbInput = spark.read.option(\"header\", \"false\") .schema(schema) .csv(dataPath) At first, we create an instance of a SparkSession which is the entry point of any Spark application working with DataFrames. The schema variable defines the schema of the DataFrame wrapping Iris data. With this explicitly set schema, we can define the column names as well as their types; otherwise the column names would be the default ones derived by Spark, such as _col0, etc. Finally, we can use Spark’s built-in CSV reader to load the Iris CSV file as a DataFrame named xgbInput. Apache Spark also contains many built-in readers for other formats such as ORC, Parquet, Avro, JSON.", "prev_chunk_id": "chunk_288", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_290", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Transform Raw Iris Dataset", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Transform Raw Iris Dataset", "content": "Transform Raw Iris Dataset To make the Iris dataset recognizable to XGBoost, we need to encode the String-typed label, i.e. “class”, to the Double-typed label. One way to convert the String-typed label to Double is to use Spark’s built-in feature transformer StringIndexer. But this feature is not accelerated in RAPIDS Accelerator, which means it will fall back to CPU. Instead, we use an alternative way to achieve the same goal with the following code: import org.apache.spark.sql.expressions.Window import org.apache.spark.sql.functions._ val spec = Window.orderBy(labelName) val Array(train, test) = xgbInput .withColumn(\"tmpClassName\", dense_rank().over(spec) - 1) .drop(labelName) .withColumnRenamed(\"tmpClassName\", labelName) .randomSplit(Array(0.7, 0.3), seed = 1) train.show(5) +------------+-----------+------------+-----------+-----+ |sepal length|sepal width|petal length|petal width|class| +------------+-----------+------------+-----------+-----+ | 4.3| 3.0| 1.1| 0.1| 0| | 4.4| 2.9| 1.4| 0.2| 0| | 4.4| 3.0| 1.3| 0.2| 0| | 4.4| 3.2| 1.3| 0.2| 0| | 4.6| 3.2| 1.4| 0.2| 0| +------------+-----------+------------+-----------+-----+ With window operations, we have mapped the string column of labels to label indices.", "prev_chunk_id": "chunk_289", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_291", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Training", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Training", "content": "Training XGBoost4j-Spark-Gpu supports regression, classification and ranking models. Although we use the Iris dataset in this tutorial to show how we use XGBoost4J-Spark-GPU to resolve a multi-classes classification problem, the usage in Regression and Ranking is very similar to classification. To train a XGBoost model for classification, we need to define a XGBoostClassifier first: import ml.dmlc.xgboost4j.scala.spark.XGBoostClassifier val xgbParam = Map( \"objective\" -> \"multi:softprob\", \"num_class\" -> 3, \"num_round\" -> 100, \"device\" -> \"cuda\", \"num_workers\" -> 1) val featuresNames = schema.fieldNames.filter(name => name != labelName) val xgbClassifier = new XGBoostClassifier(xgbParam) .setFeaturesCol(featuresNames) .setLabelCol(labelName) The device parameter is for informing XGBoost that CUDA devices should be used instead of CPU. Unlike the single-node mode, GPUs are managed by spark instead of by XGBoost. Therefore, explicitly specified device ordinal like cuda:1 is not support. The available parameters for training a XGBoost model can be found in here. Similar to the XGBoost4J-Spark package, in addition to the default set of parameters, XGBoost4J-Spark-GPU also supports the camel-case variant of these parameters to be consistent with Spark’s MLlib naming convention. Specifically, each parameter in this page has its equivalent form in XGBoost4J-Spark-GPU with camel case. For example, to set max_depth for each tree, you can pass parameter just like what we did in the above code snippet (as max_depth wrapped in a Map), or you can do it through setters in XGBoostClassifer: val xgbClassifier = new XGBoostClassifier(xgbParam) .setFeaturesCol(featuresNames) .setLabelCol(labelName) xgbClassifier.setMaxDepth(2) After setting XGBoostClassifier parameters and feature/label columns, we can build a transformer, XGBoostClassificationModel by fitting XGBoostClassifier with the input DataFrame. This fit operation is essentially the training process and the generated model can then be used in other tasks like prediction. val xgbClassificationModel = xgbClassifier.fit(train)", "prev_chunk_id": "chunk_290", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_292", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Prediction", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction When we get a model, a XGBoostClassificationModel or a XGBoostRegressionModel or a XGBoostRankerModel, it takes a DataFrame as an input, reads the column containing feature vectors, predicts for each feature vector, and outputs a new DataFrame with the following columns by default: - XGBoostClassificationModel will output margins (rawPredictionCol), probabilities(probabilityCol) and the eventual prediction labels (predictionCol) for each possible label. - XGBoostRegressionModel will output prediction a label(predictionCol). - XGBoostRankerModel will output prediction a label(predictionCol). val xgbClassificationModel = xgbClassifier.fit(train) val results = xgbClassificationModel.transform(test) results.show() With the above code snippet, we get a DataFrame as result, which contains the margin, probability for each class, and the prediction for each instance. +------------+-----------+------------------+-------------------+-----+--------------------+--------------------+----------+ |sepal length|sepal width| petal length| petal width|class| rawPrediction| probability|prediction| +------------+-----------+------------------+-------------------+-----+--------------------+--------------------+----------+ | 4.5| 2.3| 1.3|0.30000000000000004| 0|[3.16666603088378...|[0.98853939771652...| 0.0| | 4.6| 3.1| 1.5| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 4.8| 3.1| 1.6| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 4.8| 3.4| 1.6| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 4.8| 3.4|1.9000000000000001| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 4.9| 2.4| 3.3| 1.0| 1|[-2.1498908996582...|[0.00596602633595...| 1.0| | 4.9| 2.5| 4.5| 1.7| 2|[-2.1498908996582...|[0.00596602633595...| 1.0| | 5.0| 3.5| 1.3|0.30000000000000004| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.1| 2.5| 3.0| 1.1| 1|[3.16666603088378...|[0.98853939771652...| 0.0| | 5.1| 3.3| 1.7| 0.5| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.1| 3.5| 1.4| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.1| 3.8| 1.6| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.2| 3.4| 1.4| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.2| 3.5| 1.5| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.2| 4.1| 1.5| 0.1| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.4| 3.9| 1.7| 0.4| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.5| 2.4| 3.8| 1.1| 1|[-2.1498908996582...|[0.00596602633595...| 1.0| | 5.5| 4.2| 1.4| 0.2| 0|[3.25857257843017...|[0.98969423770904...| 0.0| | 5.7| 2.5| 5.0| 2.0| 2|[-2.1498908996582...|[0.00280966912396...| 2.0| | 5.7| 3.0| 4.2| 1.2| 1|[-2.1498908996582...|[0.00643939292058...| 1.0| +------------+-----------+------------------+-------------------+-----+--------------------+--------------------+----------+", "prev_chunk_id": "chunk_291", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_293", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "Submit the application", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Submit the application", "content": "Submit the application Assuming you have configured the Spark standalone cluster with GPU support. Otherwise, please refer to spark standalone configuration with GPU support. Starting from XGBoost 2.1.0, stage-level scheduling is automatically enabled. Therefore, if you are using Spark standalone cluster version 3.4.0 or higher, we strongly recommend configuring the \"spark.task.resource.gpu.amount\" as a fractional value. This will enable running multiple tasks in parallel during the ETL phase. An example configuration would be \"spark.task.resource.gpu.amount=1/spark.executor.cores\". However, if you are using a XGBoost version earlier than 2.1.0 or a Spark standalone cluster version below 3.4.0, you still need to set \"spark.task.resource.gpu.amount\" equal to \"spark.executor.resource.gpu.amount\". Assuming that the application main class is “Iris” and the application jar is “iris-1.0.0.jar”, provided below is an instance demonstrating how to submit the xgboost application to an Apache Spark Standalone cluster. rapids_version=24.08.0 xgboost_version=$LATEST_VERSION main_class=Iris app_jar=iris-1.0.0.jar spark-submit \\ --master $master \\ --packages com.nvidia:rapids-4-spark_2.12:${rapids_version},ml.dmlc:xgboost4j-spark-gpu_2.12:${xgboost_version} \\ --conf spark.executor.cores=12 \\ --conf spark.task.cpus=1 \\ --conf spark.executor.resource.gpu.amount=1 \\ --conf spark.task.resource.gpu.amount=0.08 \\ --conf spark.rapids.sql.csv.read.double.enabled=true \\ --conf spark.rapids.sql.hasNans=false \\ --conf spark.plugins=com.nvidia.spark.SQLPlugin \\ --class ${main_class} \\ ${app_jar} - First, we need to specify theRAPIDSAccelerator,xgboost4j-spark-gpupackages by--packages - Second,RAPIDSAcceleratoris a Spark plugin, so we need to configure it by specifyingspark.plugins=com.nvidia.spark.SQLPlugin For details about other RAPIDS Accelerator other configurations, please refer to the configuration. For RAPIDS Accelerator Frequently Asked Questions, please refer to the frequently-asked-questions.", "prev_chunk_id": "chunk_292", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_294", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_gpu_tutorial.html", "title": "RMM Support", "page_title": "XGBoost4J-Spark-GPU Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "RMM Support", "content": "RMM Support When compiled with the RMM plugin (see Building From Source), the XGBoost spark package can reuse the RMM memory pool automatically based on spark.rapids.memory.gpu.pooling.enabled and spark.rapids.memory.gpu.pool. Please note that both submit options need to be set accordingly. In addition, XGBoost employs NCCL for GPU communication, which requires some GPU memory for communication buffers and one should not let RMM take all the available memory. Example configuration related to memory pool: spark-submit \\ --master $master \\ --conf spark.rapids.memory.gpu.allocFraction=0.5 \\ --conf spark.rapids.memory.gpu.maxAllocFraction=0.8 \\ --conf spark.rapids.memory.gpu.pool=ARENA \\ --conf spark.rapids.memory.gpu.pooling.enabled=true \\ ...", "prev_chunk_id": "chunk_293", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_295", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "XGBoost4J-Spark Tutorial", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost4J-Spark Tutorial", "content": "XGBoost4J-Spark Tutorial XGBoost4J-Spark is a project aiming to seamlessly integrate XGBoost and Apache Spark by fitting XGBoost to Apache Spark’s MLLIB framework. With the integration, user can not only uses the high-performant algorithm implementation of XGBoost, but also leverages the powerful data processing engine of Spark for: - Feature Engineering: feature extraction, transformation, dimensionality reduction, and selection, etc. - Pipelines: constructing, evaluating, and tuning ML Pipelines - Persistence: persist and load machine learning models and even whole Pipelines This tutorial is to cover the end-to-end process to build a machine learning pipeline with XGBoost4J-Spark. We will discuss - Using Spark to preprocess data to fit to XGBoost4J-Spark’s data interface - Training a XGBoost model with XGBoost4J-Spark - Serving XGBoost model (prediction) with Spark - Building a Machine Learning Pipeline with XGBoost4J-Spark - Running XGBoost4J-Spark in Production", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_296", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Refer to XGBoost4J-Spark Dependency", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Refer to XGBoost4J-Spark Dependency", "content": "Refer to XGBoost4J-Spark Dependency Before we go into the tour of how to use XGBoost4J-Spark, you should first consult Installation from Maven repository in order to add XGBoost4J-Spark as a dependency for your project. We provide both stable releases and snapshots.", "prev_chunk_id": "chunk_295", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_297", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Data Preparation", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Data Preparation", "content": "Data Preparation As aforementioned, XGBoost4J-Spark seamlessly integrates Spark and XGBoost. The integration enables users to apply various types of transformation over the training/test datasets with the convenient and powerful data processing framework: Spark. In this section, we use Iris dataset as an example to showcase how we use Spark to transform raw dataset and make it fit to the data interface of XGBoost. Iris dataset is shipped in CSV format. Each instance contains 4 features, “sepal length”, “sepal width”, “petal length” and “petal width”. In addition, it contains the “class” column, which is essentially the label with three possible values: “Iris Setosa”, “Iris Versicolour” and “Iris Virginica”.", "prev_chunk_id": "chunk_296", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_298", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Read Dataset with Spark’s Built-In Reader", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Read Dataset with Spark’s Built-In Reader", "content": "Read Dataset with Spark’s Built-In Reader The first thing in data transformation is to load the dataset as Spark’s structured data abstraction, DataFrame. import org.apache.spark.sql.SparkSession import org.apache.spark.sql.types.{DoubleType, StringType, StructField, StructType} val spark = SparkSession.builder().getOrCreate() val schema = new StructType(Array( StructField(\"sepal length\", DoubleType, true), StructField(\"sepal width\", DoubleType, true), StructField(\"petal length\", DoubleType, true), StructField(\"petal width\", DoubleType, true), StructField(\"class\", StringType, true))) val rawInput = spark.read.schema(schema).csv(\"input_path\") At the first line, we create a instance of SparkSession which is the entry of any Spark program working with DataFrame. The schema variable defines the schema of DataFrame wrapping Iris data. With this explicitly set schema, we can define the columns’ name as well as their types; otherwise the column name would be the default ones derived by Spark, such as _col0, etc. Finally, we can use Spark’s built-in csv reader to load Iris csv file as a DataFrame named rawInput. Spark also contains many built-in readers for other format. The latest version of Spark supports CSV, JSON, Parquet, and LIBSVM.", "prev_chunk_id": "chunk_297", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_299", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Transform Raw Iris Dataset", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Transform Raw Iris Dataset", "content": "Transform Raw Iris Dataset To make Iris dataset be recognizable to XGBoost, we need to - Transform String-typed label, i.e. “class”, to Double-typed label. - Assemble the feature columns as a vector to fit to the data interface of Spark ML framework. To convert String-typed label to Double, we can use Spark’s built-in feature transformer StringIndexer. import org.apache.spark.ml.feature.StringIndexer val stringIndexer = new StringIndexer(). setInputCol(\"class\"). setOutputCol(\"classIndex\"). fit(rawInput) val labelTransformed = stringIndexer.transform(rawInput).drop(\"class\") With a newly created StringIndexer instance: - we set input column, i.e. the column containing String-typed label. - we set output column, i.e. the column containing the Double-typed label. - Then wefitStringIndex with our input DataFramerawInput, so that Spark internals can get information like total number of distinct values, etc. Now we have a StringIndexer which is ready to be applied to our input DataFrame. To execute the transformation logic of StringIndexer, we transform the input DataFrame rawInput and to keep a concise DataFrame, we drop the column “class” and only keeps the feature columns and the transformed Double-typed label column (in the last line of the above code snippet). The fit and transform are two key operations in MLLIB. Basically, fit produces a “transformer”, e.g. StringIndexer, and each transformer applies transform method on DataFrame to add new column(s) containing transformed features/labels or prediction results, etc. To understand more about fit and transform, You can find more details in here. Similarly, we can use another transformer, VectorAssembler, to assemble feature columns “sepal length”, “sepal width”, “petal length” and “petal width” as a vector. import org.apache.spark.ml.feature.VectorAssembler val vectorAssembler = new VectorAssembler(). setInputCols(Array(\"sepal length\", \"sepal width\", \"petal length\", \"petal width\")). setOutputCol(\"features\") val xgbInput = vectorAssembler.transform(labelTransformed).select(\"features\", \"classIndex\") Now, we have a DataFrame containing only two columns, “features” which contains vector-represented “sepal length”, “sepal width”, “petal length” and “petal width” and “classIndex” which has", "prev_chunk_id": "chunk_298", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_300", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Transform Raw Iris Dataset", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Transform Raw Iris Dataset", "content": "Double-typed labels. A DataFrame like this (containing vector-represented features and numeric labels) can be fed to XGBoost4J-Spark’s training engine directly.", "prev_chunk_id": "chunk_299", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_301", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Dealing with missing values", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Dealing with missing values", "content": "Dealing with missing values XGBoost supports missing values by default (as desribed here). If given a SparseVector, XGBoost will treat any values absent from the SparseVector as missing. You are also able to specify to XGBoost to treat a specific value in your Dataset as if it was a missing value. By default XGBoost will treat NaN as the value representing missing. Example of setting a missing value (e.g. -999) to the “missing” parameter in XGBoostClassifier: import ml.dmlc.xgboost4j.scala.spark.XGBoostClassifier val xgbParam = Map(\"eta\" -> 0.1f, \"missing\" -> -999, \"objective\" -> \"multi:softprob\", \"num_class\" -> 3, \"num_round\" -> 100, \"num_workers\" -> 2) val xgbClassifier = new XGBoostClassifier(xgbParam). setFeaturesCol(\"features\"). setLabelCol(\"classIndex\")", "prev_chunk_id": "chunk_300", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_302", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Training", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Training", "content": "Training XGBoost supports regression, classification and ranking. While we use Iris dataset in this tutorial to show how we use XGBoost4J-Spark to resolve a multi-classes classification problem, the usage in Regression and Ranking is very similar to classification. To train a XGBoost model for classification, we need to create a XGBoostClassifier first: import ml.dmlc.xgboost4j.scala.spark.XGBoostClassifier val xgbParam = Map(\"eta\" -> 0.1f, \"max_depth\" -> 2, \"objective\" -> \"multi:softprob\", \"num_class\" -> 3) val xgbClassifier = new XGBoostClassifier(xgbParam). setNumRound(100). setNumWorkers(2). setFeaturesCol(\"features\"). setLabelCol(\"classIndex\") The available parameters for training a XGBoost model can be found in here. In XGBoost4J-Spark, we support not only the default set of parameters but also the camel-case variant of these parameters to keep consistent with Spark’s MLLIB parameters. Specifically, each parameter in this page has its equivalent form in XGBoost4J-Spark with camel case. For example, to set max_depth for each tree, you can pass parameter just like what we did in the above code snippet (as max_depth wrapped in a Map), or you can do it through setters in XGBoostClassifer: val xgbClassifier = new XGBoostClassifier(). setFeaturesCol(\"features\"). setLabelCol(\"classIndex\") xgbClassifier.setMaxDepth(2) After we set XGBoostClassifier parameters and feature/label column, we can build a transformer, XGBoostClassificationModel by fitting XGBoostClassifier with the input DataFrame. This fit operation is essentially the training process and the generated model can then be used in prediction. val xgbClassificationModel = xgbClassifier.fit(xgbInput)", "prev_chunk_id": "chunk_301", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_303", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Early Stopping", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Early Stopping", "content": "Early Stopping Early stopping is a feature to prevent the unnecessary training iterations. By specifying num_early_stopping_rounds or directly call setNumEarlyStoppingRounds over a XGBoostClassifier or XGBoostRegressor, we can define number of rounds if the evaluation metric going away from the best iteration and early stop training iterations. When it comes to custom eval metrics, in additional to num_early_stopping_rounds, you also need to define maximize_evaluation_metrics or call setMaximizeEvaluationMetrics to specify whether you want to maximize or minimize the metrics in training. For built-in eval metrics, XGBoost4J-Spark will automatically select the direction. For example, we need to maximize the evaluation metrics (set maximize_evaluation_metrics with true), and set num_early_stopping_rounds with 5. The evaluation metric of 10th iteration is the maximum one until now. In the following iterations, if there is no evaluation metric greater than the 10th iteration’s (best one), the training would be early stopped at 15th iteration.", "prev_chunk_id": "chunk_302", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_304", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Training with Evaluation Dataset", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Training with Evaluation Dataset", "content": "Training with Evaluation Dataset You can also monitor the performance of the model during training with evaluation dataset. By calling setEvalDataset over a XGBoostClassifier, XGBoostRegressor or XGBoostRanker.", "prev_chunk_id": "chunk_303", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_305", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Prediction", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction XGBoost4j-Spark supports two ways for model serving: batch prediction and single instance prediction.", "prev_chunk_id": "chunk_304", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_306", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Batch Prediction", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Batch Prediction", "content": "Batch Prediction When we get a model, either XGBoostClassificationModel, XGBoostRegressionModel or XGBoostRankerModel, it takes a DataFrame, read the column containing feature vectors, predict for each feature vector, and output a new DataFrame with the following columns by default: - XGBoostClassificationModel will output margins (rawPredictionCol), probabilities(probabilityCol) and the eventual prediction labels (predictionCol) for each possible label. - XGBoostRegressionModel will output prediction label(predictionCol). - XGBoostRankerModel will output prediction label(predictionCol). Batch prediction expects the user to pass the testset in the form of a DataFrame. XGBoost4J-Spark starts a XGBoost worker for each partition of DataFrame for parallel prediction and generates prediction results for the whole DataFrame in a batch. val xgbClassificationModel = xgbClassifier.fit(xgbInput) val results = xgbClassificationModel.transform(testSet) With the above code snippet, we get a result DataFrame, result containing margin, probability for each class and the prediction for each instance +-----------------+----------+--------------------+--------------------+----------+ | features|classIndex| rawPrediction| probability|prediction| +-----------------+----------+--------------------+--------------------+----------+ |[5.1,3.5,1.4,0.2]| 0.0|[3.45569849014282...|[0.99579632282257...| 0.0| |[4.9,3.0,1.4,0.2]| 0.0|[3.45569849014282...|[0.99618089199066...| 0.0| |[4.7,3.2,1.3,0.2]| 0.0|[3.45569849014282...|[0.99643349647521...| 0.0| |[4.6,3.1,1.5,0.2]| 0.0|[3.45569849014282...|[0.99636095762252...| 0.0| |[5.0,3.6,1.4,0.2]| 0.0|[3.45569849014282...|[0.99579632282257...| 0.0| |[5.4,3.9,1.7,0.4]| 0.0|[3.45569849014282...|[0.99428516626358...| 0.0| |[4.6,3.4,1.4,0.3]| 0.0|[3.45569849014282...|[0.99643349647521...| 0.0| |[5.0,3.4,1.5,0.2]| 0.0|[3.45569849014282...|[0.99579632282257...| 0.0| |[4.4,2.9,1.4,0.2]| 0.0|[3.45569849014282...|[0.99618089199066...| 0.0| |[4.9,3.1,1.5,0.1]| 0.0|[3.45569849014282...|[0.99636095762252...| 0.0| |[5.4,3.7,1.5,0.2]| 0.0|[3.45569849014282...|[0.99428516626358...| 0.0| |[4.8,3.4,1.6,0.2]| 0.0|[3.45569849014282...|[0.99643349647521...| 0.0| |[4.8,3.0,1.4,0.1]| 0.0|[3.45569849014282...|[0.99618089199066...| 0.0| |[4.3,3.0,1.1,0.1]| 0.0|[3.45569849014282...|[0.99618089199066...| 0.0| |[5.8,4.0,1.2,0.2]| 0.0|[3.45569849014282...|[0.97809928655624...| 0.0| |[5.7,4.4,1.5,0.4]| 0.0|[3.45569849014282...|[0.97809928655624...| 0.0| |[5.4,3.9,1.3,0.4]| 0.0|[3.45569849014282...|[0.99428516626358...| 0.0| |[5.1,3.5,1.4,0.3]| 0.0|[3.45569849014282...|[0.99579632282257...| 0.0| |[5.7,3.8,1.7,0.3]| 0.0|[3.45569849014282...|[0.97809928655624...| 0.0| |[5.1,3.8,1.5,0.3]| 0.0|[3.45569849014282...|[0.99579632282257...| 0.0| +-----------------+----------+--------------------+--------------------+----------+", "prev_chunk_id": "chunk_305", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_307", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Single instance prediction", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Single instance prediction", "content": "Single instance prediction XGBoostClassificationModel, XGBoostRegressionModel or XGBoostRankerModel supports making prediction on single instance as well. It accepts a single Vector as feature, and output the prediction label. However, the overhead of single-instance prediction is high due to the internal overhead of XGBoost, use it carefully! val features = xgbInput.head().getAs[Vector](\"features\") val result = xgbClassificationModel.predict(features)", "prev_chunk_id": "chunk_306", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_308", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Model and pipeline persistence", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Model and pipeline persistence", "content": "Model and pipeline persistence A data scientist produces an ML model and hands it over to an engineering team for deployment in a production environment. Reversely, a trained model may be used by data scientists, for example as a baseline, across the process of data exploration. So it’s important to support model persistence to make the models available across usage scenarios and programming languages. XGBoost4j-Spark supports saving and loading XGBoostClassifier/XGBoostClassificationModel and XGBoostRegressor/XGBoostRegressionModel and XGBoostRanker/XGBoostRankerModel to/from file system. It also supports saving and loading a ML pipeline which includes these estimators and models. We can save the XGBoostClassificationModel to file system: val xgbClassificationModelPath = \"/tmp/xgbClassificationModel\" xgbClassificationModel.write.overwrite().save(xgbClassificationModelPath) and then loading the model in another session: import ml.dmlc.xgboost4j.scala.spark.XGBoostClassificationModel val xgbClassificationModel2 = XGBoostClassificationModel.load(xgbClassificationModelPath) xgbClassificationModel2.transform(xgbInput) With regards to ML pipeline save and load, please refer the next section.", "prev_chunk_id": "chunk_307", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_309", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Interact with Other Bindings of XGBoost", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Interact with Other Bindings of XGBoost", "content": "Interact with Other Bindings of XGBoost After we train a model with XGBoost4j-Spark on massive dataset, sometimes we want to do model serving in single machine or integrate it with other single node libraries for further processing. After saving the model, we can load this model with single node Python XGBoost directly. val xgbClassificationModelPath = \"/tmp/xgbClassificationModel\" xgbClassificationModel.write.overwrite().save(xgbClassificationModelPath) import xgboost as xgb bst = xgb.Booster({'nthread': 4}) bst.load_model(\"/tmp/xgbClassificationModel/data/model\")", "prev_chunk_id": "chunk_308", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_310", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Basic ML Pipeline", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Basic ML Pipeline", "content": "Basic ML Pipeline Spark ML pipeline can combine multiple algorithms or functions into a single pipeline. It covers from feature extraction, transformation, selection to model training and prediction. XGBoost4j-Spark makes it feasible to embed XGBoost into such a pipeline seamlessly. The following example shows how to build such a pipeline consisting of Spark MLlib feature transformer and XGBoostClassifier estimator. We still use Iris dataset and the rawInput DataFrame. First we need to split the dataset into training and test dataset. val Array(training, test) = rawInput.randomSplit(Array(0.8, 0.2), 123) The we build the ML pipeline which includes 4 stages: - Assemble all features into a single vector column. - From string label to indexed double label. - Use XGBoostClassifier to train classification model. - Convert indexed double label back to original string label. We have shown the first three steps in the earlier sections, and the last step is finished with a new transformer IndexToString: val labelConverter = new IndexToString() .setInputCol(\"prediction\") .setOutputCol(\"realLabel\") .setLabels(stringIndexer.labels) We need to organize these steps as a Pipeline in Spark ML framework and evaluate the whole pipeline to get a PipelineModel: import org.apache.spark.ml.feature._ import org.apache.spark.ml.Pipeline val pipeline = new Pipeline() .setStages(Array(assembler, stringIndexer, booster, labelConverter)) val model = pipeline.fit(training) After we get the PipelineModel, we can make prediction on the test dataset and evaluate the model accuracy. import org.apache.spark.ml.evaluation.MulticlassClassificationEvaluator val prediction = model.transform(test) val evaluator = new MulticlassClassificationEvaluator() val accuracy = evaluator.evaluate(prediction)", "prev_chunk_id": "chunk_309", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_311", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Pipeline with Hyper-parameter Tunning", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Pipeline with Hyper-parameter Tunning", "content": "Pipeline with Hyper-parameter Tunning The most critical operation to maximize the power of XGBoost is to select the optimal parameters for the model. Tuning parameters manually is a tedious and labor-consuming process. With the latest version of XGBoost4J-Spark, we can utilize the Spark model selecting tool to automate this process. The following example shows the code snippet utilizing CrossValidation and MulticlassClassificationEvaluator to search the optimal combination of two XGBoost parameters, max_depth and eta. (See XGBoost Parameters.) The model producing the maximum accuracy defined by MulticlassClassificationEvaluator is selected and used to generate the prediction for the test set. import org.apache.spark.ml.tuning._ import org.apache.spark.ml.PipelineModel import ml.dmlc.xgboost4j.scala.spark.XGBoostClassificationModel val paramGrid = new ParamGridBuilder() .addGrid(booster.maxDepth, Array(3, 8)) .addGrid(booster.eta, Array(0.2, 0.6)) .build() val cv = new CrossValidator() .setEstimator(pipeline) .setEvaluator(evaluator) .setEstimatorParamMaps(paramGrid) .setNumFolds(3) val cvModel = cv.fit(training) val bestModel = cvModel.bestModel.asInstanceOf[PipelineModel].stages(2) .asInstanceOf[XGBoostClassificationModel] bestModel.extractParamMap()", "prev_chunk_id": "chunk_310", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_312", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Run XGBoost4J-Spark in Production", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Run XGBoost4J-Spark in Production", "content": "Run XGBoost4J-Spark in Production XGBoost4J-Spark is one of the most important steps to bring XGBoost to production environment easier. In this section, we introduce three key features to run XGBoost4J-Spark in production.", "prev_chunk_id": "chunk_311", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_313", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Parallel/Distributed Training", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Parallel/Distributed Training", "content": "Parallel/Distributed Training The massive size of training dataset is one of the most significant characteristics in production environment. To ensure that training in XGBoost scales with the data size, XGBoost4J-Spark bridges the distributed/parallel processing framework of Spark and the parallel/distributed training mechanism of XGBoost. In XGBoost4J-Spark, each XGBoost worker is wrapped by a Spark task and the training dataset in Spark’s memory space is fed to XGBoost workers in a transparent approach to the user. In the code snippet where we build XGBoostClassifier, we set parameter num_workers (or numWorkers). This parameter controls how many parallel workers we want to have when training a XGBoostClassificationModel.", "prev_chunk_id": "chunk_312", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_314", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Gang Scheduling", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Gang Scheduling", "content": "Gang Scheduling XGBoost uses AllReduce. algorithm to synchronize the stats, e.g. histogram values, of each worker during training. Therefore XGBoost4J-Spark requires that all of nthread * numWorkers cores should be available before the training runs. In the production environment where many users share the same cluster, it’s hard to guarantee that your XGBoost4J-Spark application can get all requested resources for every run. By default, the communication layer in XGBoost will block the whole application when it requires more resources to be available. This process usually brings unnecessary resource waste as it keeps the ready resources and try to claim more. Additionally, this usually happens silently and does not bring the attention of users. XGBoost4J-Spark allows the user to setup a timeout threshold for claiming resources from the cluster. If the application cannot get enough resources within this time period, the application would fail instead of wasting resources for hanging long. To enable this feature, you can set with XGBoostClassifier/XGBoostRegressor/XGBoostRanker: xgbClassifier.setRabitTrackerTimeout(60000L) or pass in rabit_tracker_timeout in xgbParamMap when building XGBoostClassifier: val xgbParam = Map(\"eta\" -> 0.1f, \"max_depth\" -> 2, \"objective\" -> \"multi:softprob\", \"num_class\" -> 3, \"num_round\" -> 100, \"num_workers\" -> 2, \"rabit_tracker_timeout\" -> 60000L) val xgbClassifier = new XGBoostClassifier(xgbParam). setFeaturesCol(\"features\"). setLabelCol(\"classIndex\") If XGBoost4J-Spark cannot get enough resources for running two XGBoost workers, the application would fail. Users can have external mechanism to monitor the status of application and get notified for such case.", "prev_chunk_id": "chunk_313", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_315", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "Checkpoint During Training", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Checkpoint During Training", "content": "Checkpoint During Training Transient failures are also commonly seen in production environment. To simplify the design of XGBoost, we stop training if any of the distributed workers fail. However, if the training fails after having been through a long time, it would be a great waste of resources. We support creating checkpoint during training to facilitate more efficient recovery from failure. To enable this feature, you can set how many iterations we build each checkpoint with setCheckpointInterval and the location of checkpoints with setCheckpointPath: xgbClassifier.setCheckpointInterval(2) xgbClassifier.setCheckpointPath(\"/checkpoint_path\") An equivalent way is to pass in parameters in XGBoostClassifier’s constructor: val xgbParam = Map(\"eta\" -> 0.1f, \"max_depth\" -> 2, \"objective\" -> \"multi:softprob\", \"num_class\" -> 3, \"num_round\" -> 100, \"num_workers\" -> 2, \"checkpoint_path\" -> \"/checkpoints_path\", \"checkpoint_interval\" -> 2) val xgbClassifier = new XGBoostClassifier(xgbParam). setFeaturesCol(\"features\"). setLabelCol(\"classIndex\") If the training failed during these 100 rounds, the next run of training would start by reading the latest checkpoint file in /checkpoints_path and start from the iteration when the checkpoint was built until to next failure or the specified 100 rounds.", "prev_chunk_id": "chunk_314", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_316", "url": "https://xgboost.readthedocs.io/en/stable/jvm/xgboost4j_spark_tutorial.html", "title": "External Memory", "page_title": "XGBoost4J-Spark Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "External Memory", "content": "External Memory Here we refer to the iterator-based external memory instead of the one that uses special URL parameters. XGBoost-Spark has experimental support for GPU-based external memory training (XGBoost4J-Spark-GPU Tutorial) since 3.0. When it’s used in combination with GPU-based training, data is first cached on disk and then staged on CPU memory. See Using XGBoost External Memory Version for general concept and best practices for the external memory training. In addition, see the doc string of the estimator parameter useExternalMemory. With Spark estimators: val xgbClassifier = new XGBoostClassifier(xgbParam) .setFeaturesCol(featuresNames) .setLabelCol(labelName) .setUseExternalMemory(true) .setDevice(\"cuda\") // CPU is not yet supported", "prev_chunk_id": "chunk_315", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_317", "url": "https://xgboost.readthedocs.io/en/stable/jvm/java_intro.html", "title": "Getting Started with XGBoost4J", "page_title": "Getting Started with XGBoost4J — xgboost 3.0.4 documentation", "breadcrumbs": "Getting Started with XGBoost4J", "content": "Getting Started with XGBoost4J This tutorial introduces Java API for XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_318", "url": "https://xgboost.readthedocs.io/en/stable/jvm/java_intro.html", "title": "Data Interface", "page_title": "Getting Started with XGBoost4J — xgboost 3.0.4 documentation", "breadcrumbs": "Data Interface", "content": "Data Interface Like the XGBoost python module, XGBoost4J uses DMatrix to handle data. LIBSVM txt format file, sparse matrix in CSR/CSC format, and dense matrix are supported. - The first step is to import DMatrix:importml.dmlc.xgboost4j.java.DMatrix; - Use DMatrix constructor to load data from a libsvm text format file:DMatrixdmat=newDMatrix(\"train.svm.txt\"); - Pass arrays to DMatrix constructor to load from sparse matrix.Suppose we have a sparse matrix1 0 2 0 4 0 0 3 3 1 2 0We can express the sparse matrix inCompressed Sparse Row (CSR)format:long[]rowHeaders=newlong[]{0,2,4,7};float[]data=newfloat[]{1f,2f,4f,3f,3f,1f,2f};int[]colIndex=newint[]{0,2,0,3,0,1,2};intnumColumn=4;DMatrixdmat=newDMatrix(rowHeaders,colIndex,data,DMatrix.SparseType.CSR,numColumn);… or inCompressed Sparse Column (CSC)format:long[]colHeaders=newlong[]{0,3,4,6,7};float[]data=newfloat[]{1f,4f,3f,1f,2f,2f,3f};int[]rowIndex=newint[]{0,1,2,2,0,2,1};intnumRow=3;DMatrixdmat=newDMatrix(colHeaders,rowIndex,data,DMatrix.SparseType.CSC,numRow); - You may also load your data from a dense matrix. Let’s assume we have a matrix of form1 2 3 4 5 6Usingrow-major layout, we specify the dense matrix as follows:float[]data=newfloat[]{1f,2f,3f,4f,5f,6f};intnrow=3;intncol=2;floatmissing=0.0f;DMatrixdmat=newDMatrix(data,nrow,ncol,missing); - To set weight:float[]weights=newfloat[]{1f,2f,1f};dmat.setWeight(weights);", "prev_chunk_id": "chunk_317", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_319", "url": "https://xgboost.readthedocs.io/en/stable/jvm/java_intro.html", "title": "Setting Parameters", "page_title": "Getting Started with XGBoost4J — xgboost 3.0.4 documentation", "breadcrumbs": "Setting Parameters", "content": "Setting Parameters To set parameters, parameters are specified as a Map: Map<String, Object> params = new HashMap<String, Object>() { { put(\"eta\", 1.0); put(\"max_depth\", 2); put(\"objective\", \"binary:logistic\"); put(\"eval_metric\", \"logloss\"); } };", "prev_chunk_id": "chunk_318", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_320", "url": "https://xgboost.readthedocs.io/en/stable/jvm/java_intro.html", "title": "Training Model", "page_title": "Getting Started with XGBoost4J — xgboost 3.0.4 documentation", "breadcrumbs": "Training Model", "content": "Training Model With parameters and data, you are able to train a booster model. - Import Booster and XGBoost:importml.dmlc.xgboost4j.java.Booster;importml.dmlc.xgboost4j.java.XGBoost; - TrainingDMatrixtrainMat=newDMatrix(\"train.svm.txt\");DMatrixvalidMat=newDMatrix(\"valid.svm.txt\");// Specify a watch list to see model accuracy on data setsMap<String,DMatrix>watches=newHashMap<String,DMatrix>(){{put(\"train\",trainMat);put(\"test\",testMat);}};intnround=2;Boosterbooster=XGBoost.train(trainMat,params,nround,watches,null,null); - Saving modelAfter training, you can save model and dump it out.booster.saveModel(\"model.json\"); - Generating model dump with feature map// dump without feature mapString[]model_dump=booster.getModelDump(null,false);// dump with feature mapString[]model_dump_with_feature_map=booster.getModelDump(\"featureMap.txt\",false); - Load a modelBoosterbooster=XGBoost.loadModel(\"model.json\");", "prev_chunk_id": "chunk_319", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_321", "url": "https://xgboost.readthedocs.io/en/stable/jvm/java_intro.html", "title": "Prediction", "page_title": "Getting Started with XGBoost4J — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction After training and loading a model, you can use it to make prediction for other data. The result will be a two-dimension float array (nsample, nclass); for predictLeaf(), the result would be of shape (nsample, nclass*ntrees). DMatrix dtest = new DMatrix(\"test.svm.txt\"); // predict float[][] predicts = booster.predict(dtest); // predict leaf float[][] leafPredicts = booster.predictLeaf(dtest, 0);", "prev_chunk_id": "chunk_320", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_322", "url": "https://xgboost.readthedocs.io/en/stable/R-package/adding_parameters.html", "title": "Developer guide: parameters from core library", "page_title": "Developer guide: parameters from core library — xgboost 3.0.4 documentation", "breadcrumbs": "Developer guide: parameters from core library", "content": "Developer guide: parameters from core library The XGBoost core library accepts a long list of input parameters (e.g. max_depth for decision trees, regularization, device where compute happens, etc.). New parameters are constantly being added as XGBoost is developed further, and their language bindings should allow passing to the core library everything that it accepts. In the case of R, these parameters are passed as an R list object to function xgb.train, but the R interface aims at providing a better, more idiomatic user experience by offering a parameters constructor with full in-package documentation. This requires keeping the list of parameters and their documentation up to date in the R package too, in addition to the general online documentation for XGBoost. In more detail, there is a function xgb.params which allows the user to construct such a list object to pass to xgb.train while getting full IDE autocompletion on it. This function should accept all possible XGBoost parameters as arguments, listing them in the same order as they appear in the online documentation. In order to add a new parameter from the core library to xgb.params: - Add the parameter at the right location, according to the order in which it appears in the .rst file listing the parameters for the core library. If the parameter appears more than once (e.g. because it applies to more than one type of booster), then add it in a position according to to the first occurrence. - Copy-paste the docs from the .rst file as another@paramentry forxgb.train. Some easy substitutions might be needed, such as changing double-backticks to single-backticks, enquoting variables that need to be passed as strings, and replacing:math:calls with their roxygen equivalent\\eqn{}, among others. - If needed, make minimal modifications for the R interface - for example, since parameters are only listed", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_323", "url": "https://xgboost.readthedocs.io/en/stable/R-package/adding_parameters.html", "title": "Developer guide: parameters from core library", "page_title": "Developer guide: parameters from core library — xgboost 3.0.4 documentation", "breadcrumbs": "Developer guide: parameters from core library", "content": "once, should add at the beginning a note about which type of booster they apply to if they are only applicable for one type, or list default values by booster type if they are different. After adding the parameter to xgb.params, it will also need to be added to the function xgboost if that function can use it. The function xgboost is not meant to support everything that the core library offers - currently parameters related to learning-to-rank are not listed there for example as they are unusable for it (but can be used for xgb.train). In order to add the parameter to xgboost: - Add it to the function signature. The position here differs though: there are a few selected parameters whose positions have been moved closer to the top of the signature. New parameters should not be placed within those “top” positions - instead, place it after parametertree_method, in the most similar place among the remaining parameters according to how it was inserted inxgb.params. Note that the rest of the parameters that come aftertree_methodare still meant to follow the same relative order as inxgb.params. - If the parameter applies exactly in the same way as inxgb.train, then no additional documentation is needed forxgboost, because it inherits parameters fromxgb.paramsby default. However, some parameters might need slight modifications - for example, not all objectives are supported byxgboost, so modifications are needed for that parameter. - If the parameter allows aliases, use only one alias, and prefer the most descriptive nomenclature (e.g. “learning_rate” instead of “eta”). These also need a doc entry@paraminxgboost, as the one inxgb.paramswill have the unsupported alias. As new objectives and evaluation metrics are added, be mindful that they need to be added to the docs of both xgb.params and xgboost. Documentation for objectives in both functions was", "prev_chunk_id": "chunk_322", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_324", "url": "https://xgboost.readthedocs.io/en/stable/R-package/adding_parameters.html", "title": "Developer guide: parameters from core library", "page_title": "Developer guide: parameters from core library — xgboost 3.0.4 documentation", "breadcrumbs": "Developer guide: parameters from core library", "content": "originally copied from the same .rst file for the core library, but for xgboost it undergoes additional modifications in order to list what is and isn’t supported, and to refer only to the parameter aliases that are accepted by xgboost. Keep in mind also that objectives that are a variant of one another but with a different prediction mode, are not meant to be allowed in xgboost as they’d break its intended interface - therefore, such objectives are not described in the docs for xgboost (but there is a list at the end of what isn’t supported by it) and are checked against in function prescreen.objective.", "prev_chunk_id": "chunk_323", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_325", "url": "https://xgboost.readthedocs.io/en/stable/R-package/index_base.html", "title": "Handling of indexable elements", "page_title": "Handling of indexable elements — xgboost 3.0.4 documentation", "breadcrumbs": "Handling of indexable elements", "content": "Handling of indexable elements There are many functionalities in XGBoost which refer to indexable elements in a countable set, such as boosting rounds / iterations / trees in a model (which can be referred to by number), classes, categories / levels in categorical features, among others. XGBoost, being written in C++, uses base-0 indexing and considers ranges / sequences to be inclusive of the left end but not the right one - for example, a range (0, 3) would include the first three elements, numbered 0, 1, and 2. The Python interface uses this same logic, since this is also the way that indexing in Python works, but other languages like R have different logic. In R, indexing is base-1 and ranges / sequences are inclusive of both ends - for example, to refer to the first three elements in a sequence, the interval would be written as (1, 3), and the elements numbered 1, 2, and 3. In order to provide a more idiomatic R interface, XGBoost adjusts its user-facing R interface to follow this and similar R conventions, but internally, it needs to convert all these numbers to the format that the C interface uses. This is made more problematic by the fact that models are meant to be serializable and loadable in other interfaces, which will have different indexing logic. The following adjustments are made in the R interface: - Slicing method for DMatrix, which takes an array of integers, is converted to base-0 indexing by subtracting 1 from each element. Note that this is done in the C-level wrapper function for R, unlike all other conversions which are done in R before being passed to C. - Slicing method for Booster takes a sequence defined by start, end, and step. The R interface is made to", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_326", "url": "https://xgboost.readthedocs.io/en/stable/R-package/index_base.html", "title": "Handling of indexable elements", "page_title": "Handling of indexable elements — xgboost 3.0.4 documentation", "breadcrumbs": "Handling of indexable elements", "content": "work the same way as R’sseqfrom the user’s POV, so it always adjusts the left end by subtracting one, and depending on whether the step size ends exactly or not at the right end, will also adjust the right end to be non-inclusive in C indexing. - Parameteriterationrangeinpredictis also made to behave the same way as R’sseq. Since it doesn’t have a step size, just adjusting the left end by subtracting 1 suffices here. - best_iteration, depending on the context, might be stored as both a C-level booster attribute, and as an R attribute. Since the C-level attributes are shared across interfaces and used in prediction methods, in order to improve compatibility, it leaves this C-level attribute in base-0 indexing, but the R attribute, if present, will be adjusted to base-1 indexing. Note that thepredictmethod in R and other interfaces will look at the C-level attribute only. - Other references to iteration numbers or boosting rounds, such as when printing metrics or saving model snapshots, also follow base-1 indexing. These other references are coded entirely in R, as the C-level functions do not handle such functionalities. - Terminal leaf / node numbers are returned in base-0 indexing, just like they come from the C interface. - Tree numbers in plots follow base-1 indexing. Note that these are only displayed when producing these plots through the R interface’s own handling of DiagrammeR objects, but not when using the C-level GraphViz ‘dot’ format generator for plots. - Feature numbers when producing feature importances, JSONs, trees-to-tables, and SHAP; are all following base-0 indexing. - Categorical features are defined in R as afactortype which encodes with base-1 indexing. When categorical features are passed as Rfactortypes, the conversion is done automatically to base-0 indexing, but if the user whishes to manually supply categorical features as", "prev_chunk_id": "chunk_325", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_327", "url": "https://xgboost.readthedocs.io/en/stable/R-package/index_base.html", "title": "Handling of indexable elements", "page_title": "Handling of indexable elements — xgboost 3.0.4 documentation", "breadcrumbs": "Handling of indexable elements", "content": "already-encoded integers, then those integers need to already be in base-0 encoding. - Categorical levels (categories) in outputs such as plots, JSONs, and trees-to-tables; are also referred to using base-0 indexing, regardless of whether they went into the model as integers or asfactor-typed columns. - Categorical labels for DMatrices do not undergo any extra processing - the user must supply base-0 encoded labels. - A function to retrieve class-specific coefficients when using the linear coefficients history callback takes a class index parameter, which also does not undergo any conversion (i.e. user must pass a base-0 index), in order to match with the label logic - that is, the same class index will refer to the class encoded with that number in the DMatrixlabelfield. New additions to the R interface that take on indexable elements should be mindful of these conventions and try to mimic R’s behavior as much as possible.", "prev_chunk_id": "chunk_326", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_328", "url": "https://xgboost.readthedocs.io/en/stable/", "title": "XGBoost Documentation", "page_title": "XGBoost Documentation — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Documentation", "content": "XGBoost Documentation XGBoost is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Hadoop, SGE, MPI) and can solve problems beyond billions of examples.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_329", "url": "https://xgboost.readthedocs.io/en/stable/R-package/migration_guide.html", "title": "Migrating code from previous XGBoost versions", "page_title": "Migrating code from previous XGBoost versions — xgboost 3.0.4 documentation", "breadcrumbs": "Migrating code from previous XGBoost versions", "content": "Migrating code from previous XGBoost versions XGBoost’s R language bindings had large breaking changes between versions 1.x and 2.x. R code that was working with past XGBoost versions might require modifications to work with the newer versions. This guide outlines the main differences: - Functionxgboost():Previously, this function accepted arguments ‘data’ and ‘label’, which have now been renamed to ‘x’ and ‘y’, in line with other popular R packages.Previously, the ‘data’ argument which is now ‘x’ had to be passed as either an XGBoost ‘DMatrix’ or as an R matrix. Now the argument allows R data.frames, matrices, and sparse matrices from the ‘Matrix’ package, but not XGBoost’s own DMatrices. Categorical columns will be deduced from the types of the columns when passing a data.frame.Previously, the ‘label’ data which is now ‘y’ had to be passed toxgboost()encoded in the format used by the XGBoost core library - meaning: binary variables had to be encoded to 0/1, bounds for survival objectives had to be passed as different arguments, among others. In the newest versions, ‘y’ now doesn’t need to be manually encoded beforehand: it should be passed as an R object of the corresponding class as regression functions from base R and core R packages for the corresponding XGBoost objective - e.g. classification problems should be passed afactor, survival problems aSurv, regression problems a numeric vector, and so on. Learning-to-rank is not supported byxgboost(), but is supported byxgb.train.Previously,xgboost()accepted both aparamsargument and named arguments under.... Now all training parameters should be passed as named arguments, and all accepted parameters are explicit function arguments with in-package documentation. Some parameters are not allowed as they are determined automatically from the rest of the data, such as the number of classes for multi-classes classification which is determined automatically from ‘y’. As well, parameters that have synonyms or", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_330", "url": "https://xgboost.readthedocs.io/en/stable/R-package/migration_guide.html", "title": "Migrating code from previous XGBoost versions", "page_title": "Migrating code from previous XGBoost versions — xgboost 3.0.4 documentation", "breadcrumbs": "Migrating code from previous XGBoost versions", "content": "which are accepted under different possible arguments (e.g. “eta” and “learning_rate”) now accept only their more descriptive form (so “eta” is not accepted, but “learning_rate” is).Models produced by this functionxgboost()are now returned with a different class “xgboost”, which is a subclass of “xgb.Booster” but with more metadata and apredictmethod with different defaults.This functionxgboost()is now meant for interactive usage only. For package developers who wish to incorporate the XGBoost package, it is highly recommended to usexgb.traininstead, which is a lower-level function that closely mimics the same function from the Python package and is meant to be less subject to breaking changes. - Functionxgb.train():Previously,xgb.train()allowed arguments under both a “params” list and as named arguments under.... Now, all training arguments should be passed underparams.In order to make it easier to discover and pass parameters, there is now a functionxgb.paramswhich can generate a list to pass to theparamsargument.xgb.paramsis simply a function with named arguments that lists everything accepted byxgb.trainand offers in-package documentation for all of the arguments, returning a simple named list.Arguments that are meant to be consumed by the DMatrix constructor must be passed directly toxgb.DMatrixinstead (e.g. argument for categorical features or for feature names).Some arguments have been renamed (e.g. previous ‘watchlist’ is now ‘evals’, in line with the Python package).The format of the callbacks to pass toxgb.trainhas largely been re-written. See the documentation ofxgb.Callbackfor details. - Functionxgb.DMatrix():This function now accepts ‘data.frame’ inputs and determines which features are categorical from their types - anything with type ‘factor’ or ‘character’ will be considered as categorical. Note that when passing data to the ‘predict’ method, the ‘factor’ variables must have the same encoding (i.e. same levels) as XGBoost will not re-encode them for you.Whereas previously some arguments such as the type of the features had to be passed as a list under argument ‘info’, they", "prev_chunk_id": "chunk_329", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_331", "url": "https://xgboost.readthedocs.io/en/stable/R-package/migration_guide.html", "title": "Migrating code from previous XGBoost versions", "page_title": "Migrating code from previous XGBoost versions — xgboost 3.0.4 documentation", "breadcrumbs": "Migrating code from previous XGBoost versions", "content": "are all now direct function arguments to ‘xgb.DMatrix’ instead.There are now other varieties of DMatrix constructors that might better fit some uses cases -for example, there is ‘xgb.QuantileDMatrix’ which will quantize the features straight away (therefore avoiding redundant copies and reducing memory consumption) for the histogram method in XGBoost (but note that quantized DMatrices are not usable with the ‘exact’ sorted-indices method).Note that data for ‘label’ still needs to be encoded in the format consumed by the core XGBoost library - e.g. classification objectives should receive ‘label’ data encoded as zeros and ones.Creation of DMatrices from text files has been deprecated. - Functionxgb.cv():While previously this function accepted ‘data’ and ‘label’ similarly to the oldxgboost(), now it accepts onlyxgb.DMatrixobjects.The function’s scope has been expanded to support more functionalities offered by XGBoost, such as survival and learning-to-rank objectives. - Methodpredict:There are now two predict methods with different default arguments according to whether the model was produced throughxgboost()or throughxgb.train(). Functionxgboost()is more geared towards interactive usage, and thus the defaults for the ‘predict’ method on such objects (class “xgboost”) by default will perform more data validations such as checking that column names match and reordering them otherwise. The ‘predict’ method for models created throughxgb.train()(class “xgb.Booster”) has the same defaults as before, so for example it will not reorder columns to match names under the default behavior.The ‘predict’ method for objects of class “xgboost” (produced byxgboost(), not byxgb.train()) now can control the types of predictions to make through an argumenttype, similarly as the ‘predict’ methods in the ‘stats’ module of base R - e.g. one can now dopredict(model,type=\"class\"); while the ‘predict’ method for “xgb.Booster” objects (produced byxgb.train()), just like before, controls those through separate arguments such asoutputmargin.Previously, predictions using a subset of the trees were using base-0 indexing and range syntax mimicing Python’s ranges, whereas", "prev_chunk_id": "chunk_330", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_332", "url": "https://xgboost.readthedocs.io/en/stable/R-package/migration_guide.html", "title": "Migrating code from previous XGBoost versions", "page_title": "Migrating code from previous XGBoost versions — xgboost 3.0.4 documentation", "breadcrumbs": "Migrating code from previous XGBoost versions", "content": "now they use base-1 indexing as is common in R, and their behavior for ranges matches that of R’sseqfunction. Note that the syntax for “use all trees” and “use trees up to early-stopped criteria” have changed (see documentation for details). - Booster objects:The structure of these objects has been modified - now they are represented as a simple R “ALTLIST” (a special kind of ‘list’ object) with additional attributes.These objects now cannot be modified by adding more fields to them, but metadata for them can be added as attributes.The objects distinguish between two types of attributes:R-side attributes (which can be accessed and modified through R functionattributes(model)andattributes(model)$field<-val), which allow arbitrary objects. Many attributes are automatically added by the model building functions, such as evaluation logs (adata.tablewith metrics calculated per iteration), which previously were model fields.C-level attributes, which allow only JSON-compliant data and which can be accessed and set through functionxgb.attributes(model). These C-level attributes are shareable through serialized models in different XGBoost interfaces, while the R-level ones are specific to the R interface. Some attributes that are standard among language bindings of XGBoost, such as the best interation, are kept as C attributes.Previously, models that were just de-serialized from an on-disk format required calling method ‘xgb.Booster.complete’ on them to finish the full de-serialization process before being usable, or would otherwise call this method on their own automatically automatically at the first call to ‘predict’. Serialization is now handled more gracefully, and there are no additional functions/methods involved - i.e. if one saves a model to disk withsaveRDS()and then reads it back withreadRDS(), the model will be fully loaded straight away, without needing to call additional methods on it.", "prev_chunk_id": "chunk_331", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_333", "url": "https://xgboost.readthedocs.io/en/stable/R-package/migration_guide.html", "title": "Other recommendations", "page_title": "Migrating code from previous XGBoost versions — xgboost 3.0.4 documentation", "breadcrumbs": "Other recommendations", "content": "Other recommendations By default, XGBoost might recognize that some parameter has been removed or renamed from how it was in a previous version, and still accept the same function call as it used to do before with the renamed or removed arugments, but issuing a deprecation warning along the way that highlights the changes. These behaviors will be removed in future versions, and function calls which currently return deprecation warnings will stop working in the future, so in order to make sure that code calling XGBoost will still keep working, it should be ensured that it doesn’t issue deprecation warnings. Optionally, these deprecation warnings can be turned into errors (while still keeping other types of warnings as warnings) through an option “xgboost.strict_mode” - example: .. code-block:: r It can also be controlled through an environment variable XGB_STRICT_MODE=1, which takes precende over the R option - e.g.: .. code-block:: r It is highly recommended for package developers to enable this option during their package checks to ensure better compatibility with XGBoost.", "prev_chunk_id": "chunk_332", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_334", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/index.html", "title": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin", "page_title": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin — xgboost 3.0.4 documentation", "breadcrumbs": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin", "content": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin RAPIDS Memory Manager (RMM) library provides a collection of efficient memory allocators for NVIDIA GPUs. It is now possible to use XGBoost with memory allocators provided by RMM, by enabling the RMM integration plugin. The demos in this directory highlights one RMM allocator in particular: the pool sub-allocator. This allocator addresses the slow speed of cudaMalloc() by allocating a large chunk of memory upfront. Subsequent allocations will draw from the pool of already allocated memory and thus avoid the overhead of calling cudaMalloc() directly. See this GTC talk slides for more details. Before running the demos, ensure that XGBoost is compiled with the RMM plugin enabled. To do this, run CMake with option -DPLUGIN_RMM=ON (-DUSE_CUDA=ON also required): cmake -B build -S . -DUSE_CUDA=ON -DUSE_NCCL=ON -DPLUGIN_RMM=ON cmake --build build -j$(nproc) CMake will attempt to locate the RMM library in your build environment. You may choose to build RMM from the source, or install it using the Conda package manager. If CMake cannot find RMM, you should specify the location of RMM with the CMake prefix: # If using Conda: cmake -B build -S . -DUSE_CUDA=ON -DUSE_NCCL=ON -DPLUGIN_RMM=ON -DCMAKE_PREFIX_PATH=$CONDA_PREFIX # If using RMM installed with a custom location cmake -B build -S . -DUSE_CUDA=ON -DUSE_NCCL=ON -DPLUGIN_RMM=ON -DCMAKE_PREFIX_PATH=/path/to/rmm", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_335", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/index.html", "title": "Informing XGBoost about RMM pool", "page_title": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin — xgboost 3.0.4 documentation", "breadcrumbs": "Informing XGBoost about RMM pool", "content": "Informing XGBoost about RMM pool When XGBoost is compiled with RMM, most of the large size allocation will go through RMM allocators, but some small allocations in performance critical areas are using a different caching allocator so that we can have better control over memory allocation behavior. Users can override this behavior and force the use of rmm for all allocations by setting the global configuration use_rmm: with xgb.config_context(use_rmm=True): clf = xgb.XGBClassifier(tree_method=\"hist\", device=\"cuda\") Depending on the choice of memory pool size and the type of the allocator, this can add more consistency to memory usage but with slightly degraded performance impact.", "prev_chunk_id": "chunk_334", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_336", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/index.html", "title": "No Device Ordinal for Multi-GPU", "page_title": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin — xgboost 3.0.4 documentation", "breadcrumbs": "No Device Ordinal for Multi-GPU", "content": "No Device Ordinal for Multi-GPU Since with RMM the memory pool is pre-allocated on a specific device, changing the CUDA device ordinal in XGBoost can result in memory error cudaErrorIllegalAddress. Use the CUDA_VISIBLE_DEVICES environment variable instead of the device=\"cuda:1\" parameter for selecting device. For distributed training, the distributed computing frameworks like dask-cuda are responsible for device management. For Scala-Spark, see XGBoost4J-Spark-GPU Tutorial for more info.", "prev_chunk_id": "chunk_335", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_337", "url": "https://xgboost.readthedocs.io/en/stable/python/rmm-examples/index.html", "title": "Memory Over-Subscription", "page_title": "Using XGBoost with RAPIDS Memory Manager (RMM) plugin — xgboost 3.0.4 documentation", "breadcrumbs": "Memory Over-Subscription", "content": "Memory Over-Subscription The newer NVIDIA platforms like Grace-Hopper use NVLink-C2C, which allows the CPU and GPU to have a coherent memory model. Users can use the SamHeadroomMemoryResource in the latest RMM to utilize system memory for storing data. This can help XGBoost utilize memory from the host for GPU computation, but it may reduce performance due to slower CPU memory speed and page migration overhead. Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_336", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_338", "url": "https://xgboost.readthedocs.io/en/stable/python/gpu-examples/index.html", "title": "GPU Acceleration Demo", "page_title": "GPU Acceleration Demo — xgboost 3.0.4 documentation", "breadcrumbs": "GPU Acceleration Demo", "content": "GPU Acceleration Demo This is a collection of demonstration scripts to showcase the basic usage of GPU. Please see XGBoost GPU Support for more info. There are other demonstrations for distributed GPU training using dask or spark. Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_339", "url": "https://xgboost.readthedocs.io/en/stable/python/survival-examples/index.html", "title": "Survival Analysis Walkthrough", "page_title": "Survival Analysis Walkthrough — xgboost 3.0.4 documentation", "breadcrumbs": "Survival Analysis Walkthrough", "content": "Survival Analysis Walkthrough This is a collection of examples for using the XGBoost Python package for training survival models. For an introduction, see Survival Analysis with Accelerated Failure Time Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_340", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/index.html", "title": "XGBoost Dask Feature Walkthrough", "page_title": "XGBoost Dask Feature Walkthrough — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Dask Feature Walkthrough", "content": "XGBoost Dask Feature Walkthrough This directory contains some demonstrations for using dask with XGBoost. For an overview, see Distributed XGBoost with Dask Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_341", "url": "https://xgboost.readthedocs.io/en/stable/python/examples/index.html", "title": "XGBoost Python Feature Walkthrough", "page_title": "XGBoost Python Feature Walkthrough — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Python Feature Walkthrough", "content": "XGBoost Python Feature Walkthrough This is a collection of examples for using the XGBoost Python package. Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_342", "url": "https://xgboost.readthedocs.io/en/stable/python/model.html", "title": "Slice tree model", "page_title": "Model — xgboost 3.0.4 documentation", "breadcrumbs": "Slice tree model", "content": "Slice tree model When booster is set to gbtree or dart, XGBoost builds a tree model, which is a list of trees and can be sliced into multiple sub-models. from sklearn.datasets import make_classification num_classes = 3 X, y = make_classification(n_samples=1000, n_informative=5, n_classes=num_classes) dtrain = xgb.DMatrix(data=X, label=y) num_parallel_tree = 4 num_boost_round = 16 # total number of built trees is num_parallel_tree * num_classes * num_boost_round # We build a boosted random forest for classification here. booster = xgb.train({ 'num_parallel_tree': 4, 'subsample': 0.5, 'num_class': 3}, num_boost_round=num_boost_round, dtrain=dtrain) # This is the sliced model, containing [3, 7) forests # step is also supported with some limitations like negative step is invalid. sliced: xgb.Booster = booster[3:7] # Access individual tree layer trees = [_ for _ in booster] assert len(trees) == num_boost_round The sliced model is a copy of selected trees, that means the model itself is immutable during slicing. This feature is the basis of save_best option in early stopping callback. See Demo for prediction using individual trees and model slices for a worked example on how to combine prediction with sliced trees.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_343", "url": "https://xgboost.readthedocs.io/en/stable/python/callbacks.html", "title": "Callback Functions", "page_title": "Callback Functions — xgboost 3.0.4 documentation", "breadcrumbs": "Callback Functions", "content": "Callback Functions This document gives a basic walkthrough of callback API used in XGBoost Python package. In XGBoost 1.3, a new callback interface is designed for Python package, which provides the flexibility of designing various extension for training. Also, XGBoost has a number of pre-defined callbacks for supporting early stopping, checkpoints etc.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_344", "url": "https://xgboost.readthedocs.io/en/stable/python/callbacks.html", "title": "Using builtin callbacks", "page_title": "Callback Functions — xgboost 3.0.4 documentation", "breadcrumbs": "Using builtin callbacks", "content": "Using builtin callbacks By default, training methods in XGBoost have parameters like early_stopping_rounds and verbose/verbose_eval, when specified the training procedure will define the corresponding callbacks internally. For example, when early_stopping_rounds is specified, EarlyStopping callback is invoked inside iteration loop. You can also pass this callback function directly into XGBoost: D_train = xgb.DMatrix(X_train, y_train) D_valid = xgb.DMatrix(X_valid, y_valid) # Define a custom evaluation metric used for early stopping. def eval_error_metric(predt, dtrain: xgb.DMatrix): label = dtrain.get_label() r = np.zeros(predt.shape) gt = predt > 0.5 r[gt] = 1 - label[gt] le = predt <= 0.5 r[le] = label[le] return 'CustomErr', np.sum(r) # Specify which dataset and which metric should be used for early stopping. early_stop = xgb.callback.EarlyStopping(rounds=early_stopping_rounds, metric_name='CustomErr', data_name='Valid') booster = xgb.train( {'objective': 'binary:logistic', 'eval_metric': ['error', 'rmse'], 'tree_method': 'hist'}, D_train, evals=[(D_train, 'Train'), (D_valid, 'Valid')], feval=eval_error_metric, num_boost_round=1000, callbacks=[early_stop], verbose_eval=False) dump = booster.get_dump(dump_format='json') assert len(early_stop.stopping_history['Valid']['CustomErr']) == len(dump)", "prev_chunk_id": "chunk_343", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_345", "url": "https://xgboost.readthedocs.io/en/stable/python/callbacks.html", "title": "Defining your own callback", "page_title": "Callback Functions — xgboost 3.0.4 documentation", "breadcrumbs": "Defining your own callback", "content": "Defining your own callback XGBoost provides an callback interface class: TrainingCallback, user defined callbacks should inherit this class and override corresponding methods. There’s a working example in Demo for using and defining callback functions.", "prev_chunk_id": "chunk_344", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_346", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Python API Reference", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Python API Reference", "content": "Python API Reference This page gives the Python API reference of xgboost, please also refer to Python Package Introduction for more information about the Python package.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_347", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Core Data Structure", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Core Data Structure", "content": "Core Data Structure Core XGBoost Library.", "prev_chunk_id": "chunk_346", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_348", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Learning API", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Learning API", "content": "Learning API Training Library containing training routines.", "prev_chunk_id": "chunk_347", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_349", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Scikit-Learn API", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Scikit-Learn API", "content": "Scikit-Learn API Scikit-Learn Wrapper interface for XGBoost.", "prev_chunk_id": "chunk_348", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_350", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Plotting API", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Plotting API", "content": "Plotting API Plotting Library.", "prev_chunk_id": "chunk_349", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_351", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Callback API", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Callback API", "content": "Callback API Callback library containing training routines. See Callback Functions for a quick introduction.", "prev_chunk_id": "chunk_350", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_352", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "PySpark API", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "PySpark API", "content": "PySpark API PySpark XGBoost integration interface", "prev_chunk_id": "chunk_351", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_353", "url": "https://xgboost.readthedocs.io/en/stable/python/python_api.html", "title": "Collective", "page_title": "Python API Reference — xgboost 3.0.4 documentation", "breadcrumbs": "Collective", "content": "Collective XGBoost collective communication related API. Tracker for XGBoost collective.", "prev_chunk_id": "chunk_352", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_354", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Using the Scikit-Learn Estimator Interface", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Using the Scikit-Learn Estimator Interface", "content": "Using the Scikit-Learn Estimator Interface Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_355", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Overview", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "Overview In addition to the native interface, XGBoost features a sklearn estimator interface that conforms to sklearn estimator guideline. It supports regression, classification, and learning to rank. Survival training for the sklearn estimator interface is still working in progress. You can find some some quick start examples at Collection of examples for using sklearn interface. The main advantage of using sklearn interface is that it works with most of the utilities provided by sklearn like sklearn.model_selection.cross_validate(). Also, many other libraries recognize the sklearn estimator interface thanks to its popularity. With the sklearn estimator interface, we can train a classification model with only a couple lines of Python code. Here’s an example for training a classification model: from sklearn.datasets import load_breast_cancer from sklearn.model_selection import train_test_split import xgboost as xgb X, y = load_breast_cancer(return_X_y=True) X_train, X_test, y_train, y_test = train_test_split(X, y, stratify=y, random_state=94) # Use \"hist\" for constructing the trees, with early stopping enabled. clf = xgb.XGBClassifier(tree_method=\"hist\", early_stopping_rounds=2) # Fit the model, test sets are used for early stopping. clf.fit(X_train, y_train, eval_set=[(X_test, y_test)]) # Save model into JSON format. clf.save_model(\"clf.json\") The tree_method parameter specifies the method to use for constructing the trees, and the early_stopping_rounds parameter enables early stopping. Early stopping can help prevent overfitting and save time during training.", "prev_chunk_id": "chunk_354", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_356", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Early Stopping", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Early Stopping", "content": "Early Stopping As demonstrated in the previous example, early stopping can be enabled by the parameter early_stopping_rounds. Alternatively, there’s a callback function that can be used xgboost.callback.EarlyStopping to specify more details about the behavior of early stopping, including whether XGBoost should return the best model instead of the full stack of trees: early_stop = xgb.callback.EarlyStopping( rounds=2, metric_name='logloss', data_name='validation_0', save_best=True ) clf = xgb.XGBClassifier(tree_method=\"hist\", callbacks=[early_stop]) clf.fit(X_train, y_train, eval_set=[(X_test, y_test)]) At present, XGBoost doesn’t implement data spliting logic within the estimator and relies on the eval_set parameter of the xgboost.XGBModel.fit() method. If you want to use early stopping to prevent overfitting, you’ll need to manually split your data into training and testing sets using the sklearn.model_selection.train_test_split() function from the sklearn library. Some other machine learning algorithms, like those in sklearn, include early stopping as part of the estimator and may work with cross validation. However, using early stopping during cross validation may not be a perfect approach because it changes the model’s number of trees for each validation fold, leading to different model. A better approach is to retrain the model after cross validation using the best hyperparameters along with early stopping. If you want to experiment with idea of using cross validation with early stopping, here is a snippet to begin with: from sklearn.base import clone from sklearn.datasets import load_breast_cancer from sklearn.model_selection import StratifiedKFold, cross_validate import xgboost as xgb X, y = load_breast_cancer(return_X_y=True) def fit_and_score(estimator, X_train, X_test, y_train, y_test): \"\"\"Fit the estimator on the train set and score it on both sets\"\"\" estimator.fit(X_train, y_train, eval_set=[(X_test, y_test)]) train_score = estimator.score(X_train, y_train) test_score = estimator.score(X_test, y_test) return estimator, train_score, test_score cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=94) clf = xgb.XGBClassifier(tree_method=\"hist\", early_stopping_rounds=3) results = {} for train, test in cv.split(X, y): X_train = X[train] X_test = X[test] y_train = y[train] y_test = y[test] est, train_score, test_score", "prev_chunk_id": "chunk_355", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_357", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Early Stopping", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Early Stopping", "content": "= fit_and_score( clone(clf), X_train, X_test, y_train, y_test ) results[est] = (train_score, test_score)", "prev_chunk_id": "chunk_356", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_358", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Obtaining the native booster object", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Obtaining the native booster object", "content": "Obtaining the native booster object The sklearn estimator interface primarily facilitates training and doesn’t implement all features available in XGBoost. For instance, in order to have cached predictions, xgboost.DMatrix needs to be used with xgboost.Booster.predict(). One can obtain the booster object from the sklearn interface using xgboost.XGBModel.get_booster(): booster = clf.get_booster() print(booster.num_boosted_rounds())", "prev_chunk_id": "chunk_357", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_359", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Prediction", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction When early stopping is enabled, prediction functions including the xgboost.XGBModel.predict(), xgboost.XGBModel.score(), and xgboost.XGBModel.apply() methods will use the best model automatically. Meaning the xgboost.XGBModel.best_iteration is used to specify the range of trees used in prediction. To have cached results for incremental prediction, please use the xgboost.Booster.predict() method instead.", "prev_chunk_id": "chunk_358", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_360", "url": "https://xgboost.readthedocs.io/en/stable/python/sklearn_estimator.html", "title": "Number of parallel threads", "page_title": "Using the Scikit-Learn Estimator Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Number of parallel threads", "content": "Number of parallel threads When working with XGBoost and other sklearn tools, you can specify how many threads you want to use by using the n_jobs parameter. By default, XGBoost uses all the available threads on your computer, which can lead to some interesting consequences when combined with other sklearn functions like sklearn.model_selection.cross_validate(). If both XGBoost and sklearn are set to use all threads, your computer may start to slow down significantly due to something called “thread thrashing”. To avoid this, you can simply set the n_jobs parameter for XGBoost to None (which uses all threads) and the n_jobs parameter for sklearn to 1. This way, both programs will be able to work together smoothly without causing any unnecessary computer strain.", "prev_chunk_id": "chunk_359", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_361", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Python Package Introduction", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Python Package Introduction", "content": "Python Package Introduction This document gives a basic walkthrough of the xgboost package for Python. The Python package is consisted of 3 different interfaces, including native interface, scikit-learn interface and dask interface. For introduction to dask interface please see Distributed XGBoost with Dask. List of other Helpful Links - XGBoost Python Feature Walkthrough - Python API Reference Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_362", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Install XGBoost", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Install XGBoost", "content": "Install XGBoost To install XGBoost, follow instructions in Installation Guide. To verify your installation, run the following in Python: import xgboost as xgb", "prev_chunk_id": "chunk_361", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_363", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Data Interface", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Data Interface", "content": "Data Interface The XGBoost Python module is able to load data from many different types of data format including both CPU and GPU data structures. For a complete list of supported data types, please reference the Supported data structures for various XGBoost functions. For a detailed description of text input formats, please visit Text Input Format of DMatrix. The input data is stored in a DMatrix object. For the sklearn estimator interface, a DMatrix or a QuantileDMatrix is created depending on the chosen algorithm and the input, see the sklearn API reference for details. We will illustrate some of the basic input types with the DMatrix here. - To load a NumPy array intoDMatrix:data=np.random.rand(5,10)# 5 entities, each contains 10 featureslabel=np.random.randint(2,size=5)# binary targetdtrain=xgb.DMatrix(data,label=label) - To load ascipy.sparsearray intoDMatrix:csr=scipy.sparse.csr_matrix((dat,(row,col)))dtrain=xgb.DMatrix(csr) - To load a Pandas data frame intoDMatrix:data=pandas.DataFrame(np.arange(12).reshape((4,3)),columns=['a','b','c'])label=pandas.DataFrame(np.random.randint(2,size=4))dtrain=xgb.DMatrix(data,label=label) - SavingDMatrixinto a XGBoost binary file will make loading faster:dtrain=xgb.DMatrix('train.svm.txt?format=libsvm')dtrain.save_binary('train.buffer') - Missing values can be replaced by a default value in theDMatrixconstructor:dtrain=xgb.DMatrix(data,label=label,missing=np.NaN) - Weights can be set when needed:w=np.random.rand(5,1)dtrain=xgb.DMatrix(data,label=label,missing=np.NaN,weight=w) When performing ranking tasks, the number of weights should be equal to number of groups. - To load a LIBSVM text file or a XGBoost binary file intoDMatrix:dtrain=xgb.DMatrix('train.svm.txt?format=libsvm')dtest=xgb.DMatrix('test.svm.buffer')The parser in XGBoost has limited functionality. When using Python interface, it’s recommended to use sklearnload_svmlight_fileor other similar utilites than XGBoost’s builtin parser. - To load a CSV file intoDMatrix:# label_column specifies the index of the column containing the true labeldtrain=xgb.DMatrix('train.csv?format=csv&label_column=0')dtest=xgb.DMatrix('test.csv?format=csv&label_column=0')The parser in XGBoost has limited functionality. When using Python interface, it’s recommended to use pandasread_csvor other similar utilites than XGBoost’s builtin parser.", "prev_chunk_id": "chunk_362", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_364", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Markers", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Markers", "content": "Markers - T: Supported. - F: Not supported. - NE: Invalid type for the use case. For instance,pd.Seriescan not be multi-target label. - NPA: Support with the help of numpy array. - AT: Support with the help of arrow table. - CPA: Support with the help of cupy array. - SciCSR: Support with the help of scripy sparse CSR. The conversion to scipy CSR may or may not be possible. Raise a type error if conversion fails. - FF: We can look forward to having its support in recent future if requested. - empty: To be filled in.", "prev_chunk_id": "chunk_363", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_365", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Table Header", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Table Header", "content": "Table Header - Xmeans predictor matrix. - Meta info: label, weight, etc. - Multi Label: 2-dim label for multi-target. - Others: Anything else that we don’t list here explicitly including formats likelil,dia,bsr. XGBoost will try to convert it into scipy csr.", "prev_chunk_id": "chunk_364", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_366", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Support Matrix", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Support Matrix", "content": "Support Matrix Name | DMatrix X | QuantileDMatrix X | Sklearn X | Meta Info | Inplace prediction | Multi Label numpy.ndarray | T | T | T | T | T | T scipy.sparse.csr | T | T | T | NE | T | F scipy.sparse.csc | T | F | T | NE | F | F scipy.sparse.coo | SciCSR | F | SciCSR | NE | F | F uri | T | F | F | F | NE | F list | NPA | NPA | NPA | NPA | NPA | T tuple | NPA | NPA | NPA | NPA | NPA | T pandas.DataFrame | NPA | NPA | NPA | NPA | NPA | NPA pandas.Series | NPA | NPA | NPA | NPA | NPA | NE cudf.DataFrame | T | T | T | T | T | T cudf.Series | T | T | T | T | FF | NE cupy.ndarray | T | T | T | T | T | T torch.Tensor | T | T | T | T | T | T dlpack | CPA | CPA | | CPA | FF | FF modin.DataFrame | NPA | FF | NPA | NPA | FF | modin.Series | NPA | FF | NPA | NPA | FF | pyarrow.Table | T | T | T | T | T | T polars.DataFrame | AT | AT | AT | AT | AT | AT polars.LazyFrame (WARN) | AT | AT | AT | AT | AT | AT polars.Series | AT | AT | AT | AT | AT | NE __array__ | NPA | F | NPA | NPA | H | Others | SciCSR | F | | F |", "prev_chunk_id": "chunk_365", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_367", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Support Matrix", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Support Matrix", "content": "F | The polars LazyFrame.collect supports many configurations, ranging from the choice of query engine to type coercion. XGBoost simply uses the default parameter. Please run collect to obtain the DataFrame before passing it into XGBoost for finer control over the behaviour.", "prev_chunk_id": "chunk_366", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_368", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Setting Parameters", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Setting Parameters", "content": "Setting Parameters XGBoost can use either a list of pairs or a dictionary to set parameters. For instance: - Booster parametersparam={'max_depth':2,'eta':1,'objective':'binary:logistic'}param['nthread']=4param['eval_metric']='auc' - You can also specify multiple eval metrics:param['eval_metric']=['auc','ams@0']# alternatively:# plst = param.items()# plst += [('eval_metric', 'ams@0')] - Specify validations set to watch performanceevallist=[(dtrain,'train'),(dtest,'eval')]", "prev_chunk_id": "chunk_367", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_369", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Training", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Training", "content": "Training Training a model requires a parameter list and data set. num_round = 10 bst = xgb.train(param, dtrain, num_round, evallist) After training, the model can be saved. bst.save_model('0001.model') The model and its feature map can also be dumped to a text file. # dump model bst.dump_model('dump.raw.txt') # dump model with feature map bst.dump_model('dump.raw.txt', 'featmap.txt') A saved model can be loaded as follows: bst = xgb.Booster({'nthread': 4}) # init model bst.load_model('model.bin') # load model data Methods including update and boost from xgboost.Booster are designed for internal usage only. The wrapper function xgboost.train does some pre-configuration including setting up caches and some other parameters.", "prev_chunk_id": "chunk_368", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_370", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Early Stopping", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Early Stopping", "content": "Early Stopping If you have a validation set, you can use early stopping to find the optimal number of boosting rounds. Early stopping requires at least one set in evals. If there’s more than one, it will use the last. train(..., evals=evals, early_stopping_rounds=10) The model will train until the validation score stops improving. Validation error needs to decrease at least every early_stopping_rounds to continue training. If early stopping occurs, the model will have two additional fields: bst.best_score, bst.best_iteration. Note that xgboost.train() will return a model from the last iteration, not the best one. This works with both metrics to minimize (RMSE, log loss, etc.) and to maximize (MAP, NDCG, AUC). Note that if you specify more than one evaluation metric the last one in param['eval_metric'] is used for early stopping.", "prev_chunk_id": "chunk_369", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_371", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Prediction", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Prediction", "content": "Prediction A model that has been trained or loaded can perform predictions on data sets. # 7 entities, each contains 10 features data = np.random.rand(7, 10) dtest = xgb.DMatrix(data) ypred = bst.predict(dtest) If early stopping is enabled during training, you can get predictions from the best iteration with bst.best_iteration: ypred = bst.predict(dtest, iteration_range=(0, bst.best_iteration + 1))", "prev_chunk_id": "chunk_370", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_372", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Plotting", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Plotting", "content": "Plotting You can use plotting module to plot importance and output tree. To plot importance, use xgboost.plot_importance(). This function requires matplotlib to be installed. xgb.plot_importance(bst) To plot the output tree via matplotlib, use xgboost.plot_tree(), specifying the ordinal number of the target tree. This function requires graphviz and matplotlib. xgb.plot_tree(bst, num_trees=2) When you use IPython, you can use the xgboost.to_graphviz() function, which converts the target tree to a graphviz instance. The graphviz instance is automatically rendered in IPython. xgb.to_graphviz(bst, num_trees=2)", "prev_chunk_id": "chunk_371", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_373", "url": "https://xgboost.readthedocs.io/en/stable/python/python_intro.html", "title": "Scikit-Learn interface", "page_title": "Python Package Introduction — xgboost 3.0.4 documentation", "breadcrumbs": "Scikit-Learn interface", "content": "Scikit-Learn interface XGBoost provides an easy to use scikit-learn interface for some pre-defined models including regression, classification and ranking. See Using the Scikit-Learn Estimator Interface for more info. # Use \"hist\" for training the model. reg = xgb.XGBRegressor(tree_method=\"hist\", device=\"cuda\") # Fit the model using predictor X and response y. reg.fit(X, y) # Save model into JSON format. reg.save_model(\"regressor.json\") User can still access the underlying booster model when needed: booster: xgb.Booster = reg.get_booster()", "prev_chunk_id": "chunk_372", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_374", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Privacy Preserving Inference with Concrete ML", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Privacy Preserving Inference with Concrete ML", "content": "Privacy Preserving Inference with Concrete ML Concrete ML is a specialized library developed by Zama that allows the execution of machine learning models on encrypted data through Fully Homomorphic Encryption (FHE), thereby preserving data privacy. To use models such as XGBClassifier, use the following import: from concrete.ml.sklearn import XGBClassifier", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_375", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Performing Privacy Preserving Inference", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Performing Privacy Preserving Inference", "content": "Performing Privacy Preserving Inference Initialization of a XGBClassifier can be done as follows: classifier = XGBClassifier(n_bits=6, [other_hyperparameters]) where n_bits determines the precision of the input features. Note that a higher value of n_bits increases the precision of the input features and possibly the final model accuracy but also ends up with longer FHE execution time. Other hyper-parameters that exist in xgboost library can be used.", "prev_chunk_id": "chunk_374", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_376", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Model Training and Compilation", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Model Training and Compilation", "content": "Model Training and Compilation As commonly used in scikit-learn like models, it can be trained with the .fit() method. classifier.fit(X_train, y_train) After training, the model can be compiled with a calibration dataset, potentially a subset of the training data: classifier.compile(X_calibrate) This calibration dataset, X_calibrate, is used in Concrete ML compute the precision (bit-width) of each intermediate value in the model. This is a necessary step to optimize the equivalent FHE circuit.", "prev_chunk_id": "chunk_375", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_377", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "FHE Simulation and Execution", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "FHE Simulation and Execution", "content": "FHE Simulation and Execution To verify model accuracy in encrypted computations, you can run an FHE simulation: predictions = classifier.predict(X_test, fhe=\"simulate\") This simulation can be used to evaluate the model. The resulting accuracy of this simulation step is representative of the actual FHE execution without having to pay the cost of an actual FHE execution. When the model is ready, actual Fully Homomorphic Encryption execution can be performed: predictions = classifier.predict(X_test, fhe=\"execute\") Note that using FHE=”execute” is a convenient way to assess the model in FHE, but for real deployment, functions to encrypt (on the client), run in FHE (on the server), and finally decrypt (on the client) have to be used for end-to-end privacy-preserving inferences. Concrete ML provides a deployment API to facilitate this process, ensuring end-to-end privacy. To go further in the deployment API you can read: - thedeployment documentation - thedeployment notebook", "prev_chunk_id": "chunk_376", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_378", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Parameter Tuning in Concrete ML", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Parameter Tuning in Concrete ML", "content": "Parameter Tuning in Concrete ML Concrete ML is compatible with standard scikit-learn pipelines such as GridSearchCV or any other hyper-parameter tuning techniques.", "prev_chunk_id": "chunk_377", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_379", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Examples and Demos", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Examples and Demos", "content": "Examples and Demos - Sentiment analysis (based on transformers + xgboost) - XGBoost Classifier - XGBoost Regressor", "prev_chunk_id": "chunk_378", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_380", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/privacy_preserving.html", "title": "Conclusion", "page_title": "Privacy Preserving Inference with Concrete ML — xgboost 3.0.4 documentation", "breadcrumbs": "Conclusion", "content": "Conclusion Concrete ML provides a framework for executing privacy-preserving inferences by leveraging Fully Homomorphic Encryption, allowing secure and private computations on encrypted data. More information and examples are given in the Concrete ML documentation.", "prev_chunk_id": "chunk_379", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_381", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/intercept.html", "title": "Intercept", "page_title": "Intercept — xgboost 3.0.4 documentation", "breadcrumbs": "Intercept", "content": "Intercept Since 2.0.0, XGBoost supports estimating the model intercept (named base_score) automatically based on targets upon training. The behavior can be controlled by setting base_score to a constant value. The following snippet disables the automatic estimation: import xgboost as xgb reg = xgb.XGBRegressor() reg.set_params(base_score=0.5) In addition, here 0.5 represents the value after applying the inverse link function. See the end of the document for a description. Other than the base_score, users can also provide global bias via the data field base_margin, which is a vector or a matrix depending on the task. With multi-output and multi-class, the base_margin is a matrix with size (n_samples, n_targets) or (n_samples, n_classes). import xgboost as xgb from sklearn.datasets import make_regression X, y = make_regression() reg = xgb.XGBRegressor() reg.fit(X, y) # Request for raw prediction m = reg.predict(X, output_margin=True) reg_1 = xgb.XGBRegressor() # Feed the prediction into the next model reg_1.fit(X, y, base_margin=m) reg_1.predict(X, base_margin=m) It specifies the bias for each sample and can be used for stacking an XGBoost model on top of other models, see Demo for boosting from prediction for a worked example. When base_margin is specified, it automatically overrides the base_score parameter. If you are stacking XGBoost models, then the usage should be relatively straightforward, with the previous model providing raw prediction and a new model using the prediction as bias. For more customized inputs, users need to take extra care of the link function. Let \\(F\\) be the model and \\(g\\) be the link function, since base_score is overridden when sample-specific base_margin is available, we will omit it here: When base margin \\(b\\) is provided, it’s added to the raw model output \\(F\\): and the output of the final model is: Using the gamma deviance objective reg:gamma as an example, which has a log link function, hence: As a result,", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_382", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/intercept.html", "title": "Intercept", "page_title": "Intercept — xgboost 3.0.4 documentation", "breadcrumbs": "Intercept", "content": "if you are feeding outputs from models like GLM with a corresponding objective function, make sure the outputs are not yet transformed by the inverse link (activation). In the case of base_score (intercept), it can be accessed through save_config() after estimation. Unlike the base_margin, the returned value represents a value after applying inverse link. With logistic regression and the logit link function as an example, given the base_score as 0.5, \\(g(intercept) = logit(0.5) = 0\\) is added to the raw model output: and 0.5 is the same as \\(base\\_score = g^{-1}(0) = 0.5\\). This is more intuitive if you remove the model and consider only the intercept, which is estimated before the model is fitted: For some objectives like MAE, there are close solutions, while for others it’s estimated with one step Newton method.", "prev_chunk_id": "chunk_381", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_383", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/intercept.html", "title": "Offset", "page_title": "Intercept — xgboost 3.0.4 documentation", "breadcrumbs": "Offset", "content": "Offset The base_margin is a form of offset in GLM. Using the Poisson objective as an example, we might want to model the rate instead of the count: And the offset is defined as log link applied to the exposure variable: \\(\\ln{exposure}\\). Let \\(c\\) be the count and \\(\\gamma\\) be the exposure, substituting the response \\(y\\) in our previous formulation of base margin: Substitute \\(g\\) with \\(\\ln\\) for Poisson regression: We have: As you can see, we can use the base_margin for modeling with offset similar to GLMs", "prev_chunk_id": "chunk_382", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_384", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Advanced Usage of Custom Objectives", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Advanced Usage of Custom Objectives", "content": "Advanced Usage of Custom Objectives Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_385", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Overview", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "Overview XGBoost allows optimizing custom user-defined functions based on gradients and Hessians provided by the user for the desired objective function. In order for a custom objective to work as intended: - The function to optimize must be smooth and twice differentiable. - The function must be additive with respect to rows / observations, such as a likelihood function with i.i.d. assumptions. - The range of the scores for the function must be unbounded (i.e. it should not work exclusively with positive numbers, for example). - The function must be convex. Note that, if the Hessian has negative values, they will be clipped, which will likely result in a model that does not fit the function well. - For multi-output objectives, there should not be dependencies between different targets (i.e. Hessian should be diagonal for each row). Some of these limitations can nevertheless be worked around by foregoing the true Hessian of the function, using something else instead such as an approximation with better properties - convergence might be slower when not using the true Hessian of a function, but many theoretical guarantees should still hold and result in usable models. For example, XGBoost’s internal implementation of multionomial logistic regression uses an upper bound on the Hessian with diagonal structure instead of the true Hessian which is a full square matrix for each row in the data. This tutorial provides some suggestions for use-cases that do not perfectly fit the criteria outlined above, by showing how to solve a Dirichlet regression parameterized by concentrations. A Dirichlet regression model poses certain challenges for XGBoost: - Concentration parameters must be positive. An easy way to achieve this is by applying an ‘exp’ transform on raw unbounded values, but in such case the objective becomes non-convex. Furthermore, note that this function is not", "prev_chunk_id": "chunk_384", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_386", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Overview", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "in the exponential family, unlike typical distributions used for GLM models. - The Hessian has dependencies between targets - that is, for a Dirichlet distribution with ‘k’ parameters, each row will have a full Hessian matrix of dimensions[k,k]. - An optimal intercept for this type of model would involve a vector of values rather than the same value for every target. In order to use this type of model as a custom objetive: - It’s possible to use the expected Hessian (a.k.a. the Fisher information matrix or expected information) instead of the true Hessian. The expected Hessian is always positive semi-definite for an additive likelihood, even if the true Hessian isn’t. - It’s possible to use an upper bound on the expected Hessian with a diagonal structure, such that a second-order approximation under this diagonal bound would always yield greater or equal function values than under the non-diagonal expected Hessian. - Since thebase_scoreparameter that XGBoost uses for an intercept is limited to a scalar, one can use thebase_marginfunctionality instead, but note that using it requires a bit more effort.", "prev_chunk_id": "chunk_385", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_387", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Dirichlet Regression Formulae", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Dirichlet Regression Formulae", "content": "Dirichlet Regression Formulae The Dirichlet distribution is a generalization of the Beta distribution to multiple dimensions. It models proportions data in which the values sum to 1, and is typically used as part of composite models (e.g. Dirichlet-multinomial) or as a prior in Bayesian models, but it also can be used on its own for proportions data for example. Its likelihood for a given observation with values y and a given prediction x is given as follows: Where: In this case, we want to optimize the negative of the log-likelihood summed across rows. The resulting function, gradient and Hessian could be implemented as follows: Convince yourself that the implementation is correct:", "prev_chunk_id": "chunk_386", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_388", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Dirichlet Regression as Objective Function", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Dirichlet Regression as Objective Function", "content": "Dirichlet Regression as Objective Function As mentioned earlier, the Hessian of this function is problematic for XGBoost: it can have a negative determinant, and might even have negative values in the diagonal, which is problematic for optimization methods - in XGBoost, those values would be clipped and the resulting model might not end up producing sensible predictions. A potential workaround is to use the expected Hessian instead - that is, the expected outer product of the gradient if the response variable were distributed according to what is predicted. See the Wikipedia article for more information: https://en.wikipedia.org/wiki/Fisher_information In general, for objective functions in the exponential family, this is easy to obtain from the gradient of the link function and the variance of the probability distribution, but for other functions in general, it might involve other types of calculations (e.g. covariances and covariances of logarithms for Dirichlet). It nevertheless results in a form very similar to the Hessian. One can also see from the differences here that, at an optimal point (gradient being zero), the expected and true Hessian for Dirichlet will match, which is a nice property for optimization (i.e. the Hessian will be positive at a stationary point, which means it will be a minimum rather than a maximum or saddle point). But note that this is still not usable for XGBoost, since the expected Hessian, just like the true Hessian, has shape [nrows, k, k], while XGBoost requires something with shape [nrows, k]. One may use the diagonal of the expected Hessian for each row, but it’s possible to do better: one can use instead an upper bound with diagonal structure, since it should lead to better convergence properties, just like for other Hessian-based optimization methods. In the absence of any obvious way of obtaining an upper bound, a", "prev_chunk_id": "chunk_387", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_389", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Dirichlet Regression as Objective Function", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Dirichlet Regression as Objective Function", "content": "possibility here is to construct such a bound numerically based directly on the definition of a diagonally dominant matrix: https://en.wikipedia.org/wiki/Diagonally_dominant_matrix That is: take the absolute value of the expected Hessian for each row of the data, and sum by rows of the [k, k]-shaped Hessian for that row in the data: (note: the calculation can be made more efficiently than what is shown here by not calculating the full matrix, and in R, by making the rows be the last dimension and transposing after the fact) With all these pieces in place, one can now frame this model into the format required for XGBoost’s custom objectives: And for an evaluation metric monitoring based on the Dirichlet log-likelihood:", "prev_chunk_id": "chunk_388", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_390", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Practical Example", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Practical Example", "content": "Practical Example A good source for test datasets for proportions data is the R package DirichletReg: https://cran.r-project.org/package=DirichletReg For this example, we’ll now use the Arctic Lake dataset (Aitchison, J. (2003). The Statistical Analysis of Compositional Data. The Blackburn Press, Caldwell, NJ.), taken from the DirichletReg R package, which consists of 39 rows with one predictor variable ‘depth’ and a three-valued response variable denoting the sediment composition of the measurements in this arctic lake (sand, silt, clay). The data: Fitting an XGBoost model and making predictions: Should produce an evaluation log as follows (note: the function is decreasing as expected - but unlike other objectives, the minimum value here can reach below zero): [0] Train-dirichlet_ll:-40.25009 [1] Train-dirichlet_ll:-47.69122 [2] Train-dirichlet_ll:-52.64620 [3] Train-dirichlet_ll:-56.36977 [4] Train-dirichlet_ll:-59.33048 [5] Train-dirichlet_ll:-61.93359 [6] Train-dirichlet_ll:-64.17280 [7] Train-dirichlet_ll:-66.29709 [8] Train-dirichlet_ll:-68.21001 [9] Train-dirichlet_ll:-70.03442 One can confirm that the obtained yhat resembles the actual concentrations to a large degree, beyond what would be expected from random predictions by a simple look at both yhat and Y. For better results, one might want to add an intercept. XGBoost only allows using scalars for intercepts, but for a vector-valued model, the optimal intercept should also have vector form. This can be done by supplying base_margin instead - unlike the intercept, one must specifically supply values for every row here, and said base_margin must be supplied again at the moment of making predictions (i.e. does not get added automatically like base_score does). For the case of a Dirichlet model, the optimal intercept can be obtained efficiently using a general solver (e.g. SciPy’s Newton solver) with dedicated likelihood, gradient and Hessian functions for just the intercept part. Further, note that if one frames it instead as bounded optimization without applying ‘exp’ transform to the concentrations, it becomes instead a convex problem, for which the true Hessian", "prev_chunk_id": "chunk_389", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_391", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/advanced_custom_obj.html", "title": "Practical Example", "page_title": "Advanced Usage of Custom Objectives — xgboost 3.0.4 documentation", "breadcrumbs": "Practical Example", "content": "can be used without issues in other classes of solvers. For simplicity, this example will nevertheless reuse the same likelihood and gradient functions that were defined earlier alongside with SciPy’s / R’s L-BFGS solver to obtain the optimal vector-valued intercept: Now fitting a model again, this time with the intercept: [0] Train-dirichlet_ll:-37.01861 [1] Train-dirichlet_ll:-42.86120 [2] Train-dirichlet_ll:-46.55133 [3] Train-dirichlet_ll:-49.15111 [4] Train-dirichlet_ll:-51.02638 [5] Train-dirichlet_ll:-52.53880 [6] Train-dirichlet_ll:-53.77409 [7] Train-dirichlet_ll:-54.88851 [8] Train-dirichlet_ll:-55.95961 [9] Train-dirichlet_ll:-56.95497 For this small example problem, predictions should be very similar between the two and the version without intercepts achieved a lower objective function in the training data (for the Python version at least), but for more serious usage with real-world data, one is likely to observe better results when adding the intercepts.", "prev_chunk_id": "chunk_390", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_392", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Custom Objective and Evaluation Metric", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Custom Objective and Evaluation Metric", "content": "Custom Objective and Evaluation Metric Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_393", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Overview", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "Overview XGBoost is designed to be an extensible library. One way to extend it is by providing our own objective function for training and corresponding metric for performance monitoring. This document introduces implementing a customized elementwise evaluation metric and objective for XGBoost. Although the introduction uses Python for demonstration, the concepts should be readily applicable to other language bindings. See also the advanced usage example for more information about limitations and workarounds for more complex objetives: Advanced Usage of Custom Objectives In the following two sections, we will provide a step by step walk through of implementing the Squared Log Error (SLE) objective function: and its default metric Root Mean Squared Log Error(RMSLE): Although XGBoost has native support for said functions, using it for demonstration provides us the opportunity of comparing the result from our own implementation and the one from XGBoost internal for learning purposes. After finishing this tutorial, we should be able to provide our own functions for rapid experiments. And at the end, we will provide some notes on non-identity link function along with examples of using custom metric and objective with the scikit-learn interface. If we compute the gradient of said objective function: As well as the hessian (the second derivative of the objective):", "prev_chunk_id": "chunk_392", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_394", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Customized Objective Function", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Customized Objective Function", "content": "Customized Objective Function During model training, the objective function plays an important role: provide gradient information, both first and second order gradient, based on model predictions and observed data labels (or targets). Therefore, a valid objective function should accept two inputs, namely prediction and labels. For implementing SLE, we define: import numpy as np import xgboost as xgb from typing import Tuple def gradient(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: '''Compute the gradient squared log error.''' y = dtrain.get_label() return (np.log1p(predt) - np.log1p(y)) / (predt + 1) def hessian(predt: np.ndarray, dtrain: xgb.DMatrix) -> np.ndarray: '''Compute the hessian for squared log error.''' y = dtrain.get_label() return ((-np.log1p(predt) + np.log1p(y) + 1) / np.power(predt + 1, 2)) def squared_log(predt: np.ndarray, dtrain: xgb.DMatrix) -> Tuple[np.ndarray, np.ndarray]: '''Squared Log Error objective. A simplified version for RMSLE used as objective function. ''' predt[predt < -1] = -1 + 1e-6 grad = gradient(predt, dtrain) hess = hessian(predt, dtrain) return grad, hess In the above code snippet, squared_log is the objective function we want. It accepts a numpy array predt as model prediction, and the training DMatrix for obtaining required information, including labels and weights (not used here). This objective is then used as a callback function for XGBoost during training by passing it as an argument to xgb.train: xgb.train({'tree_method': 'hist', 'seed': 1994}, # any other tree method is fine. dtrain=dtrain, num_boost_round=10, obj=squared_log) Notice that in our definition of the objective, whether we subtract the labels from the prediction or the other way around is important. If you find the training error goes up instead of down, this might be the reason.", "prev_chunk_id": "chunk_393", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_395", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Customized Metric Function", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Customized Metric Function", "content": "Customized Metric Function So after having a customized objective, we might also need a corresponding metric to monitor our model’s performance. As mentioned above, the default metric for SLE is RMSLE. Similarly we define another callback like function as the new metric: def rmsle(predt: np.ndarray, dtrain: xgb.DMatrix) -> Tuple[str, float]: ''' Root mean squared log error metric.''' y = dtrain.get_label() predt[predt < -1] = -1 + 1e-6 elements = np.power(np.log1p(y) - np.log1p(predt), 2) return 'PyRMSLE', float(np.sqrt(np.sum(elements) / len(y))) Since we are demonstrating in Python, the metric or objective need not be a function, any callable object should suffice. Similar to the objective function, our metric also accepts predt and dtrain as inputs, but returns the name of the metric itself and a floating point value as the result. After passing it into XGBoost as argument of custom_metric parameter: xgb.train({'tree_method': 'hist', 'seed': 1994, 'disable_default_eval_metric': 1}, dtrain=dtrain, num_boost_round=10, obj=squared_log, custom_metric=rmsle, evals=[(dtrain, 'dtrain'), (dtest, 'dtest')], evals_result=results) We will be able to see XGBoost printing something like: [0] dtrain-PyRMSLE:1.37153 dtest-PyRMSLE:1.31487 [1] dtrain-PyRMSLE:1.26619 dtest-PyRMSLE:1.20899 [2] dtrain-PyRMSLE:1.17508 dtest-PyRMSLE:1.11629 [3] dtrain-PyRMSLE:1.09836 dtest-PyRMSLE:1.03871 [4] dtrain-PyRMSLE:1.03557 dtest-PyRMSLE:0.977186 [5] dtrain-PyRMSLE:0.985783 dtest-PyRMSLE:0.93057 ... Notice that the parameter disable_default_eval_metric is used to suppress the default metric in XGBoost. For fully reproducible source code and comparison plots, see Demo for defining a custom regression objective and metric.", "prev_chunk_id": "chunk_394", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_396", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Reverse Link Function", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Reverse Link Function", "content": "Reverse Link Function When using builtin objective, the raw prediction is transformed according to the objective function. When a custom objective is provided XGBoost doesn’t know its link function so the user is responsible for making the transformation for both objective and custom evaluation metric. For objective with identity link like squared error this is trivial, but for other link functions like log link or inverse link the difference is significant. For the Python package, the behaviour of prediction can be controlled by the output_margin parameter in predict function. When using the custom_metric parameter without a custom objective, the metric function will receive transformed prediction since the objective is defined by XGBoost. However, when the custom objective is also provided along with that metric, then both the objective and custom metric will receive raw prediction. The following example provides a comparison between two different behavior with a multi-class classification model. Firstly we define 2 different Python metric functions implementing the same underlying metric for comparison, merror_with_transform is used when custom objective is also used, otherwise the simpler merror is preferred since XGBoost can perform the transformation itself. import xgboost as xgb import numpy as np def merror_with_transform(predt: np.ndarray, dtrain: xgb.DMatrix): \"\"\"Used when custom objective is supplied.\"\"\" y = dtrain.get_label() n_classes = predt.size // y.shape[0] # Like custom objective, the predt is untransformed leaf weight when custom objective # is provided. # With the use of `custom_metric` parameter in train function, custom metric receives # raw input only when custom objective is also being used. Otherwise custom metric # will receive transformed prediction. assert predt.shape == (d_train.num_row(), n_classes) out = np.zeros(dtrain.num_row()) for r in range(predt.shape[0]): i = np.argmax(predt[r]) out[r] = i assert y.shape == out.shape errors = np.zeros(dtrain.num_row()) errors[y != out] = 1.0 return 'PyMError', np.sum(errors) / dtrain.num_row() The above function", "prev_chunk_id": "chunk_395", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_397", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Reverse Link Function", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Reverse Link Function", "content": "is only needed when we want to use custom objective and XGBoost doesn’t know how to transform the prediction. The normal implementation for multi-class error function is: def merror(predt: np.ndarray, dtrain: xgb.DMatrix): \"\"\"Used when there's no custom objective.\"\"\" # No need to do transform, XGBoost handles it internally. errors = np.zeros(dtrain.num_row()) errors[y != out] = 1.0 return 'PyMError', np.sum(errors) / dtrain.num_row() Next we need the custom softprob objective: def softprob_obj(predt: np.ndarray, data: xgb.DMatrix): \"\"\"Loss function. Computing the gradient and approximated hessian (diagonal). Reimplements the `multi:softprob` inside XGBoost. \"\"\" # Full implementation is available in the Python demo script linked below ... return grad, hess Lastly we can train the model using obj and custom_metric parameters: Xy = xgb.DMatrix(X, y) booster = xgb.train( {\"num_class\": kClasses, \"disable_default_eval_metric\": True}, m, num_boost_round=kRounds, obj=softprob_obj, custom_metric=merror_with_transform, evals_result=custom_results, evals=[(m, \"train\")], ) Or if you don’t need the custom objective and just want to supply a metric that’s not available in XGBoost: booster = xgb.train( { \"num_class\": kClasses, \"disable_default_eval_metric\": True, \"objective\": \"multi:softmax\", }, m, num_boost_round=kRounds, # Use a simpler metric implementation. custom_metric=merror, evals_result=custom_results, evals=[(m, \"train\")], ) We use multi:softmax to illustrate the differences of transformed prediction. With softprob the output prediction array has shape (n_samples, n_classes) while for softmax it’s (n_samples, ). A demo for multi-class objective function is also available at Demo for creating customized multi-class objective function. Also, see Intercept for some more explanation.", "prev_chunk_id": "chunk_396", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_398", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/custom_metric_obj.html", "title": "Scikit-Learn Interface", "page_title": "Custom Objective and Evaluation Metric — xgboost 3.0.4 documentation", "breadcrumbs": "Scikit-Learn Interface", "content": "Scikit-Learn Interface The scikit-learn interface of XGBoost has some utilities to improve the integration with standard scikit-learn functions. For instance, after XGBoost 1.6.0 users can use the cost function (not scoring functions) from scikit-learn out of the box: from sklearn.datasets import load_diabetes from sklearn.metrics import mean_absolute_error X, y = load_diabetes(return_X_y=True) reg = xgb.XGBRegressor( tree_method=\"hist\", eval_metric=mean_absolute_error, ) reg.fit(X, y, eval_set=[(X, y)]) Also, for custom objective function, users can define the objective without having to access DMatrix: def softprob_obj(labels: np.ndarray, predt: np.ndarray) -> Tuple[np.ndarray, np.ndarray]: rows = labels.shape[0] classes = predt.shape[1] grad = np.zeros((rows, classes), dtype=float) hess = np.zeros((rows, classes), dtype=float) eps = 1e-6 for r in range(predt.shape[0]): target = labels[r] p = softmax(predt[r, :]) for c in range(predt.shape[1]): g = p[c] - 1.0 if c == target else p[c] h = max((2.0 * p[c] * (1.0 - p[c])).item(), eps) grad[r, c] = g hess[r, c] = h grad = grad.reshape((rows * classes, 1)) hess = hess.reshape((rows * classes, 1)) return grad, hess clf = xgb.XGBClassifier(tree_method=\"hist\", objective=softprob_obj)", "prev_chunk_id": "chunk_397", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_399", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Notes on Parameter Tuning", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Notes on Parameter Tuning", "content": "Notes on Parameter Tuning Parameter tuning is a dark art in machine learning, the optimal parameters of a model can depend on many scenarios. So it is impossible to create a comprehensive guide for doing so. This document tries to provide some guideline for parameters in XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_400", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Understanding Bias-Variance Tradeoff", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Understanding Bias-Variance Tradeoff", "content": "Understanding Bias-Variance Tradeoff If you take a machine learning or statistics course, this is likely to be one of the most important concepts. When we allow the model to get more complicated (e.g. more depth), the model has better ability to fit the training data, resulting in a less biased model. However, such complicated model requires more data to fit. Most of parameters in XGBoost are about bias variance tradeoff. The best model should trade the model complexity with its predictive power carefully. Parameters Documentation will tell you whether each parameter will make the model more conservative or not. This can be used to help you turn the knob between complicated model and simple model.", "prev_chunk_id": "chunk_399", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_401", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Control Overfitting", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Control Overfitting", "content": "Control Overfitting When you observe high training accuracy, but low test accuracy, it is likely that you encountered overfitting problem. There are in general two ways that you can control overfitting in XGBoost: - The first way is to directly control model complexity.This includesmax_depth,min_child_weight,gamma,max_cat_thresholdand other similar regularization parameters. SeeXGBoost Parametersfor a comprehensive set of parameters.Set a constantbase_scorebased on your own criteria. SeeInterceptfor more info. - The second way is to add randomness to make training robust to noise.This includessubsampleandcolsample_bytree, which may be used with boosting RFnum_parallel_tree.You can also reduce stepsizeeta, possibly with a training callback. Remember to increasenum_roundwhen you do so.", "prev_chunk_id": "chunk_400", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_402", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Handle Imbalanced Dataset", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Handle Imbalanced Dataset", "content": "Handle Imbalanced Dataset For common cases such as ads clickthrough log, the dataset is extremely imbalanced. This can affect the training of XGBoost model, and there are two ways to improve it. - If you care only about the overall performance metric (AUC) of your predictionBalance the positive and negative weights viascale_pos_weightUse AUC for evaluation - If you care about predicting the right probabilityIn such a case, you cannot re-balance the datasetSet parametermax_delta_stepto a finite number (say 1) to help convergence", "prev_chunk_id": "chunk_401", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_403", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Use Hyper Parameter Optimization (HPO) Frameworks", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Use Hyper Parameter Optimization (HPO) Frameworks", "content": "Use Hyper Parameter Optimization (HPO) Frameworks Tuning models is a sophisticated task and there are advanced frameworks to help you. For examples, some meta estimators in scikit-learn like sklearn.model_selection.HalvingGridSearchCV can help guide the search process. Optuna is another great option and there are many more based on different branches of statistics.", "prev_chunk_id": "chunk_402", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_404", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Know Your Data", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Know Your Data", "content": "Know Your Data It cannot be stressed enough the importance of understanding the data, sometimes that’s all it takes to get a good model. Many solutions use a simple XGBoost tree model without much tuning and emphasize the data pre-processing step. XGBoost can help feature selection by providing both a global feature importance score and sample feature importance with SHAP value. Also, there are parameters specifically targeting categorical features, and tasks like survival and ranking. Feel free to explore them.", "prev_chunk_id": "chunk_403", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_405", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/param_tuning.html", "title": "Reducing Memory Usage", "page_title": "Notes on Parameter Tuning — xgboost 3.0.4 documentation", "breadcrumbs": "Reducing Memory Usage", "content": "Reducing Memory Usage If you are using a HPO library like sklearn.model_selection.GridSearchCV, please control the number of threads it can use. It’s best to let XGBoost to run in parallel instead of asking GridSearchCV to run multiple experiments at the same time. For instance, creating a fold of data for cross validation can consume a significant amount of memory: # This creates a copy of dataset. X and X_train are both in memory at the same time. # This happens for every thread at the same time if you run `GridSearchCV` with # `n_jobs` larger than 1 X_train, X_test, y_train, y_test = train_test_split(X, y) df = pd.DataFrame() # This creates a new copy of the dataframe, even if you specify the inplace parameter new_df = df.drop(...) array = np.array(...) # This may or may not make a copy of the data, depending on the type of the data array.astype(np.float32) # np by default uses double, do you actually need it? array = np.array(...) You can find some more specific memory reduction practices scattered through the documents For instances: Distributed XGBoost with Dask, XGBoost GPU Support. However, before going into these, being conscious about making data copies is a good starting point. It usually consumes a lot more memory than people expect.", "prev_chunk_id": "chunk_404", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_406", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "C API Tutorial", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "C API Tutorial", "content": "C API Tutorial In this tutorial, we are going to install XGBoost library & configure the CMakeLists.txt file of our C/C++ application to link XGBoost library with our application. Later on, we will see some useful tips for using C API and code snippets as examples to use various functions available in C API to perform basic task like loading, training model & predicting on test dataset. For API reference, please visit XGBoost C Package", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_407", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Requirements", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Requirements", "content": "Requirements Install CMake - Follow the cmake installation documentation for instructions. Install Conda - Follow the conda installation documentation for instructions", "prev_chunk_id": "chunk_406", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_408", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Install XGBoost on conda environment", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Install XGBoost on conda environment", "content": "Install XGBoost on conda environment Run the following commands on your terminal. The below commands will install the XGBoost in your XGBoost folder of the repository cloned # clone the XGBoost repository & its submodules git clone --recursive https://github.com/dmlc/xgboost cd xgboost # Activate the Conda environment, into which we'll install XGBoost conda activate [env_name] # Build the compiled version of XGBoost inside the build folder cmake -B build -S . -DCMAKE_INSTALL_PREFIX=$CONDA_PREFIX # install XGBoost in your conda environment (usually under [your home directory]/miniconda3) cmake --build build --target install", "prev_chunk_id": "chunk_407", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_409", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Configure CMakeList.txt file of your application to link with XGBoost", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Configure CMakeList.txt file of your application to link with XGBoost", "content": "Configure CMakeList.txt file of your application to link with XGBoost Here, we assume that your C++ application is using CMake for builds. Use find_package() and target_link_libraries() in your application’s CMakeList.txt to link with the XGBoost library: cmake_minimum_required(VERSION 3.18) project(your_project_name LANGUAGES C CXX VERSION your_project_version) find_package(xgboost REQUIRED) add_executable(your_project_name /path/to/project_file.c) target_link_libraries(your_project_name xgboost::xgboost) To ensure that CMake can locate the XGBoost library, supply -DCMAKE_PREFIX_PATH=$CONDA_PREFIX argument when invoking CMake. This option instructs CMake to locate the XGBoost library in $CONDA_PREFIX, which is where your Conda environment is located. # Activate the Conda environment where we previously installed XGBoost conda activate [env_name] # Invoke CMake with CMAKE_PREFIX_PATH cmake -B build -S . -DCMAKE_PREFIX_PATH=$CONDA_PREFIX # Build your application cmake --build build", "prev_chunk_id": "chunk_408", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_410", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Useful Tips To Remember", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Useful Tips To Remember", "content": "Useful Tips To Remember Below are some useful tips while using C API: - Error handling: Always check the return value of the C API functions. - In a C application: Use the following macro to guard all calls to XGBoost’s C API functions. The macro prints all the error/ exception occurred: 1#define safe_xgboost(call) { \\ 2 int err = (call); \\ 3 if (err != 0) { \\ 4 fprintf(stderr, \"%s:%d: error in %s: %s\\n\", __FILE__, __LINE__, #call, XGBGetLastError()); \\ 5 exit(1); \\ 6 } \\ 7} In your application, wrap all C API function calls with the macro as follows: DMatrixHandle train; safe_xgboost(XGDMatrixCreateFromFile(\"/path/to/training/dataset/\", silent, &train)); - In a C++ application: modify the macrosafe_xgboostto throw an exception upon an error. 1#define safe_xgboost(call) { \\ 2 int err = (call); \\ 3 if (err != 0) { \\ 4 throw std::runtime_error(std::string(__FILE__) + \":\" + std::to_string(__LINE__) + \\ 5 \": error in \" + #call + \":\" + XGBGetLastError()); \\ 6 } \\ 7} - Assertion technique: It works both in C/ C++. If expression evaluates to 0 (false), then the expression, source code filename, and line number are sent to the standard error, and then abort() function is called. It can be used to test assumptions made by you in the code. DMatrixHandle dmat; assert( XGDMatrixCreateFromFile(\"training_data.libsvm\", 0, &dmat) == 0); - Always remember to free the allocated space by BoosterHandle & DMatrixHandle appropriately: 1#include <assert.h> 2#include <stdio.h> 3#include <stdlib.h> 4#include <xgboost/c_api.h> 5 6int main(int argc, char** argv) { 7 int silent = 0; 8 9 BoosterHandle booster; 10 11 // do something with booster 12 13 //free the memory 14 XGBoosterFree(booster); 15 16 DMatrixHandle DMatrixHandle_param; 17 18 // do something with DMatrixHandle_param 19 20 // free the memory 21 XGDMatrixFree(DMatrixHandle_param); 22 23 return 0; 24} - For tree models, it", "prev_chunk_id": "chunk_409", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_411", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Useful Tips To Remember", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Useful Tips To Remember", "content": "is important to use consistent data formats during training and scoring/ predicting otherwise it will result in wrong outputs. Example if we our training data is indensematrixformat then your prediction dataset should also be adensematrixor if training inlibsvmformat then dataset for prediction should also be inlibsvmformat. - Always use strings for setting values to the parameters in booster handle object. The parameter value can be of any data type (e.g. int, char, float, double, etc), but they should always be encoded as strings. BoosterHandle booster; XGBoosterSetParam(booster, \"parameter_name\", \"0.1\");", "prev_chunk_id": "chunk_410", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_412", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Sample examples along with Code snippet to use C API functions", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Sample examples along with Code snippet to use C API functions", "content": "Sample examples along with Code snippet to use C API functions - If the dataset is available in a file, it can be loaded into aDMatrixobject using theXGDMatrixCreateFromFile() DMatrixHandle data; // handle to DMatrix // Load the data from file & store it in data variable of DMatrixHandle datatype safe_xgboost(XGDMatrixCreateFromFile(\"/path/to/file/filename\", silent, &data)); - You can also create aDMatrixobject from a 2D Matrix using theXGDMatrixCreateFromMat() 1// 1D matrix 2const int data1[] = { 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 }; 3 4// 2D matrix 5const int ROWS = 6, COLS = 3; 6const int data2[ROWS][COLS] = { {1, 2, 3}, {2, 4, 6}, {3, -1, 9}, {4, 8, -1}, {2, 5, 1}, {0, 1, 5} }; 7DMatrixHandle dmatrix1, dmatrix2; 8// Pass the matrix, no of rows & columns contained in the matrix variable 9// here '0' represents the missing value in the matrix dataset 10// dmatrix variable will contain the created DMatrix using it 11safe_xgboost(XGDMatrixCreateFromMat(data1, 1, 50, 0, &dmatrix)); 12// here -1 represents the missing value in the matrix dataset 13safe_xgboost(XGDMatrixCreateFromMat(data2, ROWS, COLS, -1, &dmatrix2)); - Create a Booster object for training & testing on dataset usingXGBoosterCreate() 1BoosterHandle booster; 2const int eval_dmats_size; 3// We assume that training and test data have been loaded into 'train' and 'test' 4DMatrixHandle eval_dmats[eval_dmats_size] = {train, test}; 5safe_xgboost(XGBoosterCreate(eval_dmats, eval_dmats_size, &booster)); - For eachDMatrixobject, set the labels usingXGDMatrixSetFloatInfo(). Later you can access the label usingXGDMatrixGetFloatInfo(). 1const int ROWS=5, COLS=3; 2const int data[ROWS][COLS] = { {1, 2, 3}, {2, 4, 6}, {3, -1, 9}, {4, 8, -1}, {2, 5, 1}, {0, 1, 5} };", "prev_chunk_id": "chunk_411", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_413", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Sample examples along with Code snippet to use C API functions", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Sample examples along with Code snippet to use C API functions", "content": "3DMatrixHandle dmatrix; 4 5safe_xgboost(XGDMatrixCreateFromMat(data, ROWS, COLS, -1, &dmatrix)); 6 7// variable to store labels for the dataset created from above matrix 8float labels[ROWS]; 9 10for (int i = 0; i < ROWS; i++) { 11 labels[i] = i; 12} 13 14// Loading the labels 15safe_xgboost(XGDMatrixSetFloatInfo(dmatrix, \"label\", labels, ROWS)); 16 17// reading the labels and store the length of the result 18bst_ulong result_len; 19 20// labels result 21const float *result; 22 23safe_xgboost(XGDMatrixGetFloatInfo(dmatrix, \"label\", &result_len, &result)); 24 25for(unsigned int i = 0; i < result_len; i++) { 26 printf(\"label[%i] = %f\\n\", i, result[i]); 27} - Set the parameters for theBoosterobject according to the requirement usingXGBoosterSetParam(). Check out the full list of parameters availablehere. 1BoosterHandle booster; 2safe_xgboost(XGBoosterSetParam(booster, \"booster\", \"gblinear\")); 3// default max_depth =6 4safe_xgboost(XGBoosterSetParam(booster, \"max_depth\", \"3\")); 5// default eta = 0.3 6safe_xgboost(XGBoosterSetParam(booster, \"eta\", \"0.1\")); - Train & evaluate the model usingXGBoosterUpdateOneIter()andXGBoosterEvalOneIter()respectively. 1int num_of_iterations = 20; 2const char* eval_names[eval_dmats_size] = {\"train\", \"test\"}; 3const char* eval_result = NULL; 4 5for (int i = 0; i < num_of_iterations; ++i) { 6 // Update the model performance for each iteration 7 safe_xgboost(XGBoosterUpdateOneIter(booster, i, train)); 8 9 // Give the statistics for the learner for training & testing dataset in terms of error after each iteration 10 safe_xgboost(XGBoosterEvalOneIter(booster, i, eval_dmats, eval_names, eval_dmats_size, &eval_result)); 11 printf(\"%s\\n\", eval_result); 12} - Predict the result on a test set usingXGBoosterPredictFromDMatrix() 1char const config[] = 2 \"{\\\"training\\\": false, \\\"type\\\": 0, \" 3 \"\\\"iteration_begin\\\": 0, \\\"iteration_end\\\": 0, \\\"strict_shape\\\": false}\"; 4/* Shape of output prediction */ 5uint64_t const* out_shape; 6/* Dimension of output prediction */ 7uint64_t out_dim; 8/* Pointer to a thread local contiguous array, assigned in prediction function. */ 9float const* out_result = NULL; 10safe_xgboost( 11 XGBoosterPredictFromDMatrix(booster, dmatrix, config, &out_shape, &out_dim, &out_result)); 12 13for (unsigned int i = 0; i < output_length; i++){ 14 printf(\"prediction[%i] = %f \\n\", i, output_result[i]); 15} - Get the", "prev_chunk_id": "chunk_412", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_414", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/c_api_tutorial.html", "title": "Sample examples along with Code snippet to use C API functions", "page_title": "C API Tutorial — xgboost 3.0.4 documentation", "breadcrumbs": "Sample examples along with Code snippet to use C API functions", "content": "number of features in your dataset usingXGBoosterGetNumFeature(). 1bst_ulong num_of_features = 0; 2 3// Assuming booster variable of type BoosterHandle is already declared 4// and dataset is loaded and trained on booster 5// storing the results in num_of_features variable 6safe_xgboost(XGBoosterGetNumFeature(booster, &num_of_features)); 7 8// Printing number of features by type conversion of num_of_features variable from bst_ulong to unsigned long 9printf(\"num_feature: %lu\\n\", (unsigned long)(num_of_features)); - Save the model usingXGBoosterSaveModel() BoosterHandle booster; const char *model_path = \"/path/of/model.json\"; safe_xgboost(XGBoosterSaveModel(booster, model_path)); - Load the model usingXGBoosterLoadModel() 1BoosterHandle booster; 2const char *model_path = \"/path/of/model.json\"; 3 4// create booster handle first 5safe_xgboost(XGBoosterCreate(NULL, 0, &booster)); 6 7// set the model parameters here 8 9// load model 10safe_xgboost(XGBoosterLoadModel(booster, model_path)); 11 12// predict the model here - Free all the internal structure used in your code usingXGDMatrixFree()andXGBoosterFree(). This step is important to prevent memory leak. safe_xgboost(XGDMatrixFree(dmatrix)); safe_xgboost(XGBoosterFree(booster));", "prev_chunk_id": "chunk_413", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_415", "url": "https://xgboost.readthedocs.io/en/stable/python/survival-examples/aft_survival_viz_demo.html", "title": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model.", "page_title": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model. — xgboost 3.0.4 documentation", "breadcrumbs": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model.", "content": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model. This demo uses 1D toy data and visualizes how XGBoost fits a tree ensemble. The ensemble model starts out as a flat line and evolves into a step function in order to account for all ranged labels. import matplotlib.pyplot as plt import numpy as np import xgboost as xgb plt.rcParams.update({\"font.size\": 13}) # Function to visualize censored labels def plot_censored_labels( X: np.ndarray, y_lower: np.ndarray, y_upper: np.ndarray ) -> None: def replace_inf(x: np.ndarray, target_value: float) -> np.ndarray: x[np.isinf(x)] = target_value return x plt.plot(X, y_lower, \"o\", label=\"y_lower\", color=\"blue\") plt.plot(X, y_upper, \"o\", label=\"y_upper\", color=\"fuchsia\") plt.vlines( X, ymin=replace_inf(y_lower, 0.01), ymax=replace_inf(y_upper, 1000.0), label=\"Range for y\", color=\"gray\", ) # Toy data X = np.array([1, 2, 3, 4, 5]).reshape((-1, 1)) INF = np.inf y_lower = np.array([10, 15, -INF, 30, 100]) y_upper = np.array([INF, INF, 20, 50, INF]) # Visualize toy data plt.figure(figsize=(5, 4)) plot_censored_labels(X, y_lower, y_upper) plt.ylim((6, 200)) plt.legend(loc=\"lower right\") plt.title(\"Toy data\") plt.xlabel(\"Input feature\") plt.ylabel(\"Label\") plt.yscale(\"log\") plt.tight_layout() plt.show(block=True) # Will be used to visualize XGBoost model grid_pts = np.linspace(0.8, 5.2, 1000).reshape((-1, 1)) # Train AFT model using XGBoost dmat = xgb.DMatrix(X) dmat.set_float_info(\"label_lower_bound\", y_lower) dmat.set_float_info(\"label_upper_bound\", y_upper) params = {\"max_depth\": 3, \"objective\": \"survival:aft\", \"min_child_weight\": 0} accuracy_history = [] class PlotIntermediateModel(xgb.callback.TrainingCallback): \"\"\"Custom callback to plot intermediate models.\"\"\" def __init__(self) -> None: super().__init__() def after_iteration( self, model: xgb.Booster, epoch: int, evals_log: xgb.callback.TrainingCallback.EvalsLog, ) -> bool: \"\"\"Run after training is finished.\"\"\" # Compute y_pred = prediction using the intermediate model, at current boosting # iteration y_pred = model.predict(dmat) # \"Accuracy\" = the number of data points whose ranged label (y_lower, y_upper) # includes the corresponding predicted label (y_pred) acc = np.sum( np.logical_and(y_pred >= y_lower, y_pred <= y_upper) / len(X) * 100 ) accuracy_history.append(acc) # Plot ranged labels as well as predictions by the model plt.subplot(5, 3, epoch + 1) plot_censored_labels(X, y_lower,", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_416", "url": "https://xgboost.readthedocs.io/en/stable/python/survival-examples/aft_survival_viz_demo.html", "title": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model.", "page_title": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model. — xgboost 3.0.4 documentation", "breadcrumbs": "Visual demo for survival analysis (regression) with Accelerated Failure Time (AFT) model.", "content": "y_upper) y_pred_grid_pts = model.predict(xgb.DMatrix(grid_pts)) plt.plot( grid_pts, y_pred_grid_pts, \"r-\", label=\"XGBoost AFT model\", linewidth=4 ) plt.title(\"Iteration {}\".format(epoch), x=0.5, y=0.8) plt.xlim((0.8, 5.2)) plt.ylim((1 if np.min(y_pred) < 6 else 6, 200)) plt.yscale(\"log\") return False res: xgb.callback.TrainingCallback.EvalsLog = {} plt.figure(figsize=(12, 13)) bst = xgb.train( params, dmat, num_boost_round=15, evals=[(dmat, \"train\")], evals_result=res, callbacks=[PlotIntermediateModel()], ) plt.tight_layout() plt.legend( loc=\"lower center\", ncol=4, bbox_to_anchor=(0.5, 0), bbox_transform=plt.gcf().transFigure, ) plt.tight_layout() # Plot negative log likelihood over boosting iterations plt.figure(figsize=(8, 3)) plt.subplot(1, 2, 1) plt.plot(res[\"train\"][\"aft-nloglik\"], \"b-o\", label=\"aft-nloglik\") plt.xlabel(\"# Boosting Iterations\") plt.legend(loc=\"best\") # Plot \"accuracy\" over boosting iterations # \"Accuracy\" = the number of data points whose ranged label (y_lower, y_upper) includes # the corresponding predicted label (y_pred) plt.subplot(1, 2, 2) plt.plot(accuracy_history, \"r-o\", label=\"Accuracy (%)\") plt.xlabel(\"# Boosting Iterations\") plt.legend(loc=\"best\") plt.tight_layout() plt.show() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_415", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_417", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/dask_learning_to_rank.html", "title": "Learning to rank with the Dask Interface", "page_title": "Learning to rank with the Dask Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Learning to rank with the Dask Interface", "content": "Learning to rank with the Dask Interface This is a demonstration of using XGBoost for learning to rank tasks using the MSLR_10k_letor dataset. For more infomation about the dataset, please visit its description page. See Distributed Training for a general description for distributed learning to rank and Learning to Rank for Dask-specific features. from __future__ import annotations import argparse import os from contextlib import contextmanager from typing import Generator import dask import numpy as np from dask import dataframe as dd from distributed import Client, LocalCluster, wait from sklearn.datasets import load_svmlight_file from xgboost import dask as dxgb def load_mslr_10k( device: str, data_path: str, cache_path: str ) -> tuple[dd.DataFrame, dd.DataFrame, dd.DataFrame]: \"\"\"Load the MSLR10k dataset from data_path and save parquet files in the cache_path.\"\"\" root_path = os.path.expanduser(args.data) cache_path = os.path.expanduser(args.cache) # Use only the Fold1 for demo: # Train, Valid, Test # {S1,S2,S3}, S4, S5 fold = 1 if not os.path.exists(cache_path): os.mkdir(cache_path) fold_path = os.path.join(root_path, f\"Fold{fold}\") train_path = os.path.join(fold_path, \"train.txt\") valid_path = os.path.join(fold_path, \"vali.txt\") test_path = os.path.join(fold_path, \"test.txt\") X_train, y_train, qid_train = load_svmlight_file( train_path, query_id=True, dtype=np.float32 ) columns = [f\"f{i}\" for i in range(X_train.shape[1])] X_train = dd.from_array(X_train.toarray(), columns=columns) y_train = y_train.astype(np.int32) qid_train = qid_train.astype(np.int32) X_train[\"y\"] = dd.from_array(y_train) X_train[\"qid\"] = dd.from_array(qid_train) X_train.to_parquet(os.path.join(cache_path, \"train\"), engine=\"pyarrow\") X_valid, y_valid, qid_valid = load_svmlight_file( valid_path, query_id=True, dtype=np.float32 ) X_valid = dd.from_array(X_valid.toarray(), columns=columns) y_valid = y_valid.astype(np.int32) qid_valid = qid_valid.astype(np.int32) X_valid[\"y\"] = dd.from_array(y_valid) X_valid[\"qid\"] = dd.from_array(qid_valid) X_valid.to_parquet(os.path.join(cache_path, \"valid\"), engine=\"pyarrow\") X_test, y_test, qid_test = load_svmlight_file( test_path, query_id=True, dtype=np.float32 ) X_test = dd.from_array(X_test.toarray(), columns=columns) y_test = y_test.astype(np.int32) qid_test = qid_test.astype(np.int32) X_test[\"y\"] = dd.from_array(y_test) X_test[\"qid\"] = dd.from_array(qid_test) X_test.to_parquet(os.path.join(cache_path, \"test\"), engine=\"pyarrow\") df_train = dd.read_parquet( os.path.join(cache_path, \"train\"), calculate_divisions=True ) df_valid = dd.read_parquet( os.path.join(cache_path, \"valid\"), calculate_divisions=True ) df_test = dd.read_parquet( os.path.join(cache_path, \"test\"), calculate_divisions=True ) return df_train, df_valid, df_test def ranking_demo(client: Client, args: argparse.Namespace) -> None: \"\"\"Learning to rank with data sorted locally.\"\"\" df_tr, df_va, _", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_418", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/dask_learning_to_rank.html", "title": "Learning to rank with the Dask Interface", "page_title": "Learning to rank with the Dask Interface — xgboost 3.0.4 documentation", "breadcrumbs": "Learning to rank with the Dask Interface", "content": "= load_mslr_10k(args.device, args.data, args.cache) X_train: dd.DataFrame = df_tr[df_tr.columns.difference([\"y\", \"qid\"])] y_train = df_tr[[\"y\", \"qid\"]] Xy_train = dxgb.DaskQuantileDMatrix(client, X_train, y_train.y, qid=y_train.qid) X_valid: dd.DataFrame = df_va[df_va.columns.difference([\"y\", \"qid\"])] y_valid = df_va[[\"y\", \"qid\"]] Xy_valid = dxgb.DaskQuantileDMatrix( client, X_valid, y_valid.y, qid=y_valid.qid, ref=Xy_train ) # Upon training, you will see a performance warning about sorting data based on # query groups. dxgb.train( client, {\"objective\": \"rank:ndcg\", \"device\": args.device}, Xy_train, evals=[(Xy_train, \"Train\"), (Xy_valid, \"Valid\")], num_boost_round=100, ) def ranking_wo_split_demo(client: Client, args: argparse.Namespace) -> None: \"\"\"Learning to rank with data partitioned according to query groups.\"\"\" df_tr, df_va, df_te = load_mslr_10k(args.device, args.data, args.cache) X_tr = df_tr[df_tr.columns.difference([\"y\", \"qid\"])] X_va = df_va[df_va.columns.difference([\"y\", \"qid\"])] # `allow_group_split=False` makes sure data is partitioned according to the query # groups. ltr = dxgb.DaskXGBRanker(allow_group_split=False, device=args.device) ltr.client = client ltr = ltr.fit( X_tr, df_tr.y, qid=df_tr.qid, eval_set=[(X_tr, df_tr.y), (X_va, df_va.y)], eval_qid=[df_tr.qid, df_va.qid], verbose=True, ) df_te = df_te.persist() wait([df_te]) X_te = df_te[df_te.columns.difference([\"y\", \"qid\"])] predt = ltr.predict(X_te) y = client.compute(df_te.y) wait([predt, y]) @contextmanager def gen_client(device: str) -> Generator[Client, None, None]: match device: case \"cuda\": from dask_cuda import LocalCUDACluster with LocalCUDACluster() as cluster: with Client(cluster) as client: with dask.config.set( { \"array.backend\": \"cupy\", \"dataframe.backend\": \"cudf\", } ): yield client case \"cpu\": with LocalCluster() as cluster: with Client(cluster) as client: yield client if __name__ == \"__main__\": parser = argparse.ArgumentParser( description=\"Demonstration of learning to rank using XGBoost.\" ) parser.add_argument( \"--data\", type=str, help=\"Root directory of the MSLR-WEB10K data.\", required=True, ) parser.add_argument( \"--cache\", type=str, help=\"Directory for caching processed data.\", required=True, ) parser.add_argument(\"--device\", choices=[\"cpu\", \"cuda\"], default=\"cpu\") parser.add_argument( \"--no-split\", action=\"store_true\", help=\"Flag to indicate query groups should not be split.\", ) args = parser.parse_args() with gen_client(args.device) as client: if args.no_split: ranking_wo_split_demo(client, args) else: ranking_demo(client, args) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_417", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_419", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/forward_logging.html", "title": "Example of forwarding evaluation logs to the client", "page_title": "Example of forwarding evaluation logs to the client — xgboost 3.0.4 documentation", "breadcrumbs": "Example of forwarding evaluation logs to the client", "content": "Example of forwarding evaluation logs to the client The example runs on GPU. Two classes are defined to show how to use Dask builtins to forward the logs to the client process. import logging import dask import distributed from dask import array as da from dask_cuda import LocalCUDACluster from distributed import Client from xgboost import dask as dxgb from xgboost.callback import EvaluationMonitor def _get_logger() -> logging.Logger: logger = logging.getLogger(\"[xgboost.dask]\") logger.setLevel(logging.INFO) if not logger.hasHandlers(): handler = logging.StreamHandler() logger.addHandler(handler) return logger class ForwardLoggingMonitor(EvaluationMonitor): def __init__( self, client: Client, rank: int = 0, period: int = 1, ) -> None: \"\"\"Print the evaluation result at each iteration. The default monitor in the native interface logs the result to the Dask scheduler process. This class can be used to forward the logging to the client process. Important: see the `client` parameter for more info. Parameters ---------- client : Distributed client. This must be the top-level client. The class uses :py:meth:`distributed.Client.forward_logging` in conjunction with the Python :py:mod:`logging` module to forward the evaluation results to the client process. It has undefined behaviour if called in a nested task. As a result, client-side logging is not enabled by default. \"\"\" client.forward_logging(_get_logger().name) super().__init__( rank=rank, period=period, logger=lambda msg: _get_logger().info(msg.strip()), ) class WorkerEventMonitor(EvaluationMonitor): \"\"\"Use :py:meth:`distributed.print` to forward the log. A downside is that not only all clients connected to the cluster can see the log, the logs are also printed on the worker. If you use a local cluster, the log is duplicated. \"\"\" def __init__(self, rank: int = 0, period: int = 1) -> None: super().__init__( rank=rank, period=period, logger=lambda msg: distributed.print(msg.strip()) ) def hist_train( client: Client, X: da.Array, y: da.Array, monitor: EvaluationMonitor ) -> da.Array: # `DaskQuantileDMatrix` is used instead of `DaskDMatrix`, be careful that it can not # be used for anything else other than as a training", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_420", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/forward_logging.html", "title": "Example of forwarding evaluation logs to the client", "page_title": "Example of forwarding evaluation logs to the client — xgboost 3.0.4 documentation", "breadcrumbs": "Example of forwarding evaluation logs to the client", "content": "DMatrix, unless a reference is # specified. See the `ref` argument of `DaskQuantileDMatrix`. dtrain = dxgb.DaskQuantileDMatrix(client, X, y) output = dxgb.train( client, # Make sure the device is set to CUDA. {\"tree_method\": \"hist\", \"device\": \"cuda\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], # Use the monitor to forward the log. callbacks=[monitor], # Disable the internal logging and prefer the client-side `EvaluationMonitor`. verbose_eval=False, ) bst = output[\"booster\"] history = output[\"history\"] prediction = dxgb.predict(client, bst, X) print(\"Evaluation history:\", history) return prediction if __name__ == \"__main__\": # `LocalCUDACluster` is used for assigning GPU to XGBoost processes. Here # `n_workers` represents the number of GPUs since we use one GPU per worker process. with LocalCUDACluster(n_workers=2, threads_per_worker=4) as cluster: # Create client from cluster, set the backend to GPU array (cupy). with Client(cluster) as client, dask.config.set({\"array.backend\": \"cupy\"}): # Generate some random data for demonstration rng = da.random.default_rng(1) m = 2**18 n = 100 X = rng.uniform(size=(m, n), chunks=(128**2, -1)) y = X.sum(axis=1) # Use forwarding, the client must be the top client. monitor: EvaluationMonitor = ForwardLoggingMonitor(client) hist_train(client, X, y, monitor).compute() # Use distributed.print, the logs in this demo are duplicated as the same # log is printed in all workers along with the client. monitor = WorkerEventMonitor() hist_train(client, X, y, monitor).compute() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_419", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_421", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/gpu_training.html", "title": "Example of training with Dask on GPU", "page_title": "Example of training with Dask on GPU — xgboost 3.0.4 documentation", "breadcrumbs": "Example of training with Dask on GPU", "content": "Example of training with Dask on GPU import dask import dask_cudf from dask import array as da from dask import dataframe as dd from dask.distributed import Client from dask_cuda import LocalCUDACluster from xgboost import dask as dxgb from xgboost.dask import DaskDMatrix def using_dask_matrix(client: Client, X: da.Array, y: da.Array) -> da.Array: # DaskDMatrix acts like normal DMatrix, works as a proxy for local DMatrix scatter # around workers. dtrain = DaskDMatrix(client, X, y) # Use train method from xgboost.dask instead of xgboost. This distributed version # of train returns a dictionary containing the resulting booster and evaluation # history obtained from evaluation metrics. output = dxgb.train( client, # Make sure the device is set to CUDA. {\"tree_method\": \"hist\", \"device\": \"cuda\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], ) bst = output[\"booster\"] history = output[\"history\"] # you can pass output directly into `predict` too. prediction = dxgb.predict(client, bst, dtrain) print(\"Evaluation history:\", history) return prediction def using_quantile_device_dmatrix(client: Client, X: da.Array, y: da.Array) -> da.Array: \"\"\"`DaskQuantileDMatrix` is a data type specialized for `hist` tree methods for reducing memory usage. .. versionadded:: 1.2.0 \"\"\" # `DaskQuantileDMatrix` is used instead of `DaskDMatrix`, be careful that it can not # be used for anything else other than training unless a reference is specified. See # the `ref` argument of `DaskQuantileDMatrix`. dtrain = dxgb.DaskQuantileDMatrix(client, X, y) output = dxgb.train( client, # Make sure the device is set to CUDA. {\"tree_method\": \"hist\", \"device\": \"cuda\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], ) prediction = dxgb.predict(client, output, X) return prediction if __name__ == \"__main__\": # `LocalCUDACluster` is used for assigning GPU to XGBoost processes. Here # `n_workers` represents the number of GPUs since we use one GPU per worker process. with LocalCUDACluster(n_workers=2, threads_per_worker=4) as cluster: # Create client from cluster, set the backend to GPU array (cupy). with Client(cluster) as client, dask.config.set({\"array.backend\": \"cupy\"}): # Generate some", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_422", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/gpu_training.html", "title": "Example of training with Dask on GPU", "page_title": "Example of training with Dask on GPU — xgboost 3.0.4 documentation", "breadcrumbs": "Example of training with Dask on GPU", "content": "random data for demonstration rng = da.random.default_rng(1) m = 2**18 n = 100 X = rng.uniform(size=(m, n), chunks=(128**2, -1)) y = X.sum(axis=1) X = dd.from_dask_array(X) y = dd.from_dask_array(y) # XGBoost can take arrays. This is to show that DataFrame uses the GPU # backend as well. assert isinstance(X, dask_cudf.DataFrame) assert isinstance(y, dask_cudf.Series) print(\"Using DaskQuantileDMatrix\") from_ddqdm = using_quantile_device_dmatrix(client, X, y).compute() print(\"Using DMatrix\") from_dmatrix = using_dask_matrix(client, X, y).compute() Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_421", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_423", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/dask_callbacks.html", "title": "Example of using callbacks with Dask", "page_title": "Example of using callbacks with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Example of using callbacks with Dask", "content": "Example of using callbacks with Dask from typing import Any import numpy as np from dask.distributed import Client, LocalCluster from dask_ml.datasets import make_regression from dask_ml.model_selection import train_test_split import xgboost as xgb import xgboost.dask as dxgb from xgboost.dask import DaskDMatrix def probability_for_going_backward(epoch: int) -> float: return 0.999 / (1.0 + 0.05 * np.log(1.0 + epoch)) # All callback functions must inherit from TrainingCallback class CustomEarlyStopping(xgb.callback.TrainingCallback): \"\"\"A custom early stopping class where early stopping is determined stochastically. In the beginning, allow the metric to become worse with a probability of 0.999. As boosting progresses, the probability should be adjusted downward\"\"\" def __init__( self, *, validation_set: str, target_metric: str, maximize: bool, seed: int ) -> None: self.validation_set = validation_set self.target_metric = target_metric self.maximize = maximize self.seed = seed self.rng = np.random.default_rng(seed=seed) if maximize: self.better = lambda x, y: x > y else: self.better = lambda x, y: x < y def after_iteration( self, model: Any, epoch: int, evals_log: xgb.callback.TrainingCallback.EvalsLog ) -> bool: metric_history = evals_log[self.validation_set][self.target_metric] if len(metric_history) < 2 or self.better( metric_history[-1], metric_history[-2] ): return False # continue training p = probability_for_going_backward(epoch) go_backward = self.rng.choice(2, size=(1,), replace=True, p=[1 - p, p]).astype( np.bool_ )[0] print( \"The validation metric went into the wrong direction. \" + f\"Stopping training with probability {1 - p}...\" ) if go_backward: return False # continue training else: return True # stop training def main(client: Client) -> None: m = 100000 n = 100 X, y = make_regression(n_samples=m, n_features=n, chunks=200, random_state=0) X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0) dtrain = DaskDMatrix(client, X_train, y_train) dtest = DaskDMatrix(client, X_test, y_test) output = dxgb.train( client, { \"verbosity\": 1, \"tree_method\": \"hist\", \"objective\": \"reg:squarederror\", \"eval_metric\": \"rmse\", \"max_depth\": 6, \"learning_rate\": 1.0, }, dtrain, num_boost_round=1000, evals=[(dtrain, \"train\"), (dtest, \"test\")], callbacks=[ CustomEarlyStopping( validation_set=\"test\", target_metric=\"rmse\", maximize=False, seed=0 ) ], ) if __name__ == \"__main__\": # or use other clusters", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_424", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/dask_callbacks.html", "title": "Example of using callbacks with Dask", "page_title": "Example of using callbacks with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Example of using callbacks with Dask", "content": "for scaling with LocalCluster(n_workers=4, threads_per_worker=1) as cluster: with Client(cluster) as client: main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": "chunk_423", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_425", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/cpu_survival.html", "title": "Example of training survival model with Dask on CPU", "page_title": "Example of training survival model with Dask on CPU — xgboost 3.0.4 documentation", "breadcrumbs": "Example of training survival model with Dask on CPU", "content": "Example of training survival model with Dask on CPU import os import dask.array as da import dask.dataframe as dd from dask.distributed import Client, LocalCluster from xgboost import dask as dxgb from xgboost.dask import DaskDMatrix def main(client: Client) -> da.Array: # Load an example survival data from CSV into a Dask data frame. # The Veterans' Administration Lung Cancer Trial # The Statistical Analysis of Failure Time Data by Kalbfleisch J. and Prentice R (1980) CURRENT_DIR = os.path.dirname(__file__) df = dd.read_csv( os.path.join(CURRENT_DIR, os.pardir, \"data\", \"veterans_lung_cancer.csv\") ) # DaskDMatrix acts like normal DMatrix, works as a proxy for local # DMatrix scatter around workers. # For AFT survival, you'd need to extract the lower and upper bounds for the label # and pass them as arguments to DaskDMatrix. y_lower_bound = df[\"Survival_label_lower_bound\"] y_upper_bound = df[\"Survival_label_upper_bound\"] X = df.drop([\"Survival_label_lower_bound\", \"Survival_label_upper_bound\"], axis=1) dtrain = DaskDMatrix( client, X, label_lower_bound=y_lower_bound, label_upper_bound=y_upper_bound ) # Use train method from xgboost.dask instead of xgboost. This # distributed version of train returns a dictionary containing the # resulting booster and evaluation history obtained from # evaluation metrics. params = { \"verbosity\": 1, \"objective\": \"survival:aft\", \"eval_metric\": \"aft-nloglik\", \"learning_rate\": 0.05, \"aft_loss_distribution_scale\": 1.20, \"aft_loss_distribution\": \"normal\", \"max_depth\": 6, \"lambda\": 0.01, \"alpha\": 0.02, } output = dxgb.train( client, params, dtrain, num_boost_round=100, evals=[(dtrain, \"train\")] ) bst = output[\"booster\"] history = output[\"history\"] # you can pass output directly into `predict` too. prediction = dxgb.predict(client, bst, dtrain) print(\"Evaluation history: \", history) # Uncomment the following line to save the model to the disk # bst.save_model('survival_model.json') return prediction if __name__ == \"__main__\": # or use other clusters for scaling with LocalCluster(n_workers=7, threads_per_worker=4) as cluster: with Client(cluster) as client: main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_426", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/cpu_training.html", "title": "Example of training with Dask on CPU", "page_title": "Example of training with Dask on CPU — xgboost 3.0.4 documentation", "breadcrumbs": "Example of training with Dask on CPU", "content": "Example of training with Dask on CPU from dask import array as da from dask.distributed import Client, LocalCluster from xgboost import dask as dxgb from xgboost.dask import DaskDMatrix def main(client: Client) -> None: # generate some random data for demonstration m = 100000 n = 100 rng = da.random.default_rng(1) X = rng.normal(size=(m, n), chunks=(10000, -1)) y = X.sum(axis=1) # DaskDMatrix acts like normal DMatrix, works as a proxy for local # DMatrix scatter around workers. dtrain = DaskDMatrix(client, X, y) # Use train method from xgboost.dask instead of xgboost. This # distributed version of train returns a dictionary containing the # resulting booster and evaluation history obtained from # evaluation metrics. output = dxgb.train( client, {\"verbosity\": 1, \"tree_method\": \"hist\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], ) bst = output[\"booster\"] history = output[\"history\"] # you can pass output directly into `predict` too. prediction = dxgb.predict(client, bst, dtrain) print(\"Evaluation history:\", history) print(\"Error:\", da.sqrt((prediction - y) ** 2).mean().compute()) if __name__ == \"__main__\": # or use other clusters for scaling with LocalCluster(n_workers=7, threads_per_worker=4) as cluster: with Client(cluster) as client: main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_427", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/sklearn_gpu_training.html", "title": "Use scikit-learn regressor interface with GPU histogram tree method", "page_title": "Use scikit-learn regressor interface with GPU histogram tree method — xgboost 3.0.4 documentation", "breadcrumbs": "Use scikit-learn regressor interface with GPU histogram tree method", "content": "Use scikit-learn regressor interface with GPU histogram tree method import dask from dask import array as da from dask.distributed import Client # It's recommended to use dask_cuda for GPU assignment from dask_cuda import LocalCUDACluster from xgboost import dask as dxgb def main(client: Client) -> dxgb.Booster: # Generate some random data for demonstration rng = da.random.default_rng(1) m = 2**18 n = 100 X = rng.uniform(size=(m, n), chunks=(128**2, -1)) y = X.sum(axis=1) regressor = dxgb.DaskXGBRegressor(verbosity=1) # Set the device to CUDA regressor.set_params(tree_method=\"hist\", device=\"cuda\") # Assigning client here is optional regressor.client = client regressor.fit(X, y, eval_set=[(X, y)]) prediction = regressor.predict(X) bst = regressor.get_booster() history = regressor.evals_result() print(\"Evaluation history:\", history) # returned prediction is always a dask array. assert isinstance(prediction, da.Array) return bst # returning the trained model if __name__ == \"__main__\": # With dask cuda, one can scale up XGBoost to arbitrary GPU clusters. # `LocalCUDACluster` used here is only for demonstration purpose. with LocalCUDACluster() as cluster: # Create client from cluster, set the backend to GPU array (cupy). with Client(cluster) as client, dask.config.set({\"array.backend\": \"cupy\"}): main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_428", "url": "https://xgboost.readthedocs.io/en/stable/python/dask-examples/sklearn_cpu_training.html", "title": "Use scikit-learn regressor interface with CPU histogram tree method", "page_title": "Use scikit-learn regressor interface with CPU histogram tree method — xgboost 3.0.4 documentation", "breadcrumbs": "Use scikit-learn regressor interface with CPU histogram tree method", "content": "Use scikit-learn regressor interface with CPU histogram tree method from dask import array as da from dask.distributed import Client, LocalCluster from xgboost import dask as dxgb def main(client: Client) -> dxgb.Booster: # generate some random data for demonstration n = 100 m = 10000 partition_size = 100 X = da.random.random((m, n), partition_size) y = da.random.random(m, partition_size) regressor = dxgb.DaskXGBRegressor(verbosity=1, n_estimators=2) regressor.set_params(tree_method=\"hist\") # assigning client here is optional regressor.client = client regressor.fit(X, y, eval_set=[(X, y)]) prediction = regressor.predict(X) bst = regressor.get_booster() history = regressor.evals_result() print(\"Evaluation history:\", history) # returned prediction is always a dask array. assert isinstance(prediction, da.Array) return bst # returning the trained model if __name__ == \"__main__\": # or use other clusters for scaling with LocalCluster(n_workers=4, threads_per_worker=1) as cluster: with Client(cluster) as client: main(client) Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_429", "url": "https://xgboost.readthedocs.io/en/stable/python/survival-examples/aft_survival_demo_with_optuna.html", "title": "Demo for survival analysis (regression) with Optuna.", "page_title": "Demo for survival analysis (regression) with Optuna. — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for survival analysis (regression) with Optuna.", "content": "Demo for survival analysis (regression) with Optuna. Demo for survival analysis (regression) using Accelerated Failure Time (AFT) model, using Optuna to tune hyperparameters import numpy as np import optuna import pandas as pd from sklearn.model_selection import ShuffleSplit import xgboost as xgb # The Veterans' Administration Lung Cancer Trial # The Statistical Analysis of Failure Time Data by Kalbfleisch J. and Prentice R (1980) df = pd.read_csv('../data/veterans_lung_cancer.csv') print('Training data:') print(df) # Split features and labels y_lower_bound = df['Survival_label_lower_bound'] y_upper_bound = df['Survival_label_upper_bound'] X = df.drop(['Survival_label_lower_bound', 'Survival_label_upper_bound'], axis=1) # Split data into training and validation sets rs = ShuffleSplit(n_splits=2, test_size=.7, random_state=0) train_index, valid_index = next(rs.split(X)) dtrain = xgb.DMatrix(X.values[train_index, :]) dtrain.set_float_info('label_lower_bound', y_lower_bound[train_index]) dtrain.set_float_info('label_upper_bound', y_upper_bound[train_index]) dvalid = xgb.DMatrix(X.values[valid_index, :]) dvalid.set_float_info('label_lower_bound', y_lower_bound[valid_index]) dvalid.set_float_info('label_upper_bound', y_upper_bound[valid_index]) # Define hyperparameter search space base_params = {'verbosity': 0, 'objective': 'survival:aft', 'eval_metric': 'aft-nloglik', 'tree_method': 'hist'} # Hyperparameters common to all trials def objective(trial): params = {'learning_rate': trial.suggest_loguniform('learning_rate', 0.01, 1.0), 'aft_loss_distribution': trial.suggest_categorical('aft_loss_distribution', ['normal', 'logistic', 'extreme']), 'aft_loss_distribution_scale': trial.suggest_loguniform('aft_loss_distribution_scale', 0.1, 10.0), 'max_depth': trial.suggest_int('max_depth', 3, 8), 'lambda': trial.suggest_loguniform('lambda', 1e-8, 1.0), 'alpha': trial.suggest_loguniform('alpha', 1e-8, 1.0)} # Search space params.update(base_params) pruning_callback = optuna.integration.XGBoostPruningCallback(trial, 'valid-aft-nloglik') bst = xgb.train(params, dtrain, num_boost_round=10000, evals=[(dtrain, 'train'), (dvalid, 'valid')], early_stopping_rounds=50, verbose_eval=False, callbacks=[pruning_callback]) if bst.best_iteration >= 25: return bst.best_score else: return np.inf # Reject models with < 25 trees # Run hyperparameter search study = optuna.create_study(direction='minimize') study.optimize(objective, n_trials=200) print('Completed hyperparameter tuning with best aft-nloglik = {}.'.format(study.best_trial.value)) params = {} params.update(base_params) params.update(study.best_trial.params) # Re-run training with the best hyperparameter combination print('Re-running the best trial... params = {}'.format(params)) bst = xgb.train(params, dtrain, num_boost_round=10000, evals=[(dtrain, 'train'), (dvalid, 'valid')], early_stopping_rounds=50) # Run prediction on the validation set df = pd.DataFrame({'Label (lower bound)': y_lower_bound[valid_index], 'Label (upper bound)': y_upper_bound[valid_index], 'Predicted label': bst.predict(dvalid)}) print(df) # Show only data points with right-censored labels print(df[np.isinf(df['Label (upper bound)'])]) # Save trained model bst.save_model('aft_best_model.json') Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_430", "url": "https://xgboost.readthedocs.io/en/stable/python/survival-examples/aft_survival_demo.html", "title": "Demo for survival analysis (regression).", "page_title": "Demo for survival analysis (regression). — xgboost 3.0.4 documentation", "breadcrumbs": "Demo for survival analysis (regression).", "content": "Demo for survival analysis (regression). Demo for survival analysis (regression). using Accelerated Failure Time (AFT) model. import os import numpy as np import pandas as pd from sklearn.model_selection import ShuffleSplit import xgboost as xgb # The Veterans' Administration Lung Cancer Trial # The Statistical Analysis of Failure Time Data by Kalbfleisch J. and Prentice R (1980) CURRENT_DIR = os.path.dirname(__file__) df = pd.read_csv(os.path.join(CURRENT_DIR, '../data/veterans_lung_cancer.csv')) print('Training data:') print(df) # Split features and labels y_lower_bound = df['Survival_label_lower_bound'] y_upper_bound = df['Survival_label_upper_bound'] X = df.drop(['Survival_label_lower_bound', 'Survival_label_upper_bound'], axis=1) # Split data into training and validation sets rs = ShuffleSplit(n_splits=2, test_size=.7, random_state=0) train_index, valid_index = next(rs.split(X)) dtrain = xgb.DMatrix(X.values[train_index, :]) dtrain.set_float_info('label_lower_bound', y_lower_bound[train_index]) dtrain.set_float_info('label_upper_bound', y_upper_bound[train_index]) dvalid = xgb.DMatrix(X.values[valid_index, :]) dvalid.set_float_info('label_lower_bound', y_lower_bound[valid_index]) dvalid.set_float_info('label_upper_bound', y_upper_bound[valid_index]) # Train gradient boosted trees using AFT loss and metric params = {'verbosity': 0, 'objective': 'survival:aft', 'eval_metric': 'aft-nloglik', 'tree_method': 'hist', 'learning_rate': 0.05, 'aft_loss_distribution': 'normal', 'aft_loss_distribution_scale': 1.20, 'max_depth': 6, 'lambda': 0.01, 'alpha': 0.02} bst = xgb.train(params, dtrain, num_boost_round=10000, evals=[(dtrain, 'train'), (dvalid, 'valid')], early_stopping_rounds=50) # Run prediction on the validation set df = pd.DataFrame({'Label (lower bound)': y_lower_bound[valid_index], 'Label (upper bound)': y_upper_bound[valid_index], 'Predicted label': bst.predict(dvalid)}) print(df) # Show only data points with right-censored labels print(df[np.isinf(df['Label (upper bound)'])]) # Save trained model bst.save_model('aft_model.json') Gallery generated by Sphinx-Gallery", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_431", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Using XGBoost External Memory Version", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Using XGBoost External Memory Version", "content": "Using XGBoost External Memory Version When working with large datasets, training XGBoost models can be challenging as the entire dataset needs to be loaded into memory. This can be costly and sometimes infeasible. Starting from 1.5, users can define a custom iterator to load data in chunks for running XGBoost algorithms. External memory can be used for training and prediction, but training is the primary use case and it will be our focus in this tutorial. For prediction and evaluation, users can iterate through the data themselves, whereas training requires the entire dataset to be loaded into the memory. Significant progress was made in the 3.0 release for the GPU implementation. We will introduce the difference between CPU and GPU in the following sections. The external memory support has undergone multiple development iterations. Like the QuantileDMatrix with DataIter, XGBoost loads data batch-by-batch using a custom iterator supplied by the user. However, unlike the QuantileDMatrix, external memory does not concatenate the batches (unless specified by the extmem_single_page) . Instead, it caches all batches in the external memory and fetch them on-demand. Go to the end of the document to see a comparison between QuantileDMatrix and the external memory version of ExtMemQuantileDMatrix. Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_432", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Data Iterator", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Data Iterator", "content": "Data Iterator Starting with XGBoost 1.5, users can define their own data loader using Python or C interface. Some examples are in the demo directory for a quick start. To enable external memory training, users need to define a data iterator with 2 class methods: next and reset, then pass it into the DMatrix or the ExtMemQuantileDMatrix constructor. import os from typing import List, Callable import xgboost from sklearn.datasets import load_svmlight_file class Iterator(xgboost.DataIter): def __init__(self, svm_file_paths: List[str]) -> None: self._file_paths = svm_file_paths self._it = 0 # XGBoost will generate some cache files under the current directory with the prefix # \"cache\" super().__init__(cache_prefix=os.path.join(\".\", \"cache\")) def next(self, input_data: Callable) -> bool: \"\"\"Advance the iterator by 1 step and pass the data to XGBoost. This function is called by XGBoost during the construction of ``DMatrix`` \"\"\" if self._it == len(self._file_paths): # return False to let XGBoost know this is the end of the iteration return False # input_data is a function passed in by XGBoost and has the exact same signature of # ``DMatrix`` X, y = load_svmlight_file(self._file_paths[self._it]) # Keyword-only arguments, see the ``DMatrix`` class for accepted arguments. input_data(data=X, label=y) self._it += 1 # Return True to let XGBoost know we haven't seen all the files yet. return True def reset(self) -> None: \"\"\"Reset the iterator to its beginning\"\"\" self._it = 0 it = Iterator([\"file_0.svm\", \"file_1.svm\", \"file_2.svm\"]) # Use the ``ExtMemQuantileDMatrix`` for the hist tree method. Xy = xgboost.ExtMemQuantileDMatrix(it) booster = xgboost.train({\"tree_method\": \"hist\"}, Xy) # The ``approx`` tree method also works, but with lower performance and cannot be used # with the quantile DMatrix. Xy = xgboost.DMatrix(it) booster = xgboost.train({\"tree_method\": \"approx\"}, Xy) The above snippet is a simplified version of Experimental support for external memory. For an example in C, please see demo/c-api/external-memory/. The iterator is the common interface for using external memory", "prev_chunk_id": "chunk_431", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_433", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Data Iterator", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Data Iterator", "content": "with XGBoost, you can pass the resulting DMatrix object for training, prediction, and evaluation. The ExtMemQuantileDMatrix is an external memory version of the QuantileDMatrix. These two classes are specifically designed for the hist tree method for reduced memory usage and data loading overhead. See respective references for more info. It is important to set the batch size based on the memory available. A good starting point for CPU is to set the batch size to 10GB per batch if you have 64GB of memory. It is not recommended to set small batch sizes like 32 samples per batch, as this can severely hurt performance in gradient boosting. See below sections for information about the GPU version and other best practices.", "prev_chunk_id": "chunk_432", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_434", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "GPU Version (GPU Hist tree method)", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "GPU Version (GPU Hist tree method)", "content": "GPU Version (GPU Hist tree method) External memory is supported by GPU algorithms (i.e., when device is set to cuda). Starting with 3.0, the default GPU implementation is similar to what the CPU version does. It also supports the use of ExtMemQuantileDMatrix when the hist tree method is employed. For a GPU device, the main memory is the device memory, whereas the external memory can be either a disk or the CPU memory. XGBoost stages the cache on CPU memory by default. Users can change the backing storage to disk by specifying the on_host parameter in the DataIter. However, using the disk is not recommended as it’s likely to make the GPU slower than the CPU. The option is here for experimental purposes only. In addition, ExtMemQuantileDMatrix parameters max_num_device_pages, min_cache_page_bytes, and max_quantile_batches can help control the data placement and memory usage. Inputs to the ExtMemQuantileDMatrix (through the iterator) must be on the GPU. Following is a snippet from Experimental support for external memory: import cupy as cp import rmm from rmm.allocators.cupy import rmm_cupy_allocator # It's important to use RMM for GPU-based external memory to improve performance. # If XGBoost is not built with RMM support, a warning will be raised. # We use the pool memory resource here, you can also try the `ArenaMemoryResource` for # improved memory fragmentation handling. mr = rmm.mr.PoolMemoryResource(rmm.mr.CudaAsyncMemoryResource()) rmm.mr.set_current_device_resource(mr) # Set the allocator for cupy as well. cp.cuda.set_allocator(rmm_cupy_allocator) # Make sure XGBoost is using RMM for all allocations. with xgboost.config_context(use_rmm=True): # Construct the iterators for ExtMemQuantileDMatrix # ... # Build the ExtMemQuantileDMatrix and start training Xy_train = xgboost.ExtMemQuantileDMatrix(it_train, max_bin=n_bins) # Use the training DMatrix as a reference Xy_valid = xgboost.ExtMemQuantileDMatrix(it_valid, max_bin=n_bins, ref=Xy_train) booster = xgboost.train( { \"tree_method\": \"hist\", \"max_depth\": 6, \"max_bin\": n_bins, \"device\": device, }, Xy_train, num_boost_round=n_rounds, evals=[(Xy_train, \"Train\"), (Xy_valid, \"Valid\")] ) It’s crucial to", "prev_chunk_id": "chunk_433", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_435", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "GPU Version (GPU Hist tree method)", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "GPU Version (GPU Hist tree method)", "content": "use RAPIDS Memory Manager (RMM) with an asynchronous memory resource for all memory allocation when training with external memory. XGBoost relies on the asynchronous memory pool to reduce the overhead of data fetching. In addition, the open source NVIDIA Linux driver is required for Heterogeneous memory management (HMM) support. Usually, users need not to change ExtMemQuantileDMatrix parameters max_num_device_pages and min_cache_page_bytes, they are automatically configured based on the device and don’t change model accuracy. However, the max_quantile_batches can be useful if ExtMemQuantileDMatrix is running out of device memory during construction, see QuantileDMatrix and the following sections for more info. In addition to the batch-based data fetching, the GPU version supports concatenating batches into a single blob for the training data to improve performance. For GPUs connected via PCIe instead of nvlink, the performance overhead with batch-based training is significant, particularly for non-dense data. Overall, it can be at least five times slower than in-core training. Concatenating pages can be used to get the performance closer to in-core training. This option should be used in combination with subsampling to reduce the memory usage. During concatenation, subsampling removes a portion of samples, reducing the training dataset size. The GPU hist tree method supports gradient-based sampling, enabling users to set a low sampling rate without compromising accuracy. Before 3.0, concatenation with subsampling was the only option for GPU-based external memory. After 3.0, XGBoost uses the regular batch fetching as the default while the page concatenation can be enabled by: param = { \"device\": \"cuda\", \"extmem_single_page\": true, 'subsample': 0.2, 'sampling_method': 'gradient_based', } For more information about the sampling algorithm and its use in external memory training, see this paper. Lastly, see following sections for best practices.", "prev_chunk_id": "chunk_434", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_436", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "NVLink-C2C", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "NVLink-C2C", "content": "NVLink-C2C The newer NVIDIA platforms like Grace-Hopper use NVLink-C2C, which facilitates a fast interconnect between the CPU and the GPU. With the host memory serving as the data cache, XGBoost can retrieve data with significantly lower overhead. When the input data is dense, there’s minimal to no performance loss for training, except for the initial construction of the ExtMemQuantileDMatrix. The initial construction iterates through the input data twice, as a result, the most significant overhead compared to in-core training is one additional data read when the data is dense. Please note that there are multiple variants of the platform and they come with different C2C bandwidths. During initial development of the feature, we used the LPDDR5 480G version, which has about 350GB/s bandwidth for host to device transfer. To run experiments on these platforms, the open source NVIDIA Linux driver with version >=565.47 is required, it should come with CTK 12.7 and later versions.", "prev_chunk_id": "chunk_435", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_437", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Distributed Training", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed Training", "content": "Distributed Training Distributed training is similar to in-core learning, but the work for framework integration is still on-going. See Experimental support for distributed training with external memory for an example for using the communicator to build a simple pipeline. Since users can define their custom data loader, it’s unlikely that existing distributed frameworks interface in XGBoost can meet all the use cases, the example can be a starting point for users who have custom infrastructure.", "prev_chunk_id": "chunk_436", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_438", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Best Practices", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Best Practices", "content": "Best Practices In previous sections, we demonstrated how to train a tree-based model with data residing on an external memory and made some recommendations for batch size. Here are some other configurations we find useful. The external memory feature involves iterating through data batches stored in a cache during tree construction. For optimal performance, we recommend using the grow_policy=depthwise setting, which allows XGBoost to build an entire layer of tree nodes with only a few batch iterations. Conversely, using the lossguide policy requires XGBoost to iterate over the data set for each tree node, resulting in significantly slower performance. In addition, this hist tree method should be preferred over the approx tree method as the former doesn’t recreate the histogram bins for every iteration. Creating the histogram bins requires loading the raw input data, which is prohibitively expensive. The ExtMemQuantileDMatrix designed for the hist tree method can speed up the initial data construction and the evaluation significantly for external memory. Since the external memory implementation focuses on training where XGBoost needs to access the entire dataset, only the X is divided into batches while everything else is concatenated. As a result, it’s recommended for users to define their own management code to iterate through the data for inference, especially for SHAP value computation. The size of SHAP results can be larger than X, making external memory in XGBoost less effective. Some frameworks like dask can help with the data chunking and iterate through the data for inference with memory spilling. When external memory is used, the performance of CPU training is limited by disk IO (input/output) speed. This means that the disk IO speed primarily determines the training speed. Similarly, PCIe bandwidth limits the GPU performance, assuming the CPU memory is used as a cache and address translation services (ATS)", "prev_chunk_id": "chunk_437", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_439", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Best Practices", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Best Practices", "content": "is unavailable. During development, we observed that typical data transfer in XGBoost with PCIe4x16 has about 24GB/s bandwidth, which is significantly lower than the GPU processing performance. Whereas with a C2C-enabled machine, the performance of data transfer and processing in training are similar. Running inference is much less computation-intensive than training and, hence, much faster. As a result, the performance bottleneck of inference is back to data transfer. For GPU, the time it takes to read the data from host to device completely determines the time it takes to run inference, even if a C2C link is available. Xy_train = xgboost.ExtMemQuantileDMatrix(it_train, max_bin=n_bins) Xy_valid = xgboost.ExtMemQuantileDMatrix(it_valid, max_bin=n_bins, ref=Xy_train) In addition, since the GPU implementation relies on asynchronous memory pool, which is subject to memory fragmentation even if the CudaAsyncMemoryResource is used. You might want to start the training with a fresh pool instead of starting training right after the ETL process. If you run into out-of-memory errors and you are convinced that the pool is not full yet (pool memory usage can be profiled with nsight-system), consider tuning the RMM memory resource like using CudaAsyncMemoryResource in conjunction with BinningMemoryResource(mr, 21, 25) instead of the PoolMemoryResource. Alternately, the ArenaMemoryResource is also an excellent option. During CPU benchmarking, we used an NVMe connected to a PCIe-4 slot. Other types of storage can be too slow for practical usage. However, your system will likely perform some caching to reduce the overhead of the file read. See the following sections for remarks.", "prev_chunk_id": "chunk_438", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_440", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Remarks", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Remarks", "content": "Remarks When using external memory with XGBoost, data is divided into smaller chunks so that only a fraction of it needs to be stored in memory at any given time. It’s important to note that this method only applies to the predictor data (X), while other data, like labels and internal runtime structures are concatenated. This means that memory reduction is most effective when dealing with wide datasets where X is significantly larger in size compared to other data like y, while it has little impact on slim datasets. As one might expect, fetching data on demand puts significant pressure on the storage device. Today’s computing devices can process way more data than storage devices can read in a single unit of time. The ratio is in the order of magnitudes. A GPU is capable of processing hundreds of Gigabytes of floating-point data in a split second. On the other hand, a four-lane NVMe storage connected to a PCIe-4 slot usually has about 6GB/s of data transfer rate. As a result, the training is likely to be severely bounded by your storage device. Before adopting the external memory solution, some back-of-envelop calculations might help you determine its viability. For instance, if your NVMe drive can transfer 4GB (a reasonably practical number) of data per second, and you have a 100GB of data in a compressed XGBoost cache (corresponding to a dense float32 numpy array with 200GB, give or take). A tree with depth 8 needs at least 16 iterations through the data when the parameter is optimal. You need about 14 minutes to train a single tree without accounting for some other overheads and assume the computation overlaps with the IO. If your dataset happens to have a TB-level size, you might need thousands of trees to get a generalized", "prev_chunk_id": "chunk_439", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_441", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Remarks", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Remarks", "content": "model. These calculations can help you get an estimate of the expected training time. However, sometimes, we can ameliorate this limitation. One should also consider that the OS (mainly talking about the Linux kernel) can usually cache the data on host memory. It only evicts pages when new data comes in and there’s no room left. In practice, at least some portion of the data can persist in the host memory throughout the entire training session. We are aware of this cache when optimizing the external memory fetcher. The compressed cache is usually smaller than the raw input data, especially when the input is dense without any missing value. If the host memory can fit a significant portion of this compressed cache, the performance should be decent after initialization. Our development so far focuses on following fronts of optimization for external memory: - Avoid iterating through the data whenever appropriate. - If the OS can cache the data, the performance should be close to in-core training. - For GPU, the actual computation should overlap with memory copy as much as possible. Starting with XGBoost 2.0, the implementation of external memory uses mmap. It has not been tested against system errors like disconnected network devices (SIGBUS). In the face of a bus error, you will see a hard crash and need to clean up the cache files. If the training session might take a long time and you use solutions like NVMe-oF, we recommend checkpointing your model periodically. Also, it’s worth noting that most tests have been conducted on Linux distributions. Another important point to keep in mind is that creating the initial cache for XGBoost may take some time. The interface to external memory is through custom iterators, which we can not assume to be thread-safe. Therefore, initialization is performed", "prev_chunk_id": "chunk_440", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_442", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Remarks", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Remarks", "content": "sequentially. Using the config_context() with verbosity=2 can give you some information on what XGBoost is doing during the wait if you don’t mind the extra output.", "prev_chunk_id": "chunk_441", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_443", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Compared to the QuantileDMatrix", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Compared to the QuantileDMatrix", "content": "Compared to the QuantileDMatrix Passing an iterator to the QuantileDMatrix enables direct construction of QuantileDMatrix with data chunks. On the other hand, if it’s passed to the DMatrix or the ExtMemQuantileDMatrix, it instead enables the external memory feature. The QuantileDMatrix concatenates the data in memory after compression and doesn’t fetch data during training. On the other hand, the external memory DMatrix (ExtMemQuantileDMatrix) fetches data batches from external memory on demand. Use the QuantileDMatrix (with iterator if necessary) when you can fit most of your data in memory. For many platforms, the training speed can be an order of magnitude faster than external memory.", "prev_chunk_id": "chunk_442", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_444", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Brief History", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Brief History", "content": "Brief History For a long time, external memory support has been an experimental feature and has undergone multiple development iterations. Here’s a brief summary of major changes: - Gradient-based sampling was introduced to the GPU hist in 1.1. - The iterator interface was introduced in 1.5, along with a major rewrite for the internal framework. - 2.0 introduced the use ofmmap, along with optimization in XBGoost to enable zero-copy data fetching. - 3.0 reworked the GPU implementation to support caching data on the host and disk, introduced theExtMemQuantileDMatrixclass, added quantile-based objectives support. - In addition, we begin support for distributed training in 3.0", "prev_chunk_id": "chunk_443", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_445", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/external_memory.html", "title": "Text File Inputs", "page_title": "Using XGBoost External Memory Version — xgboost 3.0.4 documentation", "breadcrumbs": "Text File Inputs", "content": "Text File Inputs There is no significant difference between using the external memory version of text input and the in-memory version of text input. The only difference is the filename format. The external memory version takes in the following URI format: filename?format=libsvm#cacheprefix The filename is the typical path to LIBSVM format file you want to load in, and cacheprefix is a path to a cache file that XGBoost will use for caching preprocessed data in binary form. To load from csv files, use the following syntax: filename.csv?format=csv&label_column=0#cacheprefix where label_column should point to the csv column acting as the label. If you have a dataset stored in a file similar to demo/data/agaricus.txt.train with LIBSVM format, the external memory support can be enabled by: dtrain = DMatrix('../data/agaricus.txt.train?format=libsvm#dtrain.cache') XGBoost will first load agaricus.txt.train in, preprocess it, then write to a new file named dtrain.cache as an on disk cache for storing preprocessed data in an internal binary format. For more notes about text input formats, see Text Input Format of DMatrix. For the CLI version, simply add the cache suffix, e.g. \"../data/agaricus.txt.train?format=libsvm#dtrain.cache\".", "prev_chunk_id": "chunk_444", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_446", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Distributed XGBoost with Ray", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed XGBoost with Ray", "content": "Distributed XGBoost with Ray Ray is a general purpose distributed execution framework. Ray can be used to scale computations from a single node to a cluster of hundreds of nodes without changing any code. The Python bindings of Ray come with a collection of well maintained machine learning libraries for hyperparameter optimization and model serving. The XGBoost-Ray project provides an interface to run XGBoost training and prediction jobs on a Ray cluster. It allows to utilize distributed data representations, such as Modin dataframes, as well as distributed loading from cloud storage (e.g. Parquet files). XGBoost-Ray integrates well with hyperparameter optimization library Ray Tune, and implements advanced fault tolerance handling mechanisms. With Ray you can scale your training jobs to hundreds of nodes just by adding new nodes to a cluster. You can also use Ray to leverage multi GPU XGBoost training.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_447", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Installing and starting Ray", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Installing and starting Ray", "content": "Installing and starting Ray Ray can be installed from PyPI like this: pip install ray If you’re using Ray on a single machine, you don’t need to do anything else - XGBoost-Ray will automatically start a local Ray cluster when used. If you want to use Ray on a cluster, you can use the Ray cluster launcher.", "prev_chunk_id": "chunk_446", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_448", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Installing XGBoost-Ray", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Installing XGBoost-Ray", "content": "Installing XGBoost-Ray XGBoost-Ray is also available via PyPI: pip install xgboost_ray This will install all dependencies needed to run XGBoost on Ray, including Ray itself if it hasn’t been installed before.", "prev_chunk_id": "chunk_447", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_449", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Using XGBoost-Ray for training and prediction", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Using XGBoost-Ray for training and prediction", "content": "Using XGBoost-Ray for training and prediction XGBoost-Ray uses the same API as core XGBoost. There are only two differences: - Instead of using axgboost.DMatrix, you’ll use axgboost_ray.RayDMatrixobject - There is an additionalxgboost_ray.RayParamsparameter that you can use to configure distributed training.", "prev_chunk_id": "chunk_448", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_450", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Simple training example", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Simple training example", "content": "Simple training example To run this simple example, you’ll need to install scikit-learn (with pip install sklearn). In this example, we will load the breast cancer dataset and train a binary classifier using two actors. from xgboost_ray import RayDMatrix, RayParams, train from sklearn.datasets import load_breast_cancer train_x, train_y = load_breast_cancer(return_X_y=True) train_set = RayDMatrix(train_x, train_y) evals_result = {} bst = train( { \"objective\": \"binary:logistic\", \"eval_metric\": [\"logloss\", \"error\"], }, train_set, evals_result=evals_result, evals=[(train_set, \"train\")], verbose_eval=False, ray_params=RayParams(num_actors=2, cpus_per_actor=1)) bst.save_model(\"model.xgb\") print(\"Final training error: {:.4f}\".format( evals_result[\"train\"][\"error\"][-1])) The only differences compared to the non-distributed API are the import statement (xgboost_ray instead of xgboost), using the RayDMatrix instead of the DMatrix, and passing a xgboost_ray.RayParams object. The return object is a regular xgboost.Booster instance.", "prev_chunk_id": "chunk_449", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_451", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Simple prediction example", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Simple prediction example", "content": "Simple prediction example from xgboost_ray import RayDMatrix, RayParams, predict from sklearn.datasets import load_breast_cancer import xgboost as xgb data, labels = load_breast_cancer(return_X_y=True) dpred = RayDMatrix(data, labels) bst = xgb.Booster(model_file=\"model.xgb\") pred_ray = predict(bst, dpred, ray_params=RayParams(num_actors=2)) print(pred_ray) In this example, the data will be split across two actors. The result array will integrate this data in the correct order.", "prev_chunk_id": "chunk_450", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_452", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "The RayParams object", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "The RayParams object", "content": "The RayParams object The RayParams object is used to configure various settings relating to the distributed training.", "prev_chunk_id": "chunk_451", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_453", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Multi GPU training", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Multi GPU training", "content": "Multi GPU training Ray automatically detects GPUs on cluster nodes. In order to start training on multiple GPUs, all you have to do is to set the gpus_per_actor parameter of the RayParams object, as well as the num_actors parameter for multiple GPUs: ray_params = RayParams( num_actors=4, gpus_per_actor=1, ) This will train on four GPUs in parallel. Note that it usually does not make sense to allocate more than one GPU per actor, as XGBoost relies on distributed libraries such as Dask or Ray to utilize multi GPU training.", "prev_chunk_id": "chunk_452", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_454", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Setting the number of CPUs per actor", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Setting the number of CPUs per actor", "content": "Setting the number of CPUs per actor XGBoost natively utilizes multi threading to speed up computations. Thus if your are training on CPUs only, there is likely no benefit in using more than one actor per node. In that case, assuming you have a cluster of homogeneous nodes, set the number of CPUs per actor to the number of CPUs available on each node, and the number of actors to the number of nodes. If you are using multi GPU training on a single node, divide the number of available CPUs evenly across all actors. For instance, if you have 16 CPUs and 4 GPUs available, each actor should access 1 GPU and 4 CPUs. If you are using a cluster of heterogeneous nodes (with different amounts of CPUs), you might just want to use the greatest common divisor for the number of CPUs per actor. E.g. if you have a cluster of three nodes with 4, 8, and 12 CPUs, respectively, you’d start 6 actors with 4 CPUs each for maximum CPU utilization.", "prev_chunk_id": "chunk_453", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_455", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Fault tolerance", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Fault tolerance", "content": "Fault tolerance XGBoost-Ray supports two fault tolerance modes. In non-elastic training, whenever a training actor dies (e.g. because the node goes down), the training job will stop, XGBoost-Ray will wait for the actor (or its resources) to become available again (this might be on a different node), and then continue training once all actors are back. In elastic-training, whenever a training actor dies, the rest of the actors continue training without the dead actor. If the actor comes back, it will be re-integrated into training again. Please note that in elastic-training this means that you will train on fewer data for some time. The benefit is that you can continue training even if a node goes away for the remainder of the training run, and don’t have to wait until it is back up again. In practice this usually leads to a very minor decrease in accuracy but a much shorter training time compared to non-elastic training. Both training modes can be configured using the respective xgboost_ray.RayParams parameters.", "prev_chunk_id": "chunk_454", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_456", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Hyperparameter optimization", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Hyperparameter optimization", "content": "Hyperparameter optimization XGBoost-Ray integrates well with hyperparameter optimization framework Ray Tune. Ray Tune uses Ray to start multiple distributed trials with different hyperparameter configurations. If used with XGBoost-Ray, these trials will then start their own distributed training jobs. XGBoost-Ray automatically reports evaluation results back to Ray Tune. There’s only a few things you need to do: - Put your XGBoost-Ray training call into a function accepting parameter configurations (train_modelin the example below). - Create axgboost_ray.RayParamsobject (ray_paramsin the example below). - Define the parameter search space (configdict in the example below). - Calltune.run():Themetricparameter should contain the metric you’d like to optimize. Usually this consists of the prefix passed to theevalsargument ofxgboost_ray.train(), and aneval_metricpassed in the XGBoost parameters (train-errorin the example below).Themodeshould either beminormax, depending on whether you’d like to minimize or maximize the metricTheresources_per_actorshould be set usingray_params.get_tune_resources(). This will make sure that each trial has the necessary resources available to start their distributed training jobs. from xgboost_ray import RayDMatrix, RayParams, train from sklearn.datasets import load_breast_cancer num_actors = 4 num_cpus_per_actor = 1 ray_params = RayParams( num_actors=num_actors, cpus_per_actor=num_cpus_per_actor) def train_model(config): train_x, train_y = load_breast_cancer(return_X_y=True) train_set = RayDMatrix(train_x, train_y) evals_result = {} bst = train( params=config, dtrain=train_set, evals_result=evals_result, evals=[(train_set, \"train\")], verbose_eval=False, ray_params=ray_params) bst.save_model(\"model.xgb\") from ray import tune # Specify the hyperparameter search space. config = { \"tree_method\": \"approx\", \"objective\": \"binary:logistic\", \"eval_metric\": [\"logloss\", \"error\"], \"eta\": tune.loguniform(1e-4, 1e-1), \"subsample\": tune.uniform(0.5, 1.0), \"max_depth\": tune.randint(1, 9) } # Make sure to use the `get_tune_resources` method to set the `resources_per_trial` analysis = tune.run( train_model, config=config, metric=\"train-error\", mode=\"min\", num_samples=4, resources_per_trial=ray_params.get_tune_resources()) print(\"Best hyperparameters\", analysis.best_config) Ray Tune supports various search algorithms and libraries (e.g. BayesOpt, Tree-Parzen estimators), smart schedulers like successive halving, and other features. Please refer to the Ray Tune documentation for more information.", "prev_chunk_id": "chunk_455", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_457", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/ray.html", "title": "Additional resources", "page_title": "Distributed XGBoost with Ray — xgboost 3.0.4 documentation", "breadcrumbs": "Additional resources", "content": "Additional resources - XGBoost-Ray repository - XGBoost-Ray documentation - Ray core documentation - Ray Tune documentation", "prev_chunk_id": "chunk_456", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_458", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Distributed XGBoost with PySpark", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed XGBoost with PySpark", "content": "Distributed XGBoost with PySpark Starting from version 1.7.0, xgboost supports pyspark estimator APIs.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_459", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "SparkXGBRegressor", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "SparkXGBRegressor", "content": "SparkXGBRegressor SparkXGBRegressor is a PySpark ML estimator. It implements the XGBoost classification algorithm based on XGBoost python library, and it can be used in PySpark Pipeline and PySpark ML meta algorithms like CrossValidator/TrainValidationSplit/OneVsRest. We can create a SparkXGBRegressor estimator like: from xgboost.spark import SparkXGBRegressor xgb_regressor = SparkXGBRegressor( features_col=\"features\", label_col=\"label\", num_workers=2, ) The above snippet creates a spark estimator which can fit on a spark dataset, and return a spark model that can transform a spark dataset and generate dataset with prediction column. We can set almost all of xgboost sklearn estimator parameters as SparkXGBRegressor parameters, but some parameter such as nthread is forbidden in spark estimator, and some parameters are replaced with pyspark specific parameters such as weight_col, validation_indicator_col, for details please see SparkXGBRegressor doc. The following code snippet shows how to train a spark xgboost regressor model, first we need to prepare a training dataset as a spark dataframe contains “label” column and “features” column(s), the “features” column(s) must be pyspark.ml.linalg.Vector type or spark array type or a list of feature column names. xgb_regressor_model = xgb_regressor.fit(train_spark_dataframe) The following code snippet shows how to predict test data using a spark xgboost regressor model, first we need to prepare a test dataset as a spark dataframe contains “features” and “label” column, the “features” column must be pyspark.ml.linalg.Vector type or spark array type. transformed_test_spark_dataframe = xgb_regressor_model.transform(test_spark_dataframe) The above snippet code returns a transformed_test_spark_dataframe that contains the input dataset columns and an appended column “prediction” representing the prediction results.", "prev_chunk_id": "chunk_458", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_460", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "SparkXGBClassifier", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "SparkXGBClassifier", "content": "SparkXGBClassifier SparkXGBClassifier estimator has similar API with SparkXGBRegressor, but it has some pyspark classifier specific params, e.g. raw_prediction_col and probability_col parameters. Correspondingly, by default, SparkXGBClassifierModel transforming test dataset will generate result dataset with 3 new columns: - “prediction”: represents the predicted label. - “raw_prediction”: represents the output margin values. - “probability”: represents the prediction probability on each label.", "prev_chunk_id": "chunk_459", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_461", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "XGBoost PySpark GPU support", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost PySpark GPU support", "content": "XGBoost PySpark GPU support XGBoost PySpark fully supports GPU acceleration. Users are not only able to enable efficient training but also utilize their GPUs for the whole PySpark pipeline including ETL and inference. In below sections, we will walk through an example of training on a Spark standalone cluster with GPU support. To get started, first we need to install some additional packages, then we can set the device parameter to cuda or gpu.", "prev_chunk_id": "chunk_460", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_462", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Prepare the necessary packages", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Prepare the necessary packages", "content": "Prepare the necessary packages Aside from the PySpark and XGBoost modules, we also need the cuDF package for handling Spark dataframe. We recommend using either Conda or Virtualenv to manage python dependencies for PySpark jobs. Please refer to How to Manage Python Dependencies in PySpark for more details on PySpark dependency management. In short, to create a Python environment that can be sent to a remote cluster using virtualenv and pip: python -m venv xgboost_env source xgboost_env/bin/activate pip install pyarrow pandas venv-pack xgboost # https://docs.rapids.ai/install#pip-install pip install cudf-cu11 --extra-index-url=https://pypi.nvidia.com venv-pack -o xgboost_env.tar.gz With Conda: conda create -y -n xgboost_env -c conda-forge conda-pack python=3.9 conda activate xgboost_env # use conda when the supported version of xgboost (1.7) is released on conda-forge pip install xgboost conda install cudf pyarrow pandas -c rapids -c nvidia -c conda-forge conda pack -f -o xgboost_env.tar.gz", "prev_chunk_id": "chunk_461", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_463", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Write your PySpark application", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Write your PySpark application", "content": "Write your PySpark application Below snippet is a small example for training xgboost model with PySpark. Notice that we are using a list of feature names instead of vector type as the input. The parameter \"device=cuda\" specifically indicates that the training will be performed on a GPU. from xgboost.spark import SparkXGBRegressor spark = SparkSession.builder.getOrCreate() # read data into spark dataframe train_data_path = \"xxxx/train\" train_df = spark.read.parquet(data_path) test_data_path = \"xxxx/test\" test_df = spark.read.parquet(test_data_path) # assume the label column is named \"class\" label_name = \"class\" # get a list with feature column names feature_names = [x.name for x in train_df.schema if x.name != label_name] # create a xgboost pyspark regressor estimator and set device=\"cuda\" regressor = SparkXGBRegressor( features_col=feature_names, label_col=label_name, num_workers=2, device=\"cuda\", ) # train and return the model model = regressor.fit(train_df) # predict on test data predict_df = model.transform(test_df) predict_df.show() Like other distributed interfaces, the device parameter doesn’t support specifying ordinal as GPUs are managed by Spark instead of XGBoost (good: device=cuda, bad: device=cuda:0).", "prev_chunk_id": "chunk_462", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_464", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Submit the PySpark application", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Submit the PySpark application", "content": "Submit the PySpark application Assuming you have configured the Spark standalone cluster with GPU support. Otherwise, please refer to spark standalone configuration with GPU support. Starting from XGBoost 2.0.1, stage-level scheduling is automatically enabled. Therefore, if you are using Spark standalone cluster version 3.4.0 or higher, we strongly recommend configuring the \"spark.task.resource.gpu.amount\" as a fractional value. This will enable running multiple tasks in parallel during the ETL phase. An example configuration would be \"spark.task.resource.gpu.amount=1/spark.executor.cores\". However, if you are using a XGBoost version earlier than 2.0.1 or a Spark standalone cluster version below 3.4.0, you still need to set \"spark.task.resource.gpu.amount\" equal to \"spark.executor.resource.gpu.amount\". export PYSPARK_DRIVER_PYTHON=python export PYSPARK_PYTHON=./environment/bin/python spark-submit \\ --master spark://<master-ip>:7077 \\ --conf spark.executor.cores=12 \\ --conf spark.task.cpus=1 \\ --conf spark.executor.resource.gpu.amount=1 \\ --conf spark.task.resource.gpu.amount=0.08 \\ --archives xgboost_env.tar.gz#environment \\ xgboost_app.py The above command submits the xgboost pyspark application with the python environment created by pip or conda, specifying a request for 1 GPU and 12 CPUs per executor. So you can see, a total of 12 tasks per executor will be executed concurrently during the ETL phase.", "prev_chunk_id": "chunk_463", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_465", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Model Persistence", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Model Persistence", "content": "Model Persistence Similar to standard PySpark ml estimators, one can persist and reuse the model with save and load methods: regressor = SparkXGBRegressor() model = regressor.fit(train_df) # save the model model.save(\"/tmp/xgboost-pyspark-model\") # load the model model2 = SparkXGBRankerModel.load(\"/tmp/xgboost-pyspark-model\") To export the underlying booster model used by XGBoost: regressor = SparkXGBRegressor() model = regressor.fit(train_df) # the same booster object returned by xgboost.train booster: xgb.Booster = model.get_booster() booster.predict(...) booster.save_model(\"model.json\") # or model.ubj, depending on your choice of format. This booster is not only shared by other Python interfaces but also used by all the XGBoost bindings including the C, Java, and the R package. Lastly, one can extract the booster file directly from a saved spark estimator without going through the getter: import xgboost as xgb bst = xgb.Booster() # Loading the model saved in previous snippet bst.load_model(\"/tmp/xgboost-pyspark-model/model/part-00000\")", "prev_chunk_id": "chunk_464", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_466", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Accelerate the whole pipeline for xgboost pyspark", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Accelerate the whole pipeline for xgboost pyspark", "content": "Accelerate the whole pipeline for xgboost pyspark With RAPIDS Accelerator for Apache Spark, you can leverage GPUs to accelerate the whole pipeline (ETL, Train, Transform) for xgboost pyspark without the need for any code modifications. Likewise, you have the option to configure the \"spark.task.resource.gpu.amount\" setting as a fractional value, enabling a higher number of tasks to be executed in parallel during the ETL phase. please refer to Submit the PySpark application for more details. An example submit command is shown below with additional spark configurations and dependencies: export PYSPARK_DRIVER_PYTHON=python export PYSPARK_PYTHON=./environment/bin/python spark-submit \\ --master spark://<master-ip>:7077 \\ --conf spark.executor.cores=12 \\ --conf spark.task.cpus=1 \\ --conf spark.executor.resource.gpu.amount=1 \\ --conf spark.task.resource.gpu.amount=0.08 \\ --packages com.nvidia:rapids-4-spark_2.12:24.04.1 \\ --conf spark.plugins=com.nvidia.spark.SQLPlugin \\ --conf spark.sql.execution.arrow.maxRecordsPerBatch=1000000 \\ --archives xgboost_env.tar.gz#environment \\ xgboost_app.py When rapids plugin is enabled, both of the JVM rapids plugin and the cuDF Python package are required. More configuration options can be found in the RAPIDS link above along with details on the plugin.", "prev_chunk_id": "chunk_465", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_467", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/spark_estimator.html", "title": "Advanced Usage", "page_title": "Distributed XGBoost with PySpark — xgboost 3.0.4 documentation", "breadcrumbs": "Advanced Usage", "content": "Advanced Usage XGBoost needs to repartition the input dataset to the num_workers to ensure there will be num_workers training tasks running at the same time. However, repartition is a costly operation. If there is a scenario where reading the data from source and directly fitting it to XGBoost without introducing the shuffle stage, users can avoid the need for repartitioning by setting the Spark configuration parameters spark.sql.files.maxPartitionNum and spark.sql.files.minPartitionNum to num_workers. This tells Spark to automatically partition the dataset into the desired number of partitions. However, if the input dataset is skewed (i.e. the data is not evenly distributed), setting the partition number to num_workers may not be efficient. In this case, users can set the force_repartition=true option to explicitly force XGBoost to repartition the dataset, even if the partition number is already equal to num_workers. This ensures the data is evenly distributed across the workers.", "prev_chunk_id": "chunk_466", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_468", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Distributed XGBoost with Dask", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed XGBoost with Dask", "content": "Distributed XGBoost with Dask Dask is a parallel computing library built on Python. Dask allows easy management of distributed workers and excels at handling large distributed data science workflows. The implementation in XGBoost originates from dask-xgboost with some extended functionalities and a different interface. The tutorial here focuses on basic usage of dask with CPU tree algorithms. For an overview of GPU based training and internal workings, see A New, Official Dask API for XGBoost. Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_469", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Requirements", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Requirements", "content": "Requirements Dask can be installed using either pip or conda (see the dask installation documentation for more information). For accelerating XGBoost with GPUs, dask-cuda is recommended for creating GPU clusters.", "prev_chunk_id": "chunk_468", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_470", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Overview", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "Overview A dask cluster consists of three different components: a centralized scheduler, one or more workers, and one or more clients which act as the user-facing entry point for submitting tasks to the cluster. When using XGBoost with dask, one needs to call the XGBoost dask interface from the client side. Below is a small example which illustrates basic usage of running XGBoost on a dask cluster: from xgboost import dask as dxgb import dask.array as da import dask.distributed if __name__ == \"__main__\": cluster = dask.distributed.LocalCluster() client = dask.distributed.Client(cluster) # X and y must be Dask dataframes or arrays num_obs = 1e5 num_features = 20 X = da.random.random(size=(num_obs, num_features), chunks=(1000, num_features)) y = da.random.random(size=(num_obs, 1), chunks=(1000, 1)) dtrain = dxgb.DaskDMatrix(client, X, y) # or # dtrain = dxgb.DaskQuantileDMatrix(client, X, y) output = dxgb.train( client, {\"verbosity\": 2, \"tree_method\": \"hist\", \"objective\": \"reg:squarederror\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], ) Here we first create a cluster in single-node mode with distributed.LocalCluster, then connect a distributed.Client to this cluster, setting up an environment for later computation. Notice that the cluster construction is guarded by __name__ == \"__main__\", which is necessary otherwise there might be obscure errors. We then create a xgboost.dask.DaskDMatrix object and pass it to xgboost.dask.train(), along with some other parameters, much like XGBoost’s normal, non-dask interface. Unlike that interface, data and label must be either Dask DataFrame or Dask Array instances. The primary difference with XGBoost’s dask interface is we pass our dask client as an additional argument for carrying out the computation. Note that if client is set to None, XGBoost will use the default client returned by dask. There are two sets of APIs implemented in XGBoost. The first set is functional API illustrated in above example. Given the data and a set of parameters, the train function returns a model and", "prev_chunk_id": "chunk_469", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_471", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Overview", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "the computation history as a Python dictionary: { \"booster\": Booster, \"history\": dict, } For prediction, pass the output returned by train into xgboost.dask.predict(): prediction = dxgb.predict(client, output, dtrain) # Or equivalently, pass ``output['booster']``: prediction = dxgb.predict(client, output['booster'], dtrain) Eliminating the construction of DaskDMatrix is also possible, this can make the computation a bit faster when meta information like base_margin is not needed: prediction = dxgb.predict(client, output, X) # Use inplace version. prediction = dxgb.inplace_predict(client, output, X) Here prediction is a dask Array object containing predictions from model if input is a DaskDMatrix or da.Array. When putting dask collection directly into the predict function or using xgboost.dask.inplace_predict(), the output type depends on input data. See next section for details. Alternatively, XGBoost also implements the Scikit-Learn interface with DaskXGBClassifier, DaskXGBRegressor, DaskXGBRanker and 2 random forest variances. This wrapper is similar to the single node Scikit-Learn interface in xgboost, with dask collection as inputs and has an additional client attribute. See following sections and XGBoost Dask Feature Walkthrough for more examples.", "prev_chunk_id": "chunk_470", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_472", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Running prediction", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Running prediction", "content": "Running prediction In previous example we used DaskDMatrix as input to predict function. In practice, it’s also possible to call predict function directly on dask collections like Array and DataFrame and might have better prediction performance. When DataFrame is used as prediction input, the result is a dask Series instead of array. Also, there’s in-place predict support on dask interface, which can help reducing both memory usage and prediction time. # dtrain is the DaskDMatrix defined above. prediction = dxgb.predict(client, booster, dtrain) or equivalently: # where X is a dask DataFrame or dask Array. prediction = dxgb.predict(client, booster, X) Also for inplace prediction: # where X is a dask DataFrame or dask Array backed by cupy or cuDF. booster.set_param({\"device\": \"cuda\"}) prediction = dxgb.inplace_predict(client, booster, X) When input is da.Array object, output is always da.Array. However, if the input type is dd.DataFrame, output can be dd.Series, dd.DataFrame or da.Array, depending on output shape. For example, when SHAP-based prediction is used, the return value can have 3 or 4 dimensions , in such cases an Array is always returned. The performance of running prediction, either using predict or inplace_predict, is sensitive to number of blocks. Internally, it’s implemented using da.map_blocks and dd.map_partitions. When number of partitions is large and each of them have only small amount of data, the overhead of calling predict becomes visible. On the other hand, if not using GPU, the number of threads used for prediction on each block matters. Right now, xgboost uses single thread for each partition. If the number of blocks on each workers is smaller than number of cores, then the CPU workers might not be fully utilized. One simple optimization for running consecutive predictions is using distributed.Future: dataset = [X_0, X_1, X_2] booster_f = client.scatter(booster, broadcast=True) futures = [] for X in dataset:", "prev_chunk_id": "chunk_471", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_473", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Running prediction", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Running prediction", "content": "# Here we pass in a future instead of concrete booster shap_f = dxgb.predict(client, booster_f, X, pred_contribs=True) futures.append(shap_f) results = client.gather(futures) This is only available on functional interface, as the Scikit-Learn wrapper doesn’t know how to maintain a valid future for booster. To obtain the booster object from Scikit-Learn wrapper object: cls = dxgb.DaskXGBClassifier() cls.fit(X, y) booster = cls.get_booster()", "prev_chunk_id": "chunk_472", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_474", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Scikit-Learn Estimator Interface", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Scikit-Learn Estimator Interface", "content": "Scikit-Learn Estimator Interface As mentioned previously, there’s another interface that mimics the scikit-learn estimators with higher level of of abstraction. The interface is easier to use compared to the functional interface but with more constraints. It’s worth mentioning that, although the interface mimics scikit-learn estimators, it doesn’t work with normal scikit-learn utilities like GridSearchCV as scikit-learn doesn’t understand distributed dask data collection. from distributed import LocalCluster, Client from xgboost import dask as dxgb def main(client: Client) -> None: X, y = load_data() clf = dxgb.DaskXGBClassifier(n_estimators=100, tree_method=\"hist\") clf.client = client # assign the client clf.fit(X, y, eval_set=[(X, y)]) proba = clf.predict_proba(X) if __name__ == \"__main__\": with LocalCluster() as cluster: with Client(cluster) as client: main(client)", "prev_chunk_id": "chunk_473", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_475", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "GPU acceleration", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "GPU acceleration", "content": "GPU acceleration For most of the use cases with GPUs, the Dask-CUDA project should be used to create the cluster, which automatically configures the correct device ordinal for worker processes. As a result, users should NOT specify the ordinal (good: device=cuda, bad: device=cuda:1). See Example of training with Dask on GPU and Use scikit-learn regressor interface with GPU histogram tree method for worked examples.", "prev_chunk_id": "chunk_474", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_476", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Working with other clusters", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Working with other clusters", "content": "Working with other clusters Using Dask’s LocalCluster is convenient for getting started quickly on a local machine. Once you’re ready to scale your work, though, there are a number of ways to deploy Dask on a distributed cluster. You can use Dask-CUDA, for example, for GPUs and you can use Dask Cloud Provider to deploy Dask clusters in the cloud. See the Dask documentation for a more comprehensive list. In the example below, a KubeCluster is used for deploying Dask on Kubernetes: from dask_kubernetes.operator import KubeCluster # Need to install the ``dask-kubernetes`` package from dask_kubernetes.operator.kubecluster.kubecluster import CreateMode from dask.distributed import Client from xgboost import dask as dxgb import dask.array as da def main(): '''Connect to a remote kube cluster with GPU nodes and run training on it.''' m = 1000 n = 10 kWorkers = 2 # assuming you have 2 GPU nodes on that cluster. # You need to work out the worker-spec yourself. See document in dask_kubernetes for # its usage. Here we just want to show that XGBoost works on various clusters. # See notes below for why we use pre-allocated cluster. with KubeCluster( name=\"xgboost-test\", image=\"my-image-name:latest\", n_workers=kWorkers, create_mode=CreateMode.CONNECT_ONLY, shutdown_on_close=False, ) as cluster: with Client(cluster) as client: X = da.random.random(size=(m, n), chunks=100) y = X.sum(axis=1) regressor = dxgb.DaskXGBRegressor(n_estimators=10, missing=0.0) regressor.client = client regressor.set_params(tree_method='hist', device=\"cuda\") regressor.fit(X, y, eval_set=[(X, y)]) if __name__ == '__main__': # Launch the kube cluster on somewhere like GKE, then run this as client process. # main function will connect to that cluster and start training xgboost model. main() Different cluster classes might have subtle differences like network configuration, or specific cluster implementation might contains bugs that we are not aware of. Open an issue if such case is found and there’s no documentation on how to resolve it in that cluster implementation. An interesting aspect", "prev_chunk_id": "chunk_475", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_477", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Working with other clusters", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Working with other clusters", "content": "of the Kubernetes cluster is that the pods may become available after the Dask workflow has begun, which can cause issues with distributed XGBoost since XGBoost expects the nodes used by input data to remain unchanged during training. To use Kubernetes clusters, it is necessary to wait for all the pods to be online before submitting XGBoost tasks. One can either create a wait function in Python or simply pre-allocate a cluster with k8s tools (like kubectl) before running dask workflows. To pre-allocate a cluster, we can first generate the cluster spec using dask kubernetes: import json from dask_kubernetes.operator import make_cluster_spec spec = make_cluster_spec(name=\"xgboost-test\", image=\"my-image-name:latest\", n_workers=16) with open(\"cluster-spec.json\", \"w\") as fd: json.dump(spec, fd, indent=2) kubectl apply -f ./cluster-spec.json Check whether the pods are available: kubectl get pods Once all pods have been initialized, the Dask XGBoost workflow can be run, as in the previous example. It is important to ensure that the cluster sets the parameter create_mode=CreateMode.CONNECT_ONLY and optionally shutdown_on_close=False if you do not want to shut down the cluster after a single job.", "prev_chunk_id": "chunk_476", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_478", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Threads", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Threads", "content": "Threads XGBoost has built in support for parallel computation through threads by the setting nthread parameter (n_jobs for scikit-learn). If these parameters are set, they will override the configuration in Dask. For example: with dask.distributed.LocalCluster(n_workers=7, threads_per_worker=4) as cluster: There are 4 threads allocated for each dask worker. Then by default XGBoost will use 4 threads in each process for training. But if nthread parameter is set: output = dxgb.train( client, {\"verbosity\": 1, \"nthread\": 8, \"tree_method\": \"hist\"}, dtrain, num_boost_round=4, evals=[(dtrain, \"train\")], ) XGBoost will use 8 threads in each training process.", "prev_chunk_id": "chunk_477", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_479", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Working with asyncio", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Working with asyncio", "content": "Working with asyncio XGBoost’s dask interface supports the new asyncio in Python and can be integrated into asynchronous workflows. For using dask with asynchronous operations, please refer to this dask example and document in distributed. To use XGBoost’s Dask interface asynchronously, the client which is passed as an argument for training and prediction must be operating in asynchronous mode by specifying asynchronous=True when the client is created (example below). All functions (including DaskDMatrix) provided by the functional interface will then return coroutines which can then be awaited to retrieve their result. Please note that XGBoost is a compute-bounded application, where parallelism is more important than concurrency. The support for asyncio is more about compatibility instead of performance gain. Functional interface: async with dask.distributed.Client(scheduler_address, asynchronous=True) as client: X, y = generate_array() m = await dxgb.DaskDMatrix(client, X, y) output = await dxgb.train(client, {}, dtrain=m) with_m = await dxgb.predict(client, output, m) with_X = await dxgb.predict(client, output, X) inplace = await dxgb.inplace_predict(client, output, X) # Use ``client.compute`` instead of the ``compute`` method from dask collection print(await client.compute(with_m)) While for the Scikit-Learn interface, trivial methods like set_params and accessing class attributes like evals_result() do not require await. Other methods involving actual computation will return a coroutine and hence require awaiting: async with dask.distributed.Client(scheduler_address, asynchronous=True) as client: X, y = generate_array() regressor = await dxgb.DaskXGBRegressor(verbosity=1, n_estimators=2) regressor.set_params(tree_method='hist') # trivial method, synchronous operation regressor.client = client # accessing attribute, synchronous operation regressor = await regressor.fit(X, y, eval_set=[(X, y)]) prediction = await regressor.predict(X) # Use `client.compute` instead of the `compute` method from dask collection print(await client.compute(prediction))", "prev_chunk_id": "chunk_478", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_480", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Evaluation and Early Stopping", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Evaluation and Early Stopping", "content": "Evaluation and Early Stopping The Dask interface allows the use of validation sets that are stored in distributed collections (Dask DataFrame or Dask Array). These can be used for evaluation and early stopping. To enable early stopping, pass one or more validation sets containing DaskDMatrix objects. import dask.array as da from xgboost import dask as dxgb num_rows = 1e6 num_features = 100 num_partitions = 10 rows_per_chunk = num_rows / num_partitions data = da.random.random( size=(num_rows, num_features), chunks=(rows_per_chunk, num_features) ) labels = da.random.random( size=(num_rows, 1), chunks=(rows_per_chunk, 1) ) X_eval = da.random.random( size=(num_rows, num_features), chunks=(rows_per_chunk, num_features) ) y_eval = da.random.random( size=(num_rows, 1), chunks=(rows_per_chunk, 1) ) dtrain = dxgb.DaskDMatrix( client=client, data=data, label=labels ) dvalid = dxgb.DaskDMatrix( client=client, data=X_eval, label=y_eval ) result = dxgb.train( client=client, params={ \"objective\": \"reg:squarederror\", }, dtrain=dtrain, num_boost_round=10, evals=[(dvalid, \"valid1\")], early_stopping_rounds=3 ) When validation sets are provided to xgboost.dask.train() in this way, the model object returned by xgboost.dask.train() contains a history of evaluation metrics for each validation set, across all boosting rounds. print(result[\"history\"]) # {'valid1': OrderedDict([('rmse', [0.28857, 0.28858, 0.288592, 0.288598])])} If early stopping is enabled by also passing early_stopping_rounds, you can check the best iteration in the returned booster. booster = result[\"booster\"] print(booster.best_iteration) best_model = booster[: booster.best_iteration]", "prev_chunk_id": "chunk_479", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_481", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Other customization", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Other customization", "content": "Other customization XGBoost dask interface accepts other advanced features found in single node Python interface, including callback functions, custom evaluation metric and objective: def eval_error_metric(predt, dtrain: xgb.DMatrix): label = dtrain.get_label() r = np.zeros(predt.shape) gt = predt > 0.5 r[gt] = 1 - label[gt] le = predt <= 0.5 r[le] = label[le] return 'CustomErr', np.sum(r) # custom callback early_stop = xgb.callback.EarlyStopping( rounds=early_stopping_rounds, metric_name=\"CustomErr\", data_name=\"Train\", save_best=True, ) booster = dxgb.train( client, params={ \"objective\": \"binary:logistic\", \"eval_metric\": [\"error\", \"rmse\"], \"tree_method\": \"hist\", }, dtrain=D_train, evals=[(D_train, \"Train\"), (D_valid, \"Valid\")], feval=eval_error_metric, # custom evaluation metric num_boost_round=100, callbacks=[early_stop], )", "prev_chunk_id": "chunk_480", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_482", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Hyper-parameter tuning", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Hyper-parameter tuning", "content": "Hyper-parameter tuning See https://github.com/coiled/dask-xgboost-nyctaxi for a set of examples of using XGBoost with dask and optuna.", "prev_chunk_id": "chunk_481", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_483", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Learning to Rank", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Learning to Rank", "content": "Learning to Rank There are two operation modes in the Dask learning to rank for performance reasons. The difference is whether a distributed global sort is needed. Please see Distributed Training for how ranking works with distributed training in general. Below we will discuss some of the Dask-specific features. First, if you use the DaskQuantileDMatrix interface or the DaskXGBRanker with allow_group_split set to True, XGBoost will try to sort and group the samples for each worker based on the query ID. This mode tries to skip the global sort and sort only worker-local data, and hence no inter-worker data shuffle. Please note that even worker-local sort is costly, particularly in terms of memory usage as there’s no spilling when sort_values() is used, and we need to concatenate the data. XGBoost first checks whether the QID is already sorted before actually performing the sorting operation. One can choose this if the query groups are relatively consecutive, meaning most of the samples within a query group are close to each other and are likely to be resided to the same worker. Don’t use this if you have performed a random shuffle on your data. If the input data is random, then there’s no way we can guarantee most of data within the same group being in the same worker. For large query groups, this might not be an issue. But for small query groups, it’s possible that each worker gets only one or two samples from their group for all groups, which can lead to disastrous performance. In that case, we can partition the data according to query group, which is the default behavior of the DaskXGBRanker unless the allow_group_split is set to True. This mode performs a sort and a groupby on the entire dataset in addition to an encoding operation", "prev_chunk_id": "chunk_482", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_484", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Learning to Rank", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Learning to Rank", "content": "for the query group IDs. Along with partition fragmentation, this option can lead to slow performance. See Learning to rank with the Dask Interface for a worked example.", "prev_chunk_id": "chunk_483", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_485", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Troubleshooting", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Troubleshooting", "content": "Troubleshooting - In some environments XGBoost might fail to resolve the IP address of the scheduler, a symptom is user receivingOSError:[Errno99]Cannotassignrequestedaddresserror during training. A quick workaround is to specify the address explicitly. To do that the collectiveConfigis used:Added in version 3.0.0. import dask from distributed import Client from xgboost import dask as dxgb from xgboost.collective import Config # let xgboost know the scheduler address coll_cfg = Config(retry=1, timeout=20, tracker_host_ip=\"10.23.170.98\", tracker_port=0) with Client(scheduler_file=\"sched.json\") as client: reg = dxgb.DaskXGBRegressor(coll_cfg=coll_cfg) - Please note that XGBoost requires a different port than dask. By default, on a unix-like system XGBoost uses the port 0 to find available ports, which may fail if a user is running in a restricted docker environment. In this case, please open additional ports in the container and specify it as in the above snippet. - If you encounter a NCCL system error while training with GPU enabled, which usually includes the error messageNCCL failure: unhandled system error, you can specify its network configuration using one of the environment variables listed in theNCCL documentsuch as theNCCL_SOCKET_IFNAME. In addition, you can useNCCL_DEBUGto obtain debug logs. - If NCCL fails to initialize in a container environment, it might be caused by limited system shared memory. With docker, one can try the flag:–shm-size=4g. - MIG (Multi-Instance GPU) is not yet supported by NCCL. You will receive an error message that includesMultiple processes within a communication group …upon initialization. - Starting from version 2.1.0, to reduce the size of the binary wheel, the XGBoost package (installed using pip) loads NCCL from the environment instead of bundling it directly. This means that if you encounter an error message like “Failed to load nccl …”, it indicates that NCCL is not installed or properly configured in your environment.To resolve this issue, you can install NCCL using pip:pipinstallnvidia-nccl-cu12#", "prev_chunk_id": "chunk_484", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_486", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Troubleshooting", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Troubleshooting", "content": "(or with any compatible CUDA version)The default conda installation of XGBoost should not encounter this error. If you are using a customized XGBoost, please make sure one of the followings is true:XGBoost is NOT compiled with theUSE_DLOPEN_NCCLflag.Thedmlc_nccl_pathparameter is set to full NCCL path when initializing the collective.Here are some additional tips for troubleshooting NCCL dependency issues:Check the NCCL installation path and verify that it’s installed correctly. We try to find NCCL by usingfromnvidia.ncclimportlibin Python when XGBoost is installed using pip.Ensure that you have the correct CUDA version installed. NCCL requires a compatible CUDA version to function properly.If you are not using distributed training with XGBoost and yet see this error, please open an issue on GitHub.If you continue to encounter NCCL dependency issues, please open an issue on GitHub.", "prev_chunk_id": "chunk_485", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_487", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "IPv6 Support", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "IPv6 Support", "content": "IPv6 Support XGBoost has initial IPv6 support for the dask interface on Linux. Due to most of the cluster support for IPv6 is partial (dual stack instead of IPv6 only), we require additional user configuration similar to Troubleshooting to help XGBoost obtain the correct address information: import dask from distributed import Client from xgboost import dask as dxgb # let xgboost know the scheduler address, use the same bracket format as dask. with dask.config.set({\"xgboost.scheduler_address\": \"[fd20:b6f:f759:9800::]\"}): with Client(\"[fd20:b6f:f759:9800::]\") as client: reg = dxgb.DaskXGBRegressor(tree_method=\"hist\") When GPU is used, XGBoost employs NCCL as the underlying communication framework, which may require some additional configuration via environment variable depending on the setting of the cluster. Please note that IPv6 support is Unix only.", "prev_chunk_id": "chunk_486", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_488", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Logging the evaluation results", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Logging the evaluation results", "content": "Logging the evaluation results By default, the Dask interface prints evaluation results in the scheduler process. This makes it difficult for a user to monitor training progress. We can define custom evaluation monitors using callback functions. See Example of forwarding evaluation logs to the client for a worked example on how to forward the logs to the client process. In the example, there are two potential solutions using Dask builtin methods, including distributed.Client.forward_logging() and distributed.print(). Both of them have some caveats but can be a good starting point for developing more sophisticated methods like writing to files.", "prev_chunk_id": "chunk_487", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_489", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Why is the initialization of DaskDMatrix  so slow and throws weird errors", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Why is the initialization of DaskDMatrix  so slow and throws weird errors", "content": "Why is the initialization of DaskDMatrix so slow and throws weird errors The dask API in XGBoost requires construction of DaskDMatrix. With the Scikit-Learn interface, DaskDMatrix is implicitly constructed for all input data during the fit or predict steps. You might have observed that DaskDMatrix construction can take large amounts of time, and sometimes throws errors that don’t seem to be relevant to DaskDMatrix. Here is a brief explanation for why. By default most dask computations are lazily evaluated, which means that computation is not carried out until you explicitly ask for a result by, for example, calling compute(). See the previous link for details in dask, and this wiki for information on the general concept of lazy evaluation. The DaskDMatrix constructor forces lazy computations to be evaluated, which means it’s where all your earlier computation actually being carried out, including operations like dd.read_csv(). To isolate the computation in DaskDMatrix from other lazy computations, one can explicitly wait for results of input data before constructing a DaskDMatrix. Also dask’s diagnostics dashboard can be used to monitor what operations are currently being performed.", "prev_chunk_id": "chunk_488", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_490", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Reproducible Result", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Reproducible Result", "content": "Reproducible Result In a single node mode, we can always expect the same training result between runs as along as the underlying platforms are the same. However, it’s difficult to obtain reproducible result in a distributed environment, since the tasks might get different machine allocation or have different amount of available resources during different sessions. There are heuristics and guidelines on how to achieve it but no proven method for guaranteeing such deterministic behavior. The Dask interface in XGBoost tries to provide reproducible result with best effort. This section highlights some known criteria and try to share some insights into the issue. There are primarily two different tasks for XGBoost the carry out, training and inference. Inference is reproducible given the same software and hardware along with the same run-time configurations. The remaining of this section will focus on training. Many of the challenges come from the fact that we are using approximation algorithms, The sketching algorithm used to find histogram bins is an approximation to the exact quantile algorithm, the AUC metric in a distributed environment is an approximation to the exact AUC score, and floating-point number is an approximation to real number. Floating-point is an issue as its summation is not associative, meaning \\((a + b) + c\\) does not necessarily equal to \\(a + (b + c)\\), even though this property holds true for real number. As a result, whenever we change the order of a summation, the result can differ. This imposes the requirement that, in order to have reproducible output from XGBoost, the entire pipeline needs to be reproducible. - The software stack is the same for each runs. This goes without saying. XGBoost might generate different outputs between different versions. This is expected as we might change the default value of hyper-parameter, or the", "prev_chunk_id": "chunk_489", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_491", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Reproducible Result", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Reproducible Result", "content": "parallel strategy that generates different floating-point result. We guarantee the correctness the algorithms, but there are lots of wiggle room for the final output. The situation is similar for many dependencies, for instance, the random number generator might differ from platform to platform. - The hardware stack is the same for each runs. This includes the number of workers, and the amount of available resources on each worker. XGBoost can generate different results using different number of workers. This is caused by the approximation issue mentioned previously. - Similar to the hardware constraint, the network topology is also a factor in final output. If we change topology the workers might be ordered differently, leading to different ordering of floating-point operations. - The random seed used in various place of the pipeline. - The partitioning of data needs to be reproducible. This is related to the available resources on each worker. Dask might partition the data differently for each run according to its own scheduling policy. For instance, if there are some additional tasks in the cluster while you are running the second training session for XGBoost, some of the workers might have constrained memory and Dask may not push the training data for XGBoost to that worker. This change in data partitioning can lead to different output models. If you are using a shared Dask cluster, then the result is likely to vary between runs. - The operations performed on dataframes need to be reproducible. There are some operations likeDataFrame.mergenot being deterministic on parallel hardwares like GPU where the order of the index might differ from run to run. It’s expected to have different results when training the model in a distributed environment than training the model using a single node due to aforementioned criteria.", "prev_chunk_id": "chunk_490", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_492", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dask.html", "title": "Memory Usage", "page_title": "Distributed XGBoost with Dask — xgboost 3.0.4 documentation", "breadcrumbs": "Memory Usage", "content": "Memory Usage Here are some practices on reducing memory usage with dask and xgboost. - In a distributed work flow, data is best loaded by dask collections directly instead of loaded by client process. When loading with client process is unavoidable, useclient.scatterto distribute data from client process to workers. See [2] for a nice summary. - When using GPU input, like dataframe loaded bydask_cudf, you can tryxgboost.dask.DaskQuantileDMatrixas a drop in replacement forDaskDMatrixto reduce overall memory usage. SeeExample of training with Dask on GPUfor an example. - Use in-place prediction when possible. References: - https://github.com/dask/dask/issues/6833 - https://stackoverflow.com/questions/45941528/how-to-efficiently-send-a-large-numpy-array-to-the-cluster-with-dask-array", "prev_chunk_id": "chunk_491", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_493", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/kubernetes.html", "title": "Distributed XGBoost on Kubernetes", "page_title": "Distributed XGBoost on Kubernetes — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed XGBoost on Kubernetes", "content": "Distributed XGBoost on Kubernetes Distributed XGBoost training and batch prediction on Kubernetes are supported via Kubeflow XGBoost Training Operator.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_494", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/kubernetes.html", "title": "Instructions", "page_title": "Distributed XGBoost on Kubernetes — xgboost 3.0.4 documentation", "breadcrumbs": "Instructions", "content": "Instructions In order to run a XGBoost job in a Kubernetes cluster, perform the following steps: - Install XGBoost Operator on the Kubernetes cluster.XGBoost Operator is designed to manage the scheduling and monitoring of XGBoost jobs. Followthis installation guideto install XGBoost Operator. - Write application code that will be executed by the XGBoost Operator.To use XGBoost Operator, you’ll have to write a couple of Python scripts that implement the distributed training logic for XGBoost. Please refer to theIris classification example.Data reader/writer: you need to implement the data reader and writer based on the specific requirements of your chosen data source. For example, if your dataset is stored in a Hive table, you have to write the code to read from or write to the Hive table based on the index of the worker.Model persistence: in theIris classification example, the model is stored inAlibaba OSS. If you want to store your model in other storages such as Amazon S3 or Google NFS, you’ll need to implement the model persistence logic based on the requirements of the chosen storage system. - Configure the XGBoost job using a YAML file.YAML file is used to configure the computational resources and environment for your XGBoost job to run, e.g. the number of workers/masters and the number of CPU/GPUs. Please refer to thisYAML templatefor an example. - Submit XGBoost job to a Kubernetes cluster.Usekubectlto submit a distributed XGBoost job as illustratedhere.", "prev_chunk_id": "chunk_493", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_495", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/kubernetes.html", "title": "Support", "page_title": "Distributed XGBoost on Kubernetes — xgboost 3.0.4 documentation", "breadcrumbs": "Support", "content": "Support Please submit an issue on XGBoost Operator repo for any feature requests or problems.", "prev_chunk_id": "chunk_494", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_496", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/rf.html", "title": "Random Forests(TM) in XGBoost", "page_title": "Random Forests(TM) in XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Random Forests(TM) in XGBoost", "content": "Random Forests(TM) in XGBoost XGBoost is normally used to train gradient-boosted decision trees and other gradient boosted models. Random Forests use the same model representation and inference, as gradient-boosted decision trees, but a different training algorithm. One can use XGBoost to train a standalone random forest or use random forest as a base model for gradient boosting. Here we focus on training standalone random forest. We have native APIs for training random forests since the early days, and a new Scikit-Learn wrapper after 0.82 (not included in 0.82). Please note that the new Scikit-Learn wrapper is still experimental, which means we might change the interface whenever needed.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_497", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/rf.html", "title": "Standalone Random Forest With XGBoost API", "page_title": "Random Forests(TM) in XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Standalone Random Forest With XGBoost API", "content": "Standalone Random Forest With XGBoost API The following parameters must be set to enable random forest training. - boostershould be set togbtree, as we are training forests. Note that as this is the default, this parameter needn’t be set explicitly. - subsamplemust be set to a value less than 1 to enable random selection of training cases (rows). - One ofcolsample_by*parameters must be set to a value less than 1 to enable random selection of columns. Normally,colsample_bynodewould be set to a value less than 1 to randomly sample columns at each tree split. - num_parallel_treeshould be set to the size of the forest being trained. - num_boost_roundshould be set to 1 to prevent XGBoost from boosting multiple random forests. Note that this is a keyword argument totrain(), and is not part of the parameter dictionary. - eta(alias:learning_rate) must be set to 1 when training random forest regression. - random_statecan be used to seed the random number generator. Other parameters should be set in a similar way they are set for gradient boosting. For instance, objective will typically be reg:squarederror for regression and binary:logistic for classification, lambda should be set according to a desired regularization weight, etc. If both num_parallel_tree and num_boost_round are greater than 1, training will use a combination of random forest and gradient boosting strategy. It will perform num_boost_round rounds, boosting a random forest of num_parallel_tree trees at each round. If early stopping is not enabled, the final model will consist of num_parallel_tree * num_boost_round trees. Here is a sample parameter dictionary for training a random forest on a GPU using xgboost: params = { \"colsample_bynode\": 0.8, \"learning_rate\": 1, \"max_depth\": 5, \"num_parallel_tree\": 100, \"objective\": \"binary:logistic\", \"subsample\": 0.8, \"tree_method\": \"hist\", \"device\": \"cuda\", } A random forest model can then be trained as follows: bst = train(params, dmatrix, num_boost_round=1)", "prev_chunk_id": "chunk_496", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_498", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/rf.html", "title": "Standalone Random Forest With Scikit-Learn-Like API", "page_title": "Random Forests(TM) in XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Standalone Random Forest With Scikit-Learn-Like API", "content": "Standalone Random Forest With Scikit-Learn-Like API XGBRFClassifier and XGBRFRegressor are SKL-like classes that provide random forest functionality. They are basically versions of XGBClassifier and XGBRegressor that train random forest instead of gradient boosting, and have default values and meaning of some of the parameters adjusted accordingly. In particular: - n_estimatorsspecifies the size of the forest to be trained; it is converted tonum_parallel_tree, instead of the number of boosting rounds - learning_rateis set to 1 by default - colsample_bynodeandsubsampleare set to 0.8 by default - boosteris alwaysgbtree For a simple example, you can train a random forest regressor with: from sklearn.model_selection import KFold # Your code ... kf = KFold(n_splits=2) for train_index, test_index in kf.split(X, y): xgb_model = xgb.XGBRFRegressor(random_state=42).fit( X[train_index], y[train_index]) Note that these classes have a smaller selection of parameters compared to using train(). In particular, it is impossible to combine random forests with gradient boosting using this API.", "prev_chunk_id": "chunk_497", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_499", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/rf.html", "title": "Caveats", "page_title": "Random Forests(TM) in XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Caveats", "content": "Caveats - XGBoost uses 2nd order approximation to the objective function. This can lead to results that differ from a random forest implementation that uses the exact value of the objective function. - XGBoost does not perform replacement when subsampling training cases. Each training case can occur in a subsampled set either 0 or 1 time.", "prev_chunk_id": "chunk_498", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_500", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/multioutput.html", "title": "Multiple Outputs", "page_title": "Multiple Outputs — xgboost 3.0.4 documentation", "breadcrumbs": "Multiple Outputs", "content": "Multiple Outputs Starting from version 1.6, XGBoost has experimental support for multi-output regression and multi-label classification with Python package. Multi-label classification usually refers to targets that have multiple non-exclusive class labels. For instance, a movie can be simultaneously classified as both sci-fi and comedy. For detailed explanation of terminologies related to different multi-output models please refer to the scikit-learn user guide.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_501", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/multioutput.html", "title": "Training with One-Model-Per-Target", "page_title": "Multiple Outputs — xgboost 3.0.4 documentation", "breadcrumbs": "Training with One-Model-Per-Target", "content": "Training with One-Model-Per-Target By default, XGBoost builds one model for each target similar to sklearn meta estimators, with the added benefit of reusing data and other integrated features like SHAP. For a worked example of regression, see A demo for multi-output regression. For multi-label classification, the binary relevance strategy is used. Input y should be of shape (n_samples, n_classes) with each column having a value of 0 or 1 to specify whether the sample is labeled as positive for respective class. Given a sample with 3 output classes and 2 labels, the corresponding y should be encoded as [1, 0, 1] with the second class labeled as negative and the rest labeled as positive. At the moment XGBoost supports only dense matrix for labels. from sklearn.datasets import make_multilabel_classification import numpy as np X, y = make_multilabel_classification( n_samples=32, n_classes=5, n_labels=3, random_state=0 ) clf = xgb.XGBClassifier(tree_method=\"hist\") clf.fit(X, y) np.testing.assert_allclose(clf.predict(X), y) The feature is still under development with limited support from objectives and metrics.", "prev_chunk_id": "chunk_500", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_502", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/multioutput.html", "title": "Training with Vector Leaf", "page_title": "Multiple Outputs — xgboost 3.0.4 documentation", "breadcrumbs": "Training with Vector Leaf", "content": "Training with Vector Leaf XGBoost can optionally build multi-output trees with the size of leaf equals to the number of targets when the tree method hist is used. The behavior can be controlled by the multi_strategy training parameter, which can take the value one_output_per_tree (the default) for building one model per-target or multi_output_tree for building multi-output trees. clf = xgb.XGBClassifier(tree_method=\"hist\", multi_strategy=\"multi_output_tree\") See A demo for multi-output regression for a worked example with regression.", "prev_chunk_id": "chunk_501", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_503", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Categorical Data", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Categorical Data", "content": "Categorical Data Starting from version 1.5, the XGBoost Python package has experimental support for categorical data available for public testing. For numerical data, the split condition is defined as \\(value < threshold\\), while for categorical data the split is defined depending on whether partitioning or onehot encoding is used. For partition-based splits, the splits are specified as \\(value \\in categories\\), where categories is the set of categories in one feature. If onehot encoding is used instead, then the split is defined as \\(value == category\\). More advanced categorical split strategy is planned for future releases and this tutorial details how to inform XGBoost about the data type.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_504", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Training with scikit-learn Interface", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Training with scikit-learn Interface", "content": "Training with scikit-learn Interface The easiest way to pass categorical data into XGBoost is using dataframe and the scikit-learn interface like XGBClassifier. For preparing the data, users need to specify the data type of input predictor as category. For pandas/cudf Dataframe, this can be achieved by X[\"cat_feature\"].astype(\"category\") for all columns that represent categorical features. After which, users can tell XGBoost to enable training with categorical data. Assuming that you are using the XGBClassifier for classification problem, specify the parameter enable_categorical: # Supported tree methods are `approx` and `hist`. clf = xgb.XGBClassifier(tree_method=\"hist\", enable_categorical=True, device=\"cuda\") # X is the dataframe we created in previous snippet clf.fit(X, y) # Must use JSON/UBJSON for serialization, otherwise the information is lost. clf.save_model(\"categorical-model.json\") Once training is finished, most of other features can utilize the model. For instance one can plot the model and calculate the global feature importance: # Get a graph graph = xgb.to_graphviz(clf, num_trees=1) # Or get a matplotlib axis ax = xgb.plot_tree(clf, num_trees=1) # Get feature importances clf.feature_importances_ The scikit-learn interface from dask is similar to single node version. The basic idea is create dataframe with category feature type, and tell XGBoost to use it by setting the enable_categorical parameter. See Getting started with categorical data for a worked example of using categorical data with scikit-learn interface with one-hot encoding. A comparison between using one-hot encoded data and XGBoost’s categorical data support can be found Train XGBoost with cat_in_the_dat dataset.", "prev_chunk_id": "chunk_503", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_505", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Optimal Partitioning", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Optimal Partitioning", "content": "Optimal Partitioning Optimal partitioning is a technique for partitioning the categorical predictors for each node split, the proof of optimality for numerical output was first introduced by [1]. The algorithm is used in decision trees [2], later LightGBM [3] brought it to the context of gradient boosting trees and now is also adopted in XGBoost as an optional feature for handling categorical splits. More specifically, the proof by Fisher [1] states that, when trying to partition a set of discrete values into groups based on the distances between a measure of these values, one only needs to look at sorted partitions instead of enumerating all possible permutations. In the context of decision trees, the discrete values are categories, and the measure is the output leaf value. Intuitively, we want to group the categories that output similar leaf values. During split finding, we first sort the gradient histogram to prepare the contiguous partitions then enumerate the splits according to these sorted values. One of the related parameters for XGBoost is max_cat_to_onehot, which controls whether one-hot encoding or partitioning should be used for each feature, see Parameters for Categorical Feature for details.", "prev_chunk_id": "chunk_504", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_506", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Using native interface", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Using native interface", "content": "Using native interface The scikit-learn interface is user friendly, but lacks some features that are only available in native interface. For instance users cannot compute SHAP value directly. Also native interface supports more data types. To use the native interface with categorical data, we need to pass the similar parameter to DMatrix or QuantileDMatrix and the train function. For dataframe input: # X is a dataframe we created in previous snippet Xy = xgb.DMatrix(X, y, enable_categorical=True) booster = xgb.train({\"tree_method\": \"hist\", \"max_cat_to_onehot\": 5}, Xy) # Must use JSON for serialization, otherwise the information is lost booster.save_model(\"categorical-model.json\") SHAP value computation: SHAP = booster.predict(Xy, pred_interactions=True) # categorical features are listed as \"c\" print(booster.feature_types) For other types of input, like numpy array, we can tell XGBoost about the feature types by using the feature_types parameter in DMatrix: # \"q\" is numerical feature, while \"c\" is categorical feature ft = [\"q\", \"c\", \"c\"] X: np.ndarray = load_my_data() assert X.shape[1] == 3 Xy = xgb.DMatrix(X, y, feature_types=ft, enable_categorical=True) For numerical data, the feature type can be \"q\" or \"float\", while for categorical feature it’s specified as \"c\". The Dask module in XGBoost has the same interface so dask.Array can also be used for categorical data. Lastly, the sklearn interface XGBRegressor has the same parameter.", "prev_chunk_id": "chunk_505", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_507", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Data Consistency", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Data Consistency", "content": "Data Consistency XGBoost accepts parameters to indicate which feature is considered categorical, either through the dtypes of a dataframe or through the feature_types parameter. However, XGBoost by itself doesn’t store information on how categories are encoded in the first place. For instance, given an encoding schema that maps music genres to integer codes: {\"acoustic\": 0, \"indie\": 1, \"blues\": 2, \"country\": 3} XGBoost doesn’t know this mapping from the input and hence cannot store it in the model. The mapping usually happens in the users’ data engineering pipeline with column transformers like sklearn.preprocessing.OrdinalEncoder. To make sure correct result from XGBoost, users need to keep the pipeline for transforming data consistent across training and testing data. One should watch out for errors like: X_train[\"genre\"] = X_train[\"genre\"].astype(\"category\") reg = xgb.XGBRegressor(enable_categorical=True).fit(X_train, y_train) # invalid encoding X_test[\"genre\"] = X_test[\"genre\"].astype(\"category\") reg.predict(X_test) In the above snippet, training data and test data are encoded separately, resulting in two different encoding schemas and invalid prediction result. See Feature engineering pipeline for categorical data for a worked example using ordinal encoder.", "prev_chunk_id": "chunk_506", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_508", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "Miscellaneous", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "Miscellaneous", "content": "Miscellaneous By default, XGBoost assumes input categories are integers starting from 0 till the number of categories \\([0, n\\_categories)\\). However, user might provide inputs with invalid values due to mistakes or missing values in training dataset. It can be negative value, integer values that can not be accurately represented by 32-bit floating point, or values that are larger than actual number of unique categories. During training this is validated but for prediction it’s treated as the same as not-chosen category for performance reasons.", "prev_chunk_id": "chunk_507", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_509", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/categorical.html", "title": "References", "page_title": "Categorical Data — xgboost 3.0.4 documentation", "breadcrumbs": "References", "content": "References [1] Walter D. Fisher. “On Grouping for Maximum Homogeneity”. Journal of the American Statistical Association. Vol. 53, No. 284 (Dec., 1958), pp. 789-798. [2] Trevor Hastie, Robert Tibshirani, Jerome Friedman. “The Elements of Statistical Learning”. Springer Series in Statistics Springer New York Inc. (2001). [3] Guolin Ke, Qi Meng, Thomas Finley, Taifeng Wang, Wei Chen, Weidong Ma, Qiwei Ye, Tie-Yan Liu. “LightGBM: A Highly Efficient Gradient Boosting Decision Tree.” Advances in Neural Information Processing Systems 30 (NIPS 2017), pp. 3149-3157.", "prev_chunk_id": "chunk_508", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_510", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/aft_survival_analysis.html", "title": "What is survival analysis?", "page_title": "Survival Analysis with Accelerated Failure Time — xgboost 3.0.4 documentation", "breadcrumbs": "What is survival analysis?", "content": "What is survival analysis? Survival analysis (regression) models time to an event of interest. Survival analysis is a special kind of regression and differs from the conventional regression task as follows: - The label is always positive, since you cannot wait a negative amount of time until the event occurs. - The label may not be fully known, orcensored, because “it takes time to measure time.” The second bullet point is crucial and we should dwell on it more. As you may have guessed from the name, one of the earliest applications of survival analysis is to model mortality of a given population. Let’s take NCCTG Lung Cancer Dataset as an example. The first 8 columns represent features and the last column, Time to death, represents the label. Inst | Age | Sex | ph.ecog | ph.karno | pat.karno | meal.cal | wt.loss | Time to death (days) 3 | 74 | 1 | 1 | 90 | 100 | 1175 | N/A | 306 3 | 68 | 1 | 0 | 90 | 90 | 1225 | 15 | 455 3 | 56 | 1 | 0 | 90 | 90 | N/A | 15 | \\([1010, +\\infty)\\) 5 | 57 | 1 | 1 | 90 | 60 | 1150 | 11 | 210 1 | 60 | 1 | 0 | 100 | 90 | N/A | 0 | 883 12 | 74 | 1 | 1 | 50 | 80 | 513 | 0 | \\([1022, +\\infty)\\) 7 | 68 | 2 | 2 | 70 | 60 | 384 | 10 | 310 Take a close look at the label for the third patient. His label is a range, not a single number. The third patient’s label is said to be censored, because for", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_511", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/aft_survival_analysis.html", "title": "What is survival analysis?", "page_title": "Survival Analysis with Accelerated Failure Time — xgboost 3.0.4 documentation", "breadcrumbs": "What is survival analysis?", "content": "some reason the experimenters could not get a complete measurement for that label. One possible scenario: the patient survived the first 1010 days and walked out of the clinic on the 1011th day, so his death was not directly observed. Another possibility: The experiment was cut short (since you cannot run it forever) before his death could be observed. In any case, his label is \\([1010, +\\infty)\\), meaning his time to death can be any number that’s higher than 1010, e.g. 2000, 3000, or 10000. There are four kinds of censoring: - Uncensored: the label is not censored and given as a single number. - Right-censored: the label is of form\\([a, +\\infty)\\), where\\(a\\)is the lower bound. - Left-censored: the label is of form\\([0, b]\\), where\\(b\\)is the upper bound. - Interval-censored: the label is of form\\([a, b]\\), where\\(a\\)and\\(b\\)are the lower and upper bounds, respectively. Right-censoring is the most commonly used.", "prev_chunk_id": "chunk_510", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_512", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/aft_survival_analysis.html", "title": "Accelerated Failure Time model", "page_title": "Survival Analysis with Accelerated Failure Time — xgboost 3.0.4 documentation", "breadcrumbs": "Accelerated Failure Time model", "content": "Accelerated Failure Time model Accelerated Failure Time (AFT) model is one of the most commonly used models in survival analysis. The model is of the following form: where - \\(\\mathbf{x}\\)is a vector in\\(\\mathbb{R}^d\\)representing the features. - \\(\\mathbf{w}\\)is a vector consisting of\\(d\\)coefficients, each corresponding to a feature. - \\(\\langle \\cdot, \\cdot \\rangle\\)is the usual dot product in\\(\\mathbb{R}^d\\). - \\(\\ln{(\\cdot)}\\)is the natural logarithm. - \\(Y\\)and\\(Z\\)are random variables.\\(Y\\)is the output label.\\(Z\\)is a random variable of a known probability distribution. Common choices are the normal distribution, the logistic distribution, and the extreme distribution. Intuitively,\\(Z\\)represents the “noise” that pulls the prediction\\(\\langle \\mathbf{w}, \\mathbf{x} \\rangle\\)away from the true log label\\(\\ln{Y}\\). - \\(\\sigma\\)is a parameter that scales the size of\\(Z\\). Note that this model is a generalized form of a linear regression model \\(Y = \\langle \\mathbf{w}, \\mathbf{x} \\rangle\\). In order to make AFT work with gradient boosting, we revise the model as follows: where \\(\\mathcal{T}(\\mathbf{x})\\) represents the output from a decision tree ensemble, given input \\(\\mathbf{x}\\). Since \\(Z\\) is a random variable, we have a likelihood defined for the expression \\(\\ln{Y} = \\mathcal{T}(\\mathbf{x}) + \\sigma Z\\). So the goal for XGBoost is to maximize the (log) likelihood by fitting a good tree ensemble \\(\\mathcal{T}(\\mathbf{x})\\).", "prev_chunk_id": "chunk_511", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_513", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/aft_survival_analysis.html", "title": "How to use", "page_title": "Survival Analysis with Accelerated Failure Time — xgboost 3.0.4 documentation", "breadcrumbs": "How to use", "content": "How to use The first step is to express the labels in the form of a range, so that every data point has two numbers associated with it, namely the lower and upper bounds for the label. For uncensored labels, use a degenerate interval of form \\([a, a]\\). Censoring type | Interval form | Lower bound finite? | Upper bound finite? Uncensored | \\([a, a]\\) | ✔ | ✔ Right-censored | \\([a, +\\infty)\\) | ✔ | ✘ Left-censored | \\([0, b]\\) | ✔ | ✔ Interval-censored | \\([a, b]\\) | ✔ | ✔ Collect the lower bound numbers in one array (let’s call it y_lower_bound) and the upper bound number in another array (call it y_upper_bound). The ranged labels are associated with a data matrix object via calls to xgboost.DMatrix.set_float_info(): Now we are ready to invoke the training API: We set objective parameter to survival:aft and eval_metric to aft-nloglik, so that the log likelihood for the AFT model would be maximized. (XGBoost will actually minimize the negative log likelihood, hence the name aft-nloglik.) The parameter aft_loss_distribution corresponds to the distribution of the \\(Z\\) term in the AFT model, and aft_loss_distribution_scale corresponds to the scaling factor \\(\\sigma\\). Currently, you can choose from three probability distributions for aft_loss_distribution: aft_loss_distribution | Probability Density Function (PDF) normal | \\(\\dfrac{\\exp{(-z^2/2)}}{\\sqrt{2\\pi}}\\) logistic | \\(\\dfrac{e^z}{(1+e^z)^2}\\) extreme | \\(e^z e^{-\\exp{z}}\\) Note that it is not yet possible to set the ranged label using the scikit-learn interface (e.g. xgboost.XGBRegressor). For now, you should use xgboost.train with xgboost.DMatrix. For a collection of Python examples, see Survival Analysis Walkthrough", "prev_chunk_id": "chunk_512", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_514", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "Feature Interaction Constraints", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Feature Interaction Constraints", "content": "Feature Interaction Constraints The decision tree is a powerful tool to discover interaction among independent variables (features). Variables that appear together in a traversal path are interacting with one another, since the condition of a child node is predicated on the condition of the parent node. For example, the highlighted red path in the diagram below contains three variables: \\(x_1\\), \\(x_7\\), and \\(x_{10}\\), so the highlighted prediction (at the highlighted leaf node) is the product of interaction between \\(x_1\\), \\(x_7\\), and \\(x_{10}\\). When the tree depth is larger than one, many variables interact on the sole basis of minimizing training loss, and the resulting decision tree may capture a spurious relationship (noise) rather than a legitimate relationship that generalizes across different datasets. Feature interaction constraints allow users to decide which variables are allowed to interact and which are not. Potential benefits include: - Better predictive performance from focusing on interactions that work – whether through domain specific knowledge or algorithms that rank interactions - Less noise in predictions; better generalization - More control to the user on what the model can fit. For example, the user may want to exclude some interactions even if they perform well due to regulatory constraints.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_515", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "A Simple Example", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "A Simple Example", "content": "A Simple Example Feature interaction constraints are expressed in terms of groups of variables that are allowed to interact. For example, the constraint [0, 1] indicates that variables \\(x_0\\) and \\(x_1\\) are allowed to interact with each other but with no other variable. Similarly, [2, 3, 4] indicates that \\(x_2\\), \\(x_3\\), and \\(x_4\\) are allowed to interact with one another but with no other variable. A set of feature interaction constraints is expressed as a nested list, e.g. [[0, 1], [2, 3, 4]], where each inner list is a group of indices of features that are allowed to interact with each other. In the following diagram, the left decision tree is in violation of the first constraint ([0, 1]), whereas the right decision tree complies with both the first and second constraints ([0, 1], [2, 3, 4]). | forbidden | allowed", "prev_chunk_id": "chunk_514", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_516", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "Enforcing Feature Interaction Constraints in XGBoost", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Enforcing Feature Interaction Constraints in XGBoost", "content": "Enforcing Feature Interaction Constraints in XGBoost It is very simple to enforce feature interaction constraints in XGBoost. Here we will give an example using Python, but the same general idea generalizes to other platforms. Suppose the following code fits your model without feature interaction constraints: model_no_constraints = xgb.train(params, dtrain, num_boost_round = 1000, evals = evallist, early_stopping_rounds = 10) Then fitting with feature interaction constraints only requires adding a single parameter: params_constrained = params.copy() # Use nested list to define feature interaction constraints params_constrained['interaction_constraints'] = '[[0, 2], [1, 3, 4], [5, 6]]' # Features 0 and 2 are allowed to interact with each other but with no other feature # Features 1, 3, 4 are allowed to interact with one another but with no other feature # Features 5 and 6 are allowed to interact with each other but with no other feature model_with_constraints = xgb.train(params_constrained, dtrain, num_boost_round = 1000, evals = evallist, early_stopping_rounds = 10)", "prev_chunk_id": "chunk_515", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_517", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "Using feature name instead", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Using feature name instead", "content": "Using feature name instead XGBoost’s Python and R packages support using feature names instead of feature index for specifying the constraints. Given a data frame with columns [\"f0\", \"f1\", \"f2\"], the feature interaction constraint can be specified as [[\"f0\", \"f2\"]] (Python) or list(c(\"f0\", \"f2\")) (R, when passing them to function xgboost()).", "prev_chunk_id": "chunk_516", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_518", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "Advanced topic", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Advanced topic", "content": "Advanced topic The intuition behind interaction constraints is simple. Users may have prior knowledge about relations between different features, and encode it as constraints during model construction. But there are also some subtleties around specifying constraints. Take the constraint [[1, 2], [2, 3, 4]] as an example. The second feature appears in two different interaction sets, [1, 2] and [2, 3, 4]. So the union set of features allowed to interact with 2 is {1, 3, 4}. In the following diagram, the root splits at feature 2. Because all its descendants should be able to interact with it, all 4 features are legitimate split candidates at the second layer. At first sight, this might look like disregarding the specified constraint sets, but it is not. This has lead to some interesting implications of feature interaction constraints. Take [[0, 1], [0, 1, 2], [1, 2]] as another example. Assuming we have only 3 available features in our training datasets for presentation purpose, careful readers might have found out that the above constraint is the same as simply [[0, 1, 2]]. Since no matter which feature is chosen for split in the root node, all its descendants are allowed to include every feature as legitimate split candidates without violating interaction constraints. For one last example, we use [[0, 1], [1, 3, 4]] and choose feature 0 as split for the root node. At the second layer of the built tree, 1 is the only legitimate split candidate except for 0 itself, since they belong to the same constraint set. Following the grow path of our example tree below, the node at the second layer splits at feature 1. But due to the fact that 1 also belongs to second constraint set [1, 3, 4], at the third layer, we are allowed to", "prev_chunk_id": "chunk_517", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_519", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/feature_interaction_constraint.html", "title": "Advanced topic", "page_title": "Feature Interaction Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Advanced topic", "content": "include all features as split candidates and still comply with the interaction constraints of its ascendants.", "prev_chunk_id": "chunk_518", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_520", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/monotonic.html", "title": "Monotonic Constraints", "page_title": "Monotonic Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Monotonic Constraints", "content": "Monotonic Constraints It is often the case in a modeling problem or project that the functional form of an acceptable model is constrained in some way. This may happen due to business considerations, or because of the type of scientific question being investigated. In some cases, where there is a very strong prior belief that the true relationship has some quality, constraints can be used to improve the predictive performance of the model. A common type of constraint in this situation is that certain features bear a monotonic relationship to the predicted response: whenever \\(x \\leq x'\\) is an increasing constraint; or whenever \\(x \\leq x'\\) is a decreasing constraint. XGBoost has the ability to enforce monotonicity constraints on any features used in a boosted model.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_521", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/monotonic.html", "title": "A Simple Example", "page_title": "Monotonic Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "A Simple Example", "content": "A Simple Example To illustrate, let’s create some simulated data with two features and a response according to the following scheme The response generally increases with respect to the \\(x_1\\) feature, but a sinusoidal variation has been superimposed, resulting in the true effect being non-monotonic. For the \\(x_2\\) feature the variation is decreasing with a sinusoidal variation. Let’s fit a boosted tree model to this data without imposing any monotonic constraints: The black curve shows the trend inferred from the model for each feature. To make these plots the distinguished feature \\(x_i\\) is fed to the model over a one-dimensional grid of values, while all the other features (in this case only one other feature) are set to their average values. We see that the model does a good job of capturing the general trend with the oscillatory wave superimposed. Here is the same model, but fit with monotonicity constraints: We see the effect of the constraint. For each variable the general direction of the trend is still evident, but the oscillatory behaviour no longer remains as it would violate our imposed constraints.", "prev_chunk_id": "chunk_520", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_522", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/monotonic.html", "title": "Enforcing Monotonic Constraints in XGBoost", "page_title": "Monotonic Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Enforcing Monotonic Constraints in XGBoost", "content": "Enforcing Monotonic Constraints in XGBoost It is very simple to enforce monotonicity constraints in XGBoost. Here we will give an example using Python, but the same general idea generalizes to other platforms. Suppose the following code fits your model without monotonicity constraints model_no_constraints = xgb.train(params, dtrain, num_boost_round = 1000, evals = evallist, early_stopping_rounds = 10) Then fitting with monotonicity constraints only requires adding a single parameter params_constrained = params.copy() params_constrained['monotone_constraints'] = (1,-1) model_with_constraints = xgb.train(params_constrained, dtrain, num_boost_round = 1000, evals = evallist, early_stopping_rounds = 10) In this example the training data X has two columns, and by using the parameter values (1,-1) we are telling XGBoost to impose an increasing constraint on the first predictor and a decreasing constraint on the second. Some other examples: - (1,0): An increasing constraint on the first predictor and no constraint on the second. - (0,-1): No constraint on the first predictor and a decreasing constraint on the second.", "prev_chunk_id": "chunk_521", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_523", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/monotonic.html", "title": "Using feature names", "page_title": "Monotonic Constraints — xgboost 3.0.4 documentation", "breadcrumbs": "Using feature names", "content": "Using feature names XGBoost’s Python and R packages support using feature names instead of feature indices for specifying the constraints. Given a data frame with columns [\"f0\", \"f1\", \"f2\"], the monotonic constraint can be specified as {\"f0\": 1, \"f2\": -1} (Python) or as list(f0=1, f2=-1) (R, when using ‘xgboost()’, but not ‘xgb.train’), and \"f1\" will default to 0 (no constraint).", "prev_chunk_id": "chunk_522", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_524", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "DART booster", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "DART booster", "content": "DART booster XGBoost mostly combines a huge number of regression trees with a small learning rate. In this situation, trees added early are significant and trees added late are unimportant. Vinayak and Gilad-Bachrach proposed a new method to add dropout techniques from the deep neural net community to boosted trees, and reported better results in some situations. This is a instruction of new tree booster dart.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_525", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "Original paper", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "Original paper", "content": "Original paper Rashmi Korlakai Vinayak, Ran Gilad-Bachrach. “DART: Dropouts meet Multiple Additive Regression Trees.” [PMLR, arXiv].", "prev_chunk_id": "chunk_524", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_526", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "Features", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "Features", "content": "Features - Drop trees in order to solve the over-fitting.Trivial trees (to correct trivial errors) may be prevented. Because of the randomness introduced in the training, expect the following few differences: - Training can be slower thangbtreebecause the random dropout prevents usage of the prediction buffer. - The early stop might not be stable, due to the randomness.", "prev_chunk_id": "chunk_525", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_527", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "How it works", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "How it works", "content": "How it works - In\\(m\\)-th training round, suppose\\(k\\)trees are selected to be dropped. - Let\\(D = \\sum_{i \\in \\mathbf{K}} F_i\\)be the leaf scores of dropped trees and\\(F_m = \\eta \\tilde{F}_m\\)be the leaf scores of a new tree. - The objective function is as follows: - \\(D\\)and\\(F_m\\)are overshooting, so using scale factor", "prev_chunk_id": "chunk_526", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_528", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "Parameters", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "Parameters", "content": "Parameters The booster dart inherits gbtree booster, so it supports all parameters that gbtree does, such as eta, gamma, max_depth etc. Additional parameters are noted below: - sample_type: type of sampling algorithm.uniform: (default) dropped trees are selected uniformly.weighted: dropped trees are selected in proportion to weight. - normalize_type: type of normalization algorithm.tree: (default) New trees have the same weight of each of dropped trees.\\[\\begin{split}a \\left( \\sum_{i \\in \\mathbf{K}} F_i + \\frac{1}{k} F_m \\right) &= a \\left( \\sum_{i \\in \\mathbf{K}} F_i + \\frac{\\eta}{k} \\tilde{F}_m \\right) \\\\ &\\sim a \\left( 1 + \\frac{\\eta}{k} \\right) D \\\\ &= a \\frac{k + \\eta}{k} D = D , \\\\ &\\quad a = \\frac{k}{k + \\eta}\\end{split}\\]forest: New trees have the same weight of sum of dropped trees (forest).\\[\\begin{split}a \\left( \\sum_{i \\in \\mathbf{K}} F_i + F_m \\right) &= a \\left( \\sum_{i \\in \\mathbf{K}} F_i + \\eta \\tilde{F}_m \\right) \\\\ &\\sim a \\left( 1 + \\eta \\right) D \\\\ &= a (1 + \\eta) D = D , \\\\ &\\quad a = \\frac{1}{1 + \\eta} .\\end{split}\\] - rate_drop: dropout rate.range: [0.0, 1.0] - skip_drop: probability of skipping dropout.If a dropout is skipped, new trees are added in the same manner as gbtree.range: [0.0, 1.0]", "prev_chunk_id": "chunk_527", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_529", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/dart.html", "title": "Sample Script", "page_title": "DART booster — xgboost 3.0.4 documentation", "breadcrumbs": "Sample Script", "content": "Sample Script import xgboost as xgb # read in data dtrain = xgb.DMatrix('demo/data/agaricus.txt.train?format=libsvm') dtest = xgb.DMatrix('demo/data/agaricus.txt.test?format=libsvm') # specify parameters via map param = {'booster': 'dart', 'max_depth': 5, 'learning_rate': 0.1, 'objective': 'binary:logistic', 'sample_type': 'uniform', 'normalize_type': 'tree', 'rate_drop': 0.1, 'skip_drop': 0.5} num_round = 50 bst = xgb.train(param, dtrain, num_round) preds = bst.predict(dtest)", "prev_chunk_id": "chunk_528", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_530", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Learning to Rank", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Learning to Rank", "content": "Learning to Rank Contents", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_531", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Overview", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Overview", "content": "Overview Often in the context of information retrieval, learning-to-rank aims to train a model that arranges a set of query results into an ordered list [1]. For supervised learning-to-rank, the predictors are sample documents encoded as feature matrix, and the labels are relevance degree for each sample. Relevance degree can be multi-level (graded) or binary (relevant or not). The training samples are often grouped by their query index with each query group containing multiple query results. XGBoost implements learning to rank through a set of objective functions and performance metrics. The default objective is rank:ndcg based on the LambdaMART [2] algorithm, which in turn is an adaptation of the LambdaRank [3] framework to gradient boosting trees. For a history and a summary of the algorithm, see [5]. The implementation in XGBoost features deterministic GPU computation, distributed training, position debiasing and two different pair construction strategies.", "prev_chunk_id": "chunk_530", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_532", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Training with the Pairwise Objective", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Training with the Pairwise Objective", "content": "Training with the Pairwise Objective LambdaMART is a pairwise ranking model, meaning that it compares the relevance degree for every pair of samples in a query group and calculate a proxy gradient for each pair. The default objective rank:ndcg is using the surrogate gradient derived from the ndcg metric. To train a XGBoost model, we need an additional sorted array called qid for specifying the query group of input samples. An example input would look like this: QID | Label | Features 1 | 0 | \\(x_1\\) 1 | 1 | \\(x_2\\) 1 | 0 | \\(x_3\\) 2 | 0 | \\(x_4\\) 2 | 1 | \\(x_5\\) 2 | 1 | \\(x_6\\) 2 | 1 | \\(x_7\\) Notice that the samples are sorted based on their query index in a non-decreasing order. In the above example, the first three samples belong to the first query and the next four samples belong to the second. For the sake of simplicity, we will use a synthetic binary learning-to-rank dataset in the following code snippets, with binary labels representing whether the result is relevant or not, and randomly assign the query group index to each sample. For an example that uses a real world dataset, please see Getting started with learning to rank. from sklearn.datasets import make_classification import numpy as np import xgboost as xgb # Make a synthetic ranking dataset for demonstration seed = 1994 X, y = make_classification(random_state=seed) rng = np.random.default_rng(seed) n_query_groups = 3 qid = rng.integers(0, n_query_groups, size=X.shape[0]) # Sort the inputs based on query index sorted_idx = np.argsort(qid) X = X[sorted_idx, :] y = y[sorted_idx] qid = qid[sorted_idx] The simplest way to train a ranking model is by using the scikit-learn estimator interface. Continuing the previous snippet, we can train a simple ranking model without tuning: ranker = xgb.XGBRanker(tree_method=\"hist\",", "prev_chunk_id": "chunk_531", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_533", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Training with the Pairwise Objective", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Training with the Pairwise Objective", "content": "lambdarank_num_pair_per_sample=8, objective=\"rank:ndcg\", lambdarank_pair_method=\"topk\") ranker.fit(X, y, qid=qid) Please note that, as of writing, there’s no learning-to-rank interface in scikit-learn. As a result, the xgboost.XGBRanker class does not fully conform the scikit-learn estimator guideline and can not be directly used with some of its utility functions. For instances, the auc_score and ndcg_score in scikit-learn don’t consider query group information nor the pairwise loss. Most of the metrics are implemented as part of XGBoost, but to use scikit-learn utilities like sklearn.model_selection.cross_validation(), we need to make some adjustments in order to pass the qid as an additional parameter for xgboost.XGBRanker.score(). Given a data frame X (either pandas or cuDF), add the column qid as follows: import pandas as pd # `X`, `qid`, and `y` are from the previous snippet, they are all sorted by the `sorted_idx`. df = pd.DataFrame(X, columns=[str(i) for i in range(X.shape[1])]) df[\"qid\"] = qid ranker.fit(df, y) # No need to pass qid as a separate argument from sklearn.model_selection import StratifiedGroupKFold, cross_val_score # Works with cv in scikit-learn, along with HPO utilities like GridSearchCV kfold = StratifiedGroupKFold(shuffle=False) cross_val_score(ranker, df, y, cv=kfold, groups=df.qid) The above snippets build a model using LambdaMART with the NDCG@8 metric. The outputs of a ranker are relevance scores: scores = ranker.predict(X) sorted_idx = np.argsort(scores)[::-1] # Sort the relevance scores from most relevant to least relevant scores = scores[sorted_idx]", "prev_chunk_id": "chunk_532", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_534", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Position Bias", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Position Bias", "content": "Position Bias Obtaining real relevance degrees for query results is an expensive and strenuous, requiring human labelers to label all results one by one. When such labeling task is infeasible, we might want to train the learning-to-rank model on user click data instead, as it is relatively easy to collect. Another advantage of using click data directly is that it can reflect the most up-to-date user preferences [1]. However, user clicks are often biased, as users tend to choose results that are displayed in higher positions. User clicks are also noisy, where users might accidentally click on irrelevant documents. To ameliorate these issues, XGBoost implements the Unbiased LambdaMART [4] algorithm to debias the position-dependent click data. The feature can be enabled by the lambdarank_unbiased parameter; see Parameters for learning to rank (rank:ndcg, rank:map, rank:pairwise) for related options and Getting started with learning to rank for a worked example with simulated user clicks.", "prev_chunk_id": "chunk_533", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_535", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Loss", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Loss", "content": "Loss XGBoost implements different LambdaMART objectives based on different metrics. We list them here as a reference. Other than those used as objective function, XGBoost also implements metrics like pre (for precision) for evaluation. See parameters for available options and the following sections for how to choose these objectives based of the amount of effective pairs. - NDCG Normalized Discounted Cumulative Gain NDCG can be used with both binary relevance and multi-level relevance. If you are not sure about your data, this metric can be used as the default. The name for the objective is rank:ndcg. - MAP Mean average precision MAP is a binary measure. It can be used when the relevance label is 0 or 1. The name for the objective is rank:map. - Pairwise The LambdaMART algorithm scales the logistic loss with learning to rank metrics like NDCG in the hope of including ranking information into the loss function. The rank:pairwise loss is the original version of the pairwise loss, also known as the RankNet loss [7] or the pairwise logistic loss. Unlike the rank:map and the rank:ndcg, no scaling is applied (\\(|\\Delta Z_{ij}| = 1\\)). Whether scaling with a LTR metric is actually more effective is still up for debate; [8] provides a theoretical foundation for general lambda loss functions and some insights into the framework.", "prev_chunk_id": "chunk_534", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_536", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Constructing Pairs", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Constructing Pairs", "content": "Constructing Pairs There are two implemented strategies for constructing document pairs for \\(\\lambda\\)-gradient calculation. The first one is the mean method, another one is the topk method. The preferred strategy can be specified by the lambdarank_pair_method parameter. For the mean strategy, XGBoost samples lambdarank_num_pair_per_sample pairs for each document in a query list. For example, given a list of 3 documents and lambdarank_num_pair_per_sample is set to 2, XGBoost will randomly sample 6 pairs, assuming the labels for these documents are different. On the other hand, if the pair method is set to topk, XGBoost constructs about \\(k \\times |query|\\) number of pairs with \\(|query|\\) pairs for each sample at the top \\(k = lambdarank\\_num\\_pair\\) position. The number of pairs counted here is an approximation since we skip pairs that have the same label.", "prev_chunk_id": "chunk_535", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_537", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Obtaining Good Result", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Obtaining Good Result", "content": "Obtaining Good Result Learning to rank is a sophisticated task and an active research area. It’s not trivial to train a model that generalizes well. There are multiple loss functions available in XGBoost along with a set of hyperparameters. This section contains some hints for how to choose hyperparameters as a starting point. One can further optimize the model by tuning these hyperparameters. The first question would be how to choose an objective that matches the task at hand. If your input data has multi-level relevance degrees, then either rank:ndcg or rank:pairwise should be used. However, when the input has binary labels, we have multiple options based on the target metric. [6] provides some guidelines on this topic and users are encouraged to see the analysis done in their work. The choice should be based on the number of effective pairs, which refers to the number of pairs that can generate non-zero gradient and contribute to training. LambdaMART with MRR has the least amount of effective pairs as the \\(\\lambda\\)-gradient is only non-zero when the pair contains a non-relevant document ranked higher than the top relevant document. As a result, it’s not implemented in XGBoost. Since NDCG is a multi-level metric, it usually generate more effective pairs than MAP. However, when there are sufficiently many effective pairs, it’s shown in [6] that matching the target metric with the objective is of significance. When the target metric is MAP and you are using a large dataset that can provide a sufficient amount of effective pairs, rank:map can in theory yield higher MAP value than rank:ndcg. The consideration of effective pairs also applies to the choice of pair method (lambdarank_pair_method) and the number of pairs for each sample (lambdarank_num_pair_per_sample). For example, the mean-NDCG considers more pairs than NDCG@10, so the former generates", "prev_chunk_id": "chunk_536", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_538", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Obtaining Good Result", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Obtaining Good Result", "content": "more effective pairs and provides more granularity than the latter. Also, using the mean strategy can help the model generalize with random sampling. However, one might want to focus the training on the top \\(k\\) documents instead of using all pairs, to better fit their real-world application. When using the mean strategy for generating pairs, where the target metric (like NDCG) is computed over the whole query list, users can specify how many pairs should be generated per each document, by setting the lambdarank_num_pair_per_sample. XGBoost will randomly sample lambdarank_num_pair_per_sample pairs for each element in the query group (\\(|pairs| = |query| \\times num\\_pairsample\\)). Often, setting it to 1 can produce reasonable results. In cases where performance is inadequate due to insufficient number of effective pairs being generated, set lambdarank_num_pair_per_sample to a higher value. As more document pairs are generated, more effective pairs will be generated as well. On the other hand, if you are prioritizing the top \\(k\\) documents, the lambdarank_num_pair_per_sample should be set slightly higher than \\(k\\) (with a few more documents) to obtain a good training result. Lastly, XGBoost employs additional regularization for learning to rank objectives, which can be disabled by setting the lambdarank_normalization to False. Summary If you have large amount of training data: - Use the target-matching objective. - Choose thetopkstrategy for generating document pairs (if it’s appropriate for your application). On the other hand, if you have comparatively small amount of training data: - SelectNDCGor the RankNet loss (rank:pairwise). - Choose themeanstrategy for generating document pairs, to obtain more effective pairs. For any method chosen, you can modify lambdarank_num_pair_per_sample to control the amount of pairs generated.", "prev_chunk_id": "chunk_537", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_539", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Distributed Training", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed Training", "content": "Distributed Training XGBoost implements distributed learning-to-rank with integration of multiple frameworks including Dask, Spark, and PySpark. The interface is similar to the single-node counterpart. Please refer to document of the respective XGBoost interface for details. XGBoost works with collective operations, which means data is scattered to multiple workers. We can divide the data partitions by query group and ensure no query group is split among workers. However, this requires a costly sort and groupby operation and might only be necessary for selected use cases. Splitting and scattering a query group to multiple workers is theoretically sound but can affect the model’s accuracy. If there are only a small number of groups sitting at the boundaries of workers, the small discrepancy is not an issue, as the amount of training data is usually large when distributed training is used. For a longer explanation, assuming the pairwise ranking method is used, we calculate the gradient based on relevance degree by constructing pairs within a query group. If a single query group is split among workers and we use worker-local data for gradient calculation, then we are simply sampling pairs from a smaller group for each worker to calculate the gradient and the evaluation metric. The comparison between each pair doesn’t change because a group is split into sub-groups, what changes is the number of total and effective pairs and normalizers like IDCG. One can generate more pairs from a large group than it’s from two smaller subgroups. As a result, the obtained gradient is still valid from a theoretical standpoint but might not be optimal. As long as each data partitions within a worker are correctly sorted by query IDs, XGBoost can aggregate sample gradients accordingly. And both the (Py)Spark interface and the Dask interface can sort the data according to query", "prev_chunk_id": "chunk_538", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_540", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Distributed Training", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Distributed Training", "content": "ID, please see respected tutorials for more information. However, it’s possible that a distributed framework shuffles the data during map reduce and splits every query group into multiple workers. In that case, the performance would be disastrous. As a result, it depends on the data and the framework for whether a sorted groupby is needed.", "prev_chunk_id": "chunk_539", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_541", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Comparing Results with Version 1.7", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Comparing Results with Version 1.7", "content": "Comparing Results with Version 1.7 The learning to rank implementation has been significantly updated in 2.0 with added hyper-parameters and training strategies. To obtain similar result as the 1.7 xgboost.XGBRanker, following parameter should be used: params = { # 1.7 only supports sampling, while 2.0 and later use top-k as the default. # See above sections for the trade-off. \"lambdarank_pair_method\": \"mean\", # 1.7 uses the ranknet loss while later versions use the NDCG weighted loss \"objective\": \"rank:pairwise\", # 1.7 doesn't have this normalization. \"lambdarank_score_normalization\": False, \"base_score\": 0.5, # The default tree method has been changed from approx to hist. \"tree_method\": \"approx\", # The default for `mean` pair method is one pair each sample, which is the default in 1.7 as well. # You can leave it as unset. \"lambdarank_num_pair_per_sample\": 1, } The result still differs due to the change of random seed. But the overall training strategy would be the same for rank:pairwise.", "prev_chunk_id": "chunk_540", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_542", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "Reproducible Result", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "Reproducible Result", "content": "Reproducible Result Like any other tasks, XGBoost should generate reproducible results given the same hardware and software environments (and data partitions, if distributed interface is used). Even when the underlying environment has changed, the result should still be consistent. However, when the lambdarank_pair_method is set to mean, XGBoost uses random sampling, and results may differ depending on the platform used. The random number generator used on Windows (Microsoft Visual C++) is different from the ones used on other platforms like Linux (GCC, Clang) [1], so the output varies significantly between these platforms.", "prev_chunk_id": "chunk_541", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_543", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/learning_to_rank.html", "title": "References", "page_title": "Learning to Rank — xgboost 3.0.4 documentation", "breadcrumbs": "References", "content": "References [1] Tie-Yan Liu. 2009. “Learning to Rank for Information Retrieval”. Found. Trends Inf. Retr. 3, 3 (March 2009), 225–331. [2] Christopher J. C. Burges, Robert Ragno, and Quoc Viet Le. 2006. “Learning to rank with nonsmooth cost functions”. In Proceedings of the 19th International Conference on Neural Information Processing Systems (NIPS’06). MIT Press, Cambridge, MA, USA, 193–200. [3] Wu, Q., Burges, C.J.C., Svore, K.M. et al. “Adapting boosting for information retrieval measures”. Inf Retrieval 13, 254–270 (2010). [4] Ziniu Hu, Yang Wang, Qu Peng, Hang Li. “Unbiased LambdaMART: An Unbiased Pairwise Learning-to-Rank Algorithm”. Proceedings of the 2019 World Wide Web Conference. [5] Burges, Chris J.C. “From RankNet to LambdaRank to LambdaMART: An Overview”. MSR-TR-2010-82 [6] Pinar Donmez, Krysta M. Svore, and Christopher J.C. Burges. 2009. “On the local optimality of LambdaRank”. In Proceedings of the 32nd international ACM SIGIR conference on Research and development in information retrieval (SIGIR ‘09). Association for Computing Machinery, New York, NY, USA, 460–467. [7] Chris Burges, Tal Shaked, Erin Renshaw, Ari Lazier, Matt Deeds, Nicole Hamilton, and Greg Hullender. 2005. “Learning to rank using gradient descent”. In Proceedings of the 22nd international conference on Machine learning (ICML ‘05). Association for Computing Machinery, New York, NY, USA, 89–96. [8] Xuanhui Wang and Cheng Li and Nadav Golbandi and Mike Bendersky and Marc Najork. 2018. “The LambdaLoss Framework for Ranking Metric Optimization”. Proceedings of The 27th ACM International Conference on Information and Knowledge Management (CIKM ‘18).", "prev_chunk_id": "chunk_542", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_544", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Introduction to Model IO", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Introduction to Model IO", "content": "Introduction to Model IO Since 2.1.0, the default model format for XGBoost is the UBJSON format, the option is enabled for serializing models to file, serializing models to buffer, and for memory snapshot (pickle and alike). In XGBoost 1.0.0, we introduced support of using JSON for saving/loading XGBoost models and related hyper-parameters for training, aiming to replace the old binary internal format with an open format that can be easily reused. Later in XGBoost 1.6.0, additional support for Universal Binary JSON is added as an optimization for more efficient model IO, which is set to default in 2.1. JSON and UBJSON have the same document structure with different representations, and we will refer them collectively as the JSON format. This tutorial aims to share some basic insights into the JSON serialisation method used in XGBoost. Without explicitly mentioned, the following sections assume you are using the one of the 2 outputs formats, which can be enabled by providing the file name with .json (or .ubj for binary JSON) as file extension when saving/loading model: booster.save_model('model.json'). More details below. Before we get started, XGBoost is a gradient boosting library with focus on tree model, which means inside XGBoost, there are 2 distinct parts: - The model consisting of trees and - Hyperparameters and configurations used for building the model. If you come from Deep Learning community, then it should be clear to you that there are differences between the neural network structures composed of weights with fixed tensor operations, and the optimizers (like RMSprop) used to train them. So when one calls booster.save_model (xgb.save in R), XGBoost saves the trees, some model parameters like number of input columns in trained trees, and the objective function, which combined to represent the concept of “model” in XGBoost. As for why are we saving", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_545", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Introduction to Model IO", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Introduction to Model IO", "content": "the objective as part of model, that’s because objective controls transformation of global bias (called base_score in XGBoost) and task-specific information. Users can share this model with others for prediction, evaluation or continue the training with a different set of hyper-parameters etc. However, this is not the end of story. There are cases where we need to save something more than just the model itself. For example, in distributed training, XGBoost performs checkpointing operation. Or for some reasons, your favorite distributed computing framework decide to copy the model from one worker to another and continue the training in there. In such cases, the serialisation output is required to contain enough information to continue previous training without user providing any parameters again. We consider such scenario as memory snapshot (or memory based serialisation method) and distinguish it with normal model IO operation. Currently, memory snapshot is used in the following places: - Python package: when theBoosterobject is pickled with the built-inpicklemodule. - R package: when thexgb.Boosterobject is persisted with the built-in functionssaveRDSorsave. - JVM packages: when theBoosterobject is serialized with the built-in functionssaveModel. Other language bindings are still working in progress. To enable JSON format support for model IO (saving only the trees and objective), provide a filename with .json or .ubj as file extension, the latter is the extension for Universal Binary JSON While for memory snapshot, UBJSON is the default starting with xgboost 1.6. When loading the model back, XGBoost recognizes the file extensions .json and .ubj, and can dispatch accordingly. If the extension is not specified, XGBoost tries to guess the right one.", "prev_chunk_id": "chunk_544", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_546", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "A note on backward compatibility of models and memory snapshots", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "A note on backward compatibility of models and memory snapshots", "content": "A note on backward compatibility of models and memory snapshots We guarantee backward compatibility for models but not for memory snapshots. Models (trees and objective) use a stable representation, so that models produced in earlier versions of XGBoost are accessible in later versions of XGBoost. If you’d like to store or archive your model for long-term storage, use save_model (Python) and xgb.save (R). On the other hand, memory snapshot (serialisation) captures many stuff internal to XGBoost, and its format is not stable and is subject to frequent changes. Therefore, memory snapshot is suitable for checkpointing only, where you persist the complete snapshot of the training configurations so that you can recover robustly from possible failures and resume the training process. Loading memory snapshot generated by an earlier version of XGBoost may result in errors or undefined behaviors. If a model is persisted with pickle.dump (Python) or saveRDS (R), then the model may not be accessible in later versions of XGBoost.", "prev_chunk_id": "chunk_545", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_547", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Custom objective and metric", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Custom objective and metric", "content": "Custom objective and metric XGBoost accepts user provided objective and metric functions as an extension. These functions are not saved in model file as they are language dependent features. With Python, user can pickle the model to include these functions in saved binary. One drawback is, the output from pickle is not a stable serialization format and doesn’t work on different Python version nor XGBoost version, not to mention different language environments. Another way to workaround this limitation is to provide these functions again after the model is loaded. If the customized function is useful, please consider making a PR for implementing it inside XGBoost, this way we can have your functions working with different language bindings.", "prev_chunk_id": "chunk_546", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_548", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Loading pickled file from different version of XGBoost", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Loading pickled file from different version of XGBoost", "content": "Loading pickled file from different version of XGBoost As noted, pickled model is neither portable nor stable, but in some cases the pickled models are valuable. One way to restore it in the future is to load it back with that specific version of Python and XGBoost, export the model by calling save_model. A similar procedure may be used to recover the model persisted in an old RDS file. In R, you are able to install an older version of XGBoost using the remotes package: library(remotes) remotes::install_version(\"xgboost\", \"0.90.0.1\") # Install version 0.90.0.1 Once the desired version is installed, you can load the RDS file with readRDS and recover the xgb.Booster object. Then call xgb.save to export the model using the stable representation. Now you should be able to use the model in the latest version of XGBoost.", "prev_chunk_id": "chunk_547", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_549", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Saving and Loading the internal parameters configuration", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Saving and Loading the internal parameters configuration", "content": "Saving and Loading the internal parameters configuration XGBoost’s C API, Python API and R API support saving and loading the internal configuration directly as a JSON string. In Python package: bst = xgboost.train(...) config = bst.save_config() print(config) or in R: config <- xgb.config(bst) print(config) Will print out something similar to (not actual output as it’s too long for demonstration): { \"Learner\": { \"generic_parameter\": { \"device\": \"cuda:0\", \"gpu_page_size\": \"0\", \"n_jobs\": \"0\", \"random_state\": \"0\", \"seed\": \"0\", \"seed_per_iteration\": \"0\" }, \"gradient_booster\": { \"gbtree_train_param\": { \"num_parallel_tree\": \"1\", \"process_type\": \"default\", \"tree_method\": \"hist\", \"updater\": \"grow_gpu_hist\", \"updater_seq\": \"grow_gpu_hist\" }, \"name\": \"gbtree\", \"updater\": { \"grow_gpu_hist\": { \"gpu_hist_train_param\": { \"debug_synchronize\": \"0\", }, \"train_param\": { \"alpha\": \"0\", \"cache_opt\": \"1\", \"colsample_bylevel\": \"1\", \"colsample_bynode\": \"1\", \"colsample_bytree\": \"1\", \"default_direction\": \"learn\", ... \"subsample\": \"1\" } } } }, \"learner_train_param\": { \"booster\": \"gbtree\", \"disable_default_eval_metric\": \"0\", \"objective\": \"reg:squarederror\" }, \"metrics\": [], \"objective\": { \"name\": \"reg:squarederror\", \"reg_loss_param\": { \"scale_pos_weight\": \"1\" } } }, \"version\": [1, 0, 0] } You can load it back to the model generated by same version of XGBoost by: bst.load_config(config) This way users can study the internal representation more closely. Please note that some JSON generators make use of locale dependent floating point serialization methods, which is not supported by XGBoost.", "prev_chunk_id": "chunk_548", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_550", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "Difference between saving model and dumping model", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "Difference between saving model and dumping model", "content": "Difference between saving model and dumping model XGBoost has a function called dump_model in Booster object, which lets you to export the model in a readable format like text, json or dot (graphviz). The primary use case for it is for model interpretation or visualization, and is not supposed to be loaded back to XGBoost. The JSON version has a schema. See next section for more info.", "prev_chunk_id": "chunk_549", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_551", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "JSON Schema", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "JSON Schema", "content": "JSON Schema Another important feature of JSON format is a documented schema, based on which one can easily reuse the output model from XGBoost. Here is the JSON schema for the output model (not serialization, which will not be stable as noted above). For an example of parsing XGBoost tree model, see /demo/json-model. Please notice the “weight_drop” field used in “dart” booster. XGBoost does not scale tree leaf directly, instead it saves the weights as a separated array. { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"definitions\": { \"gbtree\": { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"gbtree\" }, \"model\": { \"type\": \"object\", \"properties\": { \"gbtree_model_param\": { \"$ref\": \"#/definitions/gbtree_model_param\" }, \"trees\": { \"type\": \"array\", \"items\": { \"type\": \"object\", \"properties\": { \"tree_param\": { \"$ref\": \"#/definitions/tree_param\" }, \"id\": { \"type\": \"integer\" }, \"loss_changes\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } }, \"sum_hessian\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } }, \"base_weights\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } }, \"left_children\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"right_children\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"parents\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"split_indices\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"split_conditions\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } }, \"split_type\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"default_left\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"categories\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"categories_nodes\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"categories_segments\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } }, \"categories_sizes\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } } }, \"required\": [ \"tree_param\", \"loss_changes\", \"sum_hessian\", \"base_weights\", \"left_children\", \"right_children\", \"parents\", \"split_indices\", \"split_conditions\", \"default_left\", \"categories\", \"categories_nodes\", \"categories_segments\", \"categories_sizes\" ] } }, \"tree_info\": { \"type\": \"array\", \"items\": { \"type\": \"integer\" } } }, \"required\": [ \"gbtree_model_param\", \"trees\",", "prev_chunk_id": "chunk_550", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_552", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "JSON Schema", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "JSON Schema", "content": "\"tree_info\" ] } }, \"required\": [ \"name\", \"model\" ] }, \"gbtree_model_param\": { \"type\": \"object\", \"properties\": { \"num_trees\": { \"type\": \"string\" }, \"num_parallel_tree\": { \"type\": \"string\" } }, \"required\": [ \"num_trees\", \"num_parallel_tree\" ] }, \"tree_param\": { \"type\": \"object\", \"properties\": { \"num_nodes\": { \"type\": \"string\" }, \"size_leaf_vector\": { \"type\": \"string\" }, \"num_feature\": { \"type\": \"string\" } }, \"required\": [ \"num_nodes\", \"num_feature\", \"size_leaf_vector\" ] }, \"reg_loss_param\": { \"type\": \"object\", \"properties\": { \"scale_pos_weight\": { \"type\": \"string\" } } }, \"pseudo_huber_param\": { \"type\": \"object\", \"properties\": { \"huber_slope\": { \"type\": \"string\" } } }, \"aft_loss_param\": { \"type\": \"object\", \"properties\": { \"aft_loss_distribution\": { \"type\": \"string\" }, \"aft_loss_distribution_scale\": { \"type\": \"string\" } } }, \"softmax_multiclass_param\": { \"type\": \"object\", \"properties\": { \"num_class\": { \"type\": \"string\" } } }, \"lambda_rank_param\": { \"type\": \"object\", \"properties\": { \"num_pairsample\": { \"type\": \"string\" }, \"fix_list_weight\": { \"type\": \"string\" } } }, \"lambdarank_param\": { \"type\": \"object\", \"properties\": { \"lambdarank_num_pair_per_sample\": { \"type\": \"string\" }, \"lambdarank_pair_method\": { \"type\": \"string\" }, \"lambdarank_unbiased\": {\"type\": \"string\" }, \"lambdarank_bias_norm\": {\"type\": \"string\" }, \"ndcg_exp_gain\": {\"type\": \"string\"} } } }, \"type\": \"object\", \"properties\": { \"version\": { \"type\": \"array\", \"items\": [ { \"type\": \"number\", \"minimum\": 1 }, { \"type\": \"number\", \"minimum\": 0 }, { \"type\": \"number\", \"minimum\": 0 } ], \"minItems\": 3, \"maxItems\": 3 }, \"learner\": { \"type\": \"object\", \"properties\": { \"feature_names\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"feature_types\": { \"type\": \"array\", \"items\": { \"type\": \"string\" } }, \"gradient_booster\": { \"oneOf\": [ { \"$ref\": \"#/definitions/gbtree\" }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"gblinear\" }, \"model\": { \"type\": \"object\", \"properties\": { \"weights\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } } } } } }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"dart\" }, \"gbtree\": { \"$ref\": \"#/definitions/gbtree\" }, \"weight_drop\": { \"type\": \"array\", \"items\": { \"type\": \"number\" } } }, \"required\": [ \"name\", \"gbtree\", \"weight_drop\" ] } ] },", "prev_chunk_id": "chunk_551", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_553", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "JSON Schema", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "JSON Schema", "content": "\"objective\": { \"oneOf\": [ { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:squarederror\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:pseudohubererror\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:squaredlogerror\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:linear\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:logistic\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"binary:logistic\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"binary:logitraw\" }, \"reg_loss_param\": { \"$ref\": \"#/definitions/reg_loss_param\"} }, \"required\": [ \"name\", \"reg_loss_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"count:poisson\" }, \"poisson_regression_param\": { \"type\": \"object\", \"properties\": { \"max_delta_step\": { \"type\": \"string\" } } } }, \"required\": [ \"name\", \"poisson_regression_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:tweedie\" }, \"tweedie_regression_param\": { \"type\": \"object\", \"properties\": { \"tweedie_variance_power\": { \"type\": \"string\" } } } }, \"required\": [ \"name\", \"tweedie_regression_param\" ] }, { \"properties\": { \"name\": { \"const\": \"reg:absoluteerror\" } }, \"type\": \"object\" }, { \"properties\": { \"name\": { \"const\": \"reg:quantileerror\" }, \"quantile_loss_param\": { \"type\": \"object\", \"properties\": { \"quantle_alpha\": {\"type\": \"array\"} } } }, \"type\": \"object\" }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"survival:cox\" } }, \"required\": [ \"name\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"reg:gamma\" } }, \"required\": [ \"name\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"multi:softprob\" }, \"softmax_multiclass_param\": { \"$ref\": \"#/definitions/softmax_multiclass_param\"} }, \"required\": [ \"name\", \"softmax_multiclass_param\" ] }, {", "prev_chunk_id": "chunk_552", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_554", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/saving_model.html", "title": "JSON Schema", "page_title": "Introduction to Model IO — xgboost 3.0.4 documentation", "breadcrumbs": "JSON Schema", "content": "\"type\": \"object\", \"properties\": { \"name\": { \"const\": \"multi:softmax\" }, \"softmax_multiclass_param\": { \"$ref\": \"#/definitions/softmax_multiclass_param\"} }, \"required\": [ \"name\", \"softmax_multiclass_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"rank:pairwise\" }, \"lambda_rank_param\": { \"$ref\": \"#/definitions/lambdarank_param\"} }, \"required\": [ \"name\", \"lambdarank_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"rank:ndcg\" }, \"lambda_rank_param\": { \"$ref\": \"#/definitions/lambdarank_param\"} }, \"required\": [ \"name\", \"lambdarank_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": { \"const\": \"rank:map\" }, \"lambda_rank_param\": { \"$ref\": \"#/definitions/lambda_rank_param\"} }, \"required\": [ \"name\", \"lambda_rank_param\" ] }, { \"type\": \"object\", \"properties\": { \"name\": {\"const\": \"survival:aft\"}, \"aft_loss_param\": { \"$ref\": \"#/definitions/aft_loss_param\"} } }, { \"type\": \"object\", \"properties\": { \"name\": {\"const\": \"binary:hinge\"} } } ] }, \"learner_model_param\": { \"type\": \"object\", \"properties\": { \"base_score\": { \"type\": \"string\" }, \"num_class\": { \"type\": \"string\" }, \"num_feature\": { \"type\": \"string\" }, \"num_target\": { \"type\": \"string\" } } } }, \"required\": [ \"gradient_booster\", \"objective\" ] } }, \"required\": [ \"version\", \"learner\" ] }", "prev_chunk_id": "chunk_553", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_555", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Introduction to Boosted Trees", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Introduction to Boosted Trees", "content": "Introduction to Boosted Trees XGBoost stands for “Extreme Gradient Boosting”, where the term “Gradient Boosting” originates from the paper Greedy Function Approximation: A Gradient Boosting Machine, by Friedman. The term gradient boosted trees has been around for a while, and there are a lot of materials on the topic. This tutorial will explain boosted trees in a self-contained and principled way using the elements of supervised learning. We think this explanation is cleaner, more formal, and motivates the model formulation used in XGBoost.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_556", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Elements of Supervised Learning", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Elements of Supervised Learning", "content": "Elements of Supervised Learning XGBoost is used for supervised learning problems, where we use the training data (with multiple features) \\(x_i\\) to predict a target variable \\(y_i\\). Before we learn about trees specifically, let us start by reviewing the basic elements in supervised learning.", "prev_chunk_id": "chunk_555", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_557", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Model and Parameters", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Model and Parameters", "content": "Model and Parameters The model in supervised learning usually refers to the mathematical structure of by which the prediction \\(y_i\\) is made from the input \\(x_i\\). A common example is a linear model, where the prediction is given as \\(\\hat{y}_i = \\sum_j \\theta_j x_{ij}\\), a linear combination of weighted input features. The prediction value can have different interpretations, depending on the task, i.e., regression or classification. For example, it can be logistic transformed to get the probability of positive class in logistic regression, and it can also be used as a ranking score when we want to rank the outputs. The parameters are the undetermined part that we need to learn from data. In linear regression problems, the parameters are the coefficients \\(\\theta\\). Usually we will use \\(\\theta\\) to denote the parameters (there are many parameters in a model, our definition here is sloppy).", "prev_chunk_id": "chunk_556", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_558", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Objective Function: Training Loss + Regularization", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Objective Function: Training Loss + Regularization", "content": "Objective Function: Training Loss + Regularization With judicious choices for \\(y_i\\), we may express a variety of tasks, such as regression, classification, and ranking. The task of training the model amounts to finding the best parameters \\(\\theta\\) that best fit the training data \\(x_i\\) and labels \\(y_i\\). In order to train the model, we need to define the objective function to measure how well the model fit the training data. A salient characteristic of objective functions is that they consist of two parts: training loss and regularization term: where \\(L\\) is the training loss function, and \\(\\Omega\\) is the regularization term. The training loss measures how predictive our model is with respect to the training data. A common choice of \\(L\\) is the mean squared error, which is given by Another commonly used loss function is logistic loss, to be used for logistic regression: The regularization term is what people usually forget to add. The regularization term controls the complexity of the model, which helps us to avoid overfitting. This sounds a bit abstract, so let us consider the following problem in the following picture. You are asked to fit visually a step function given the input data points on the upper left corner of the image. Which solution among the three do you think is the best fit? The correct answer is marked in red. Please consider if this visually seems a reasonable fit to you. The general principle is we want both a simple and predictive model. The tradeoff between the two is also referred as bias-variance tradeoff in machine learning.", "prev_chunk_id": "chunk_557", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_559", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Why introduce the general principle?", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Why introduce the general principle?", "content": "Why introduce the general principle? The elements introduced above form the basic elements of supervised learning, and they are natural building blocks of machine learning toolkits. For example, you should be able to describe the differences and commonalities between gradient boosted trees and random forests. Understanding the process in a formalized way also helps us to understand the objective that we are learning and the reason behind the heuristics such as pruning and smoothing.", "prev_chunk_id": "chunk_558", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_560", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Decision Tree Ensembles", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Decision Tree Ensembles", "content": "Decision Tree Ensembles Now that we have introduced the elements of supervised learning, let us get started with real trees. To begin with, let us first learn about the model choice of XGBoost: decision tree ensembles. The tree ensemble model consists of a set of classification and regression trees (CART). Here’s a simple example of a CART that classifies whether someone will like a hypothetical computer game X. We classify the members of a family into different leaves, and assign them the score on the corresponding leaf. A CART is a bit different from decision trees, in which the leaf only contains decision values. In CART, a real score is associated with each of the leaves, which gives us richer interpretations that go beyond classification. This also allows for a principled, unified approach to optimization, as we will see in a later part of this tutorial. Usually, a single tree is not strong enough to be used in practice. What is actually used is the ensemble model, which sums the prediction of multiple trees together. Here is an example of a tree ensemble of two trees. The prediction scores of each individual tree are summed up to get the final score. If you look at the example, an important fact is that the two trees try to complement each other. Mathematically, we can write our model in the form where \\(K\\) is the number of trees, \\(f_k\\) is a function in the functional space \\(\\mathcal{F}\\), and \\(\\mathcal{F}\\) is the set of all possible CARTs. The objective function to be optimized is given by where \\(\\omega(f_k)\\) is the complexity of the tree \\(f_k\\), defined in detail later. Now here comes a trick question: what is the model used in random forests? Tree ensembles! So random forests and boosted trees are really", "prev_chunk_id": "chunk_559", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_561", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Decision Tree Ensembles", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Decision Tree Ensembles", "content": "the same models; the difference arises from how we train them. This means that, if you write a predictive service for tree ensembles, you only need to write one and it should work for both random forests and gradient boosted trees. (See Treelite for an actual example.) One example of why elements of supervised learning rock.", "prev_chunk_id": "chunk_560", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_562", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Tree Boosting", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Tree Boosting", "content": "Tree Boosting Now that we introduced the model, let us turn to training: How should we learn the trees? The answer is, as is always for all supervised learning models: define an objective function and optimize it! Let the following be the objective function (remember it always needs to contain training loss and regularization): in which \\(t\\) is the number of trees in our ensemble. (Each training step will add one new tree, so that at step \\(t\\) the ensemble contains \\(K=t\\) trees).", "prev_chunk_id": "chunk_561", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_563", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Additive Training", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Additive Training", "content": "Additive Training The first question we want to ask: what are the parameters of trees? You can find that what we need to learn are those functions \\(f_k\\), each containing the structure of the tree and the leaf scores. Learning tree structure is much harder than traditional optimization problem where you can simply take the gradient. It is intractable to learn all the trees at once. Instead, we use an additive strategy: fix what we have learned, and add one new tree at a time. We write the prediction value at step \\(t\\) as \\(\\hat{y}_i^{(t)}\\). Then we have It remains to ask: which tree do we want at each step? A natural thing is to add the one that optimizes our objective. If we consider using mean squared error (MSE) as our loss function, the objective becomes The form of MSE is friendly, with a first order term (usually called the residual) and a quadratic term. For other losses of interest (for example, logistic loss), it is not so easy to get such a nice form. So in the general case, we take the Taylor expansion of the loss function up to the second order: where the \\(g_i\\) and \\(h_i\\) are defined as After we remove all the constants, the specific objective at step \\(t\\) becomes This becomes our optimization goal for the new tree. One important advantage of this definition is that the value of the objective function only depends on \\(g_i\\) and \\(h_i\\). This is how XGBoost supports custom loss functions. We can optimize every loss function, including logistic regression and pairwise ranking, using exactly the same solver that takes \\(g_i\\) and \\(h_i\\) as input!", "prev_chunk_id": "chunk_562", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_564", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Model Complexity", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Model Complexity", "content": "Model Complexity We have introduced the training step, but wait, there is one important thing, the regularization term! We need to define the complexity of the tree \\(\\omega(f)\\). In order to do so, let us first refine the definition of the tree \\(f(x)\\) as Here \\(w\\) is the vector of scores on leaves, \\(q\\) is a function assigning each data point to the corresponding leaf, and \\(T\\) is the number of leaves. In XGBoost, we define the complexity as Of course, there is more than one way to define the complexity, but this one works well in practice. The regularization is one part most tree packages treat less carefully, or simply ignore. This was because the traditional treatment of tree learning only emphasized improving impurity, while the complexity control was left to heuristics. By defining it formally, we can get a better idea of what we are learning and obtain models that perform well in the wild.", "prev_chunk_id": "chunk_563", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_565", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "The Structure Score", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "The Structure Score", "content": "The Structure Score Here is the magical part of the derivation. After re-formulating the tree model, we can write the objective value with the \\(t\\)-th tree as: where \\(I_j = \\{i|q(x_i)=j\\}\\) is the set of indices of data points assigned to the \\(j\\)-th leaf. Notice that in the second line we have changed the index of the summation because all the data points on the same leaf get the same score. We could further compress the expression by defining \\(G_j = \\sum_{i\\in I_j} g_i\\) and \\(H_j = \\sum_{i\\in I_j} h_i\\): In this equation, \\(w_j\\) are independent with respect to each other, the form \\(G_jw_j+\\frac{1}{2}(H_j+\\lambda)w_j^2\\) is quadratic and the best \\(w_j\\) for a given structure \\(q(x)\\) and the best objective reduction we can get is: The last equation measures how good a tree structure \\(q(x)\\) is. If all this sounds a bit complicated, let’s take a look at the picture, and see how the scores can be calculated. Basically, for a given tree structure, we push the statistics \\(g_i\\) and \\(h_i\\) to the leaves they belong to, sum the statistics together, and use the formula to calculate how good the tree is. This score is like the impurity measure in a decision tree, except that it also takes the model complexity into account.", "prev_chunk_id": "chunk_564", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_566", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Learn the tree structure", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Learn the tree structure", "content": "Learn the tree structure Now that we have a way to measure how good a tree is, ideally we would enumerate all possible trees and pick the best one. In practice this is intractable, so we will try to optimize one level of the tree at a time. Specifically we try to split a leaf into two leaves, and the score it gains is This formula can be decomposed as 1) the score on the new left leaf 2) the score on the new right leaf 3) The score on the original leaf 4) regularization on the additional leaf. We can see an important fact here: if the gain is smaller than \\(\\gamma\\), we would do better not to add that branch. This is exactly the pruning techniques in tree based models! By using the principles of supervised learning, we can naturally come up with the reason these techniques work :) For real valued data, we usually want to search for an optimal split. To efficiently do so, we place all the instances in sorted order, like the following picture. A left to right scan is sufficient to calculate the structure score of all possible split solutions, and we can find the best split efficiently.", "prev_chunk_id": "chunk_565", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_567", "url": "https://xgboost.readthedocs.io/en/stable/tutorials/model.html", "title": "Final words on XGBoost", "page_title": "Introduction to Boosted Trees — xgboost 3.0.4 documentation", "breadcrumbs": "Final words on XGBoost", "content": "Final words on XGBoost Now that you understand what boosted trees are, you may ask, where is the introduction for XGBoost? XGBoost is exactly a tool motivated by the formal principle introduced in this tutorial! More importantly, it is developed with both deep consideration in terms of systems optimization and principles in machine learning. The goal of this library is to push the extreme of the computation limits of machines to provide a scalable, portable and accurate library. Make sure you try it out, and most importantly, contribute your piece of wisdom (code, examples, tutorials) to the community!", "prev_chunk_id": "chunk_566", "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_568", "url": "https://xgboost.readthedocs.io/en/stable/changes/index.html", "title": "Release Notes", "page_title": "Release Notes — xgboost 3.0.4 documentation", "breadcrumbs": "Release Notes", "content": "Release Notes For release notes prior to the 2.1 release, please see news .", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_569", "url": "https://xgboost.readthedocs.io/en/stable/contrib/index.html", "title": "Contribute to XGBoost", "page_title": "Contribute to XGBoost — xgboost 3.0.4 documentation", "breadcrumbs": "Contribute to XGBoost", "content": "Contribute to XGBoost XGBoost has been developed by community members. Everyone is welcome to contribute. We value all forms of contributions, including, but not limited to: - Code reviews for pull requests - Documentation and usage examples - Community participation in forums and issues - Code readability and developer guideWe welcome contributions that add code comments to improve readability.We also welcome contributions to docs to explain the design choices of the XGBoost internals. - Test cases to make the codebase more robust. - Tutorials, blog posts, talks that promote the project. Here are guidelines for contributing to various aspect of the XGBoost project:", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"},
{"chunk_id": "chunk_570", "url": "https://xgboost.readthedocs.io/en/stable/cli.html", "title": "XGBoost Command Line version", "page_title": "XGBoost Command Line version — xgboost 3.0.4 documentation", "breadcrumbs": "XGBoost Command Line version", "content": "XGBoost Command Line version See XGBoost Command Line walkthrough.", "prev_chunk_id": null, "next_chunk_id": null, "type": "section"}
]